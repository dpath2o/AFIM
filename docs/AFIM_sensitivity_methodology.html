<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>AFIM Sensitivity Methodology</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <style>body { max-width: 100%; margin: 1rem 2rem; }</style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">AFIM Sensitivity Methodology</h1>
</header>
<h1
id="methodology-antarctic-landfast-sea-ice-modelling-and-metrics">Methodology:
Antarctic (Land)Fast (Sea) Ice Modelling and Metrics</h1>
<p>This document describes the core methodologies implemented in the
AFIM (Antarctic Fast Ice Modelling) framework, corresponding to
functions and constructs in the repository <a
href="https://github.com/dpath2o/AFIM/tree/main/src"><code>src/</code></a>.</p>
<hr />
<p>When classifying fast ice from numerical model sea ice simulation
results, it is common practice to use sea ice concentration
(<code>aice</code>) and sea ice speed (<code>ispd</code>). The former is
a tracer variable derived on the spatial grid centre (commonly referred
to as the /T-grid/). In contrast, <code>ispd</code> is derived from the
momentum components (<code>u</code>, <code>v</code>), which are defined
at displaced locations relative to the /T-grid/, forming what is
referred to as the Arakawa /B-grid/. <a
href="https://raw.githubusercontent.com/dpath2o/AFIM/main/docs/figures/bgrid.png">This
figure</a> shows a depiction of the computational <a
href="https://doi.org/10.1016/B978-0-12-460817-7.50009-4">Arakawa
B-grid</a> in the vicinity of an island. Note that in this depiction,
only one grid cell has been masked out as land. This is important, as it
motivates the classification strategy: due to computational constraints,
a no-slip boundary is imposed on any velocity cell adjacent to land
(i.e., touching land). These velocity components are explicitly set to
<span class="math inline">\(0\)</span> by the model. Velocity is defined
on staggered /B-grid/ locations, this results in cells near the coast
having artificially zero speed regardless of the physical ice state.
This introduces ambiguity: a zero speed may result either from a valid
physical condition (e.g., grounded ice) or from an imposed boundary
condition.</p>
<p>In <a href="https://github.com/CICE-Consortium/CICE">CICE v6</a>, the
momentum equation evolves horizontal velocity components (<span
class="math inline">\(u\)</span>, <span
class="math inline">\(v\)</span>) under various forces:</p>
<p><span class="math display">\[
\rho h \frac{\partial \vec{u}}{\partial t} = \vec{\tau}_a + \vec{\tau}_o
- mf\hat{z} \times \vec{u} - mg\nabla H + \nabla \cdot
\boldsymbol{\sigma} - C_d \vec{u}
\]</span></p>
<p>Where: - <span class="math inline">\(\vec{u}\)</span> is ice velocity
- <span class="math inline">\(\vec{\tau}_a\)</span>, <span
class="math inline">\(\vec{\tau}_o\)</span> are wind and ocean stresses
- <span class="math inline">\(f\)</span> is the Coriolis parameter,
<span class="math inline">\(g\)</span> is gravity - <span
class="math inline">\(H\)</span> is surface height - <span
class="math inline">\(\boldsymbol{\sigma}\)</span> is the internal ice
stress tensor - <span class="math inline">\(C_d\)</span> is the drag
coefficient</p>
<p>In mathematical terms, the ice speed is computed as:</p>
<p><span class="math display">\[
|\vec{u}| = \sqrt{u^2 + v^2}
\]</span></p>
<p>But near land, either <span class="math inline">\(u = 0\)</span>,
<span class="math inline">\(v = 0\)</span>, or both are imposed, and so
<span class="math inline">\(|\vec{u}| = 0\)</span> even though ice may
not be landfast. Because of this, AFIM implements multiple strategies to
mitigate false classifications near land by using interpolated speeds or
spatially averaged approaches (see Sections 2.1 and 2.2**.</p>
<hr />
<h2 id="primary-classification">1. Primary Classification</h2>
<p>A grid cell is classified as fast ice if:</p>
<p><span class="math display">\[
a \geq a_\text{thresh} \quad \text{and} \quad |\vec{u}| \leq
u_\text{thresh}
\]</span></p>
<p>where: * <span class="math inline">\(a_\text{thresh} = 0.15\)</span>
(<strong>sea ice concentration threshold</strong>) * <span
class="math inline">\(u_\text{thresh} \in \{10^{-3}, 5 \times 10^{-4}\,
2.5 \times 10^{-4}}~\text{m/s}\)</span> (<strong>sea ice speed
threshold</strong>)</p>
<p>Fast ice is identified from sea ice concentration (<span
class="math inline">\(a\)</span>) and speed (<span
class="math inline">\(|\vec{u}|\)</span>) using multiple thresholding
methods.</p>
<p>Since we are masking (thresholding) values that are two grids (<span
class="math inline">\(a\)</span> is on the /T-grid/ and <span
class="math inline">\(\vec{u}\)</span> is on the /B-grid/) we need to
decide on either re-gridding <span class="math inline">\(a\)</span> to
the /B-grid/ or <span class="math inline">\(\vec{u}\)</span> to the
/T-grid/. Since the underlying landmask file that I have been using for
simulation is based on the /T-grid/ I choose to re-grid <span
class="math inline">\(u\)</span> and <span
class="math inline">\(v\)</span> sea ice velocity components to the
/T-grid/. Other established results (<a
href="https://doi.org/10.1002/2016JC012006">Lemieux et.al</a> and <a
href="https://doi.org/10.1016/j.ocemod.2021.101920">VanAchter et.al</a>)
have used this same approach. However, to be thorough in my reporting
and analysis I have chosen to preserve the non-re-gridded ice speeds and
hence have created the following four sea ice speed categories.</p>
<h3 id="ispd-categories">1.1 <code>ispd</code> categories:</h3>
<ol type="1">
<li><code>ispd_B</code> :: no re-gridding</li>
<li><code>ispd_Ta</code> :: spatially-averaged</li>
<li><code>ispd_Tx</code> :: spatially-weighted-average</li>
<li><code>ispd_BT</code> :: composite-mean of <code>ispd_B</code>,
<code>ispd_Ta</code> and <code>ispd_Tx</code></li>
</ol>
<h4 id="ispd_b">1.1.1 <code>ispd_B</code></h4>
<p>From <a
href="https://github.com/dpath2o/AFIM/blob/main/src/sea_ice_processor.py#L228"><code>ispd_B</code></a></p>
<p><span class="math display">\[
|\vec{u}|_B = \sqrt{u^2 + v^2}
\]</span></p>
<h4 id="ispd_ta">1.1.2 <code>ispd_Ta</code></h4>
<p>From <a
href="https://github.com/dpath2o/AFIM/blob/main/src/sea_ice_processor.py#L238"><code>ispd_Ta</code></a></p>
<p>To approximate the speed on the T-grid (<span
class="math inline">\(|\vec{u}|_T\)</span>), AFIM applies a spatial
average of the B-grid speed <span
class="math inline">\(|\vec{u}|_B\)</span> from the four surrounding
corners:</p>
<p><span class="math display">\[
|\vec{u}|_T(i,j) = \frac{1}{4} \Big[ |\vec{u}|_B(i,j) +
|\vec{u}|_B(i+1,j) + |\vec{u}|_B(i,j+1) + |\vec{u}|_B(i+1,j+1) \Big]
\]</span></p>
<p>This is equivalent to averaging the velocity magnitudes from the four
B-grid corners around a T-grid center, mitigating the impact of
single-point no-slip anomalies.</p>
<h4 id="ispd_tx">1.1.3 <code>ispd_Tx</code></h4>
<p>From <a
href="https://github.com/dpath2o/AFIM/blob/273090c740618e4db7a5d835e614fa855a9fc793/src/sea_ice_processor.py#L190"><code>ispd_Tx</code></a></p>
<p>More generally, this type of spatial interpolation is an instance of
<strong>bilinear interpolation</strong>, a common spatial re-gridding
method in numerical modeling. The bilinear interpolation at a point
<span class="math inline">\((x, y)\)</span> within a cell bounded by
<span class="math inline">\((x_1, y_1)\)</span>, <span
class="math inline">\((x_2, y_2)\)</span>, with values <span
class="math inline">\(Q_{11}\)</span>, <span
class="math inline">\(Q_{21}\)</span>, <span
class="math inline">\(Q_{12}\)</span>, <span
class="math inline">\(Q_{22}\)</span> at each corner, is given by:</p>
<p><span class="math display">\[
\begin{aligned}
f(x, y) &amp;= \frac{1}{(x_2 - x_1)(y_2 - y_1)} \Big[ \\
&amp;\quad Q_{11}(x_2 - x)(y_2 - y) + Q_{21}(x - x_1)(y_2 - y) \\
&amp;\quad + Q_{12}(x_2 - x)(y - y_1) + Q_{22}(x - x_1)(y - y_1) \Big]
\end{aligned}
\]</span></p>
<p>This expression performs linear interpolation in <span
class="math inline">\(x\)</span> followed by <span
class="math inline">\(y\)</span>, and provides smooth, continuous
estimates across grid cells while not necessarily conserving quantities
like mass or energy. More information on this specific method that I
used can be obtained from <a
href="https://earthsystemmodeling.org/regrid/">ESMF Regridding
Documentation</a> and <a
href="https://xesmf.readthedocs.io/en/latest/notebooks/Compare_algorithms.html">xESMF</a>.</p>
<h3 id="masking-methods">1.2 masking methods:</h3>
<p>From the above four <code>ispd</code> categories there are then two
temporal ways in which to apply the thresholding: 1. on daily-averaged
<span class="math inline">\(a\)</span> and <span
class="math inline">\(\vec{u}\)</span>, <strong>or</strong> 2.
N-day-average <span class="math inline">\(\bar{a}\)</span> and <span
class="math inline">\(\bar{\vec{u}}\)</span> 3. apply additional
criteria (see section 1.3 below)</p>
<p>Then classify/mask for fast ice using:</p>
<p><span class="math display">\[
FImask_{ispd-cat} = \bar{a} \geq a_\text{thresh} \quad \text{and} \quad
\bar{u} \leq u_\text{thresh}
\]</span> where <span class="math inline">\(u_{\text{thresh}}\)</span>
is one of the four sea ice speed categories: <code>ispd_B</code>,
<code>ispd_Ta</code>, <code>ispd_Tx</code>, or <code>ispd_BT</code>.</p>
<p>This results in eight different fast ice classifications (or
conversely <strong>pack ice</strong> classifications). Hence my naming
scheme I have chosen to use the following nomenclature for brevity and
remaining consistent with the underlying sea ice speed categories: 1.
<code>B</code>, <code>Ta</code>, <code>Tx</code>, <code>BT</code> ::
<strong>no</strong> temporal-averaging of <span
class="math inline">\(a\)</span> and <span
class="math inline">\(\vec{u}\)</span> 2. <code>B_roll</code>,
<code>Ta_roll</code>, <code>Tx_roll</code>, <code>BT_roll</code> ::
rolling-averaging of <span class="math inline">\(N\)</span>-days on {a}$
and <span class="math inline">\(\bar{\vec{u}}\)</span></p>
<p>An additional method for classifying fast ice was then proposed by
<span class="citation" data-cites="adfraser">@adfraser</span>, and that
is to use the daily-averaged <span class="math inline">\(a\)</span> and
<span class="math inline">\(\vec{u}\)</span> to create:
<code>FI_mask_B</code>, <code>FI_mask_Ta</code>, <code>FI_mask_Tx</code>
or <code>FI_mask_BT</code>). * Boolean (or binary-days) approach: 1.
take</p>
<h4 id="daily-average-method">1.2.1 daily-average method:</h4>
<p><a
href="https://github.com/dpath2o/AFIM/blob/273090c740618e4db7a5d835e614fa855a9fc793/src/sea_ice_processor.py#L434">Full
method</a></p>
<h4 id="rolling-average-method">1.2.2 rolling-average method:</h4>
<p>More generally the N-day-average that <a
href="https://github.com/dpath2o/AFIM/blob/273090c740618e4db7a5d835e614fa855a9fc793/src/sea_ice_processor.py#L540">I
employed</a> can be expressed as a rolling average over <span
class="math inline">\(N\)</span>-days (default <span
class="math inline">\(N=15\)</span>):</p>
<p><span class="math display">\[
\bar{a}(t) = \frac{1}{N} \sum_{\tau = t - N/2}^{t + N/2} a(\tau)
\]</span></p>
<h3 id="additional-criteria-imposed">1.3 Additional criteria
imposed:</h3>
<h4 id="re-apply-landmask">1.3.1 re-apply landmask:</h4>
<p>After either doing (or not doing the temporal averaging) the dataset
is then sub-set for particular hemisphere: <code>north</code> or
<code>south</code> (default <code>south</code>).</p>
<h4 id="hemisphere-masking">1.3.2 hemisphere masking:</h4>
<p>After either doing (or not doing the temporal averaging) the dataset
is then sub-set for particular hemisphere: <code>north</code> or
<code>south</code> (default <code>south</code>).</p>
<h3 id="rolling-mean-then-masking">1.2 Rolling Mean Then Masking</h3>
<p>From <a
href="https://github.com/dpath2o/AFIM/blob/main/src/sea_ice_processor.py#L287"><code>compute_fast_ice_rolling</code></a>:</p>
<hr />
<hr />
<h2 id="daily-vs.-rolling-averaged-workflow">3. Daily
vs. Rolling-Averaged Workflow</h2>
<h3 id="daily-processing">3.1 Daily Processing</h3>
<p>From <a
href="https://github.com/dpath2o/AFIM/blob/main/src/sea_ice_processor.py#L434"><code>process_daily_cice</code></a>:
Masking is applied directly to daily fields.</p>
<h3 id="rolling-averaged-processing">3.2 Rolling Averaged
Processing</h3>
<p>From <a
href="https://github.com/dpath2o/AFIM/blob/main/src/sea_ice_processor.py#L481"><code>process_rolling_cice</code></a>:
A rolling average is applied before thresholding.</p>
<hr />
<h2 id="fast-ice-metrics">4. Fast Ice Metrics</h2>
<p>Metrics are computed via <a
href="https://github.com/dpath2o/AFIM/blob/main/scripts/sea_ice_metrics/compute_fast_ice_metrics.py"><code>compute_fast_ice_metrics.py</code></a>,
with methods:</p>
<h3 id="fast-ice-area-fia">4.1 Fast Ice Area (FIA)</h3>
<p>From <a
href="https://github.com/dpath2o/AFIM/blob/main/src/sea_ice_processor.py#L620"><code>compute_fast_ice_area</code></a>:</p>
<p><span class="math display">\[
\text{FIA}(t) = \sum_{i,j} A_{i,j} M_{i,j}(t)
\]</span> Where: - <span class="math inline">\(M_{i,j}(t)\)</span> is
the boolean fast ice mask - <span class="math inline">\(A_{i,j}\)</span>
is the grid cell area</p>
<h3 id="fast-ice-concentration-fic">4.2 Fast Ice Concentration
(FIC)</h3>
<p>From <a
href="https://github.com/dpath2o/AFIM/blob/main/src/sea_ice_processor.py#L628"><code>compute_fast_ice_concentration</code></a>:</p>
<p><span class="math display">\[
\text{FIC}_{i,j}(t) = M_{i,j}(t) \cdot a_{i,j}(t)
\]</span></p>
<h3 id="fast-ice-thickness-fih">4.3 Fast Ice Thickness (FIH)</h3>
<p>From <a
href="https://github.com/dpath2o/AFIM/blob/main/src/sea_ice_processor.py#L636"><code>compute_fast_ice_thickness</code></a>:</p>
<p><span class="math display">\[
\text{FIH}_{i,j}(t) = M_{i,j}(t) \cdot h_{i,j}(t)
\]</span></p>
<hr />
<h2 id="threshold-sensitivity">5. Threshold Sensitivity</h2>
<p>AFIM supports experiments with multiple <span
class="math inline">\(u_\text{thresh}\)</span> values: - <span
class="math inline">\(10^{-3}~\text{m/s}\)</span> (default) - <span
class="math inline">\(5 \times 10^{-4}~\text{m/s}\)</span> (for
sensitivity testing)</p>
<p>These are applied to both boolean and rolling classifications.</p>
<hr />
<h2 id="source-files">📁 Source Files</h2>
<p>All methods above are implemented in: - <a
href="https://github.com/dpath2o/AFIM/blob/main/src/sea_ice_processor.py"><code>src/sea_ice_processor.py</code></a>
- <a
href="https://github.com/dpath2o/AFIM/blob/main/scripts/sea_ice_metrics/compute_fast_ice_metrics.py"><code>scripts/sea_ice_metrics/compute_fast_ice_metrics.py</code></a></p>
<p>See also: <code>config.json</code> files for applied thresholds and
flags.</p>
</body>
</html>
