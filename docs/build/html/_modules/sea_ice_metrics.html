

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sea_ice_metrics &mdash; AFIM 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=01f34227"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            AFIM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AFIM_sensitivity_methodology.html">Methodology: Antarctic (Land)Fast (Sea) Ice Modelling and Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lateral_drag_form_factor_creation.html">Coastal-drag form factors from high-resolution coastline and grounded icebergs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AFIM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">sea_ice_metrics</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sea_ice_metrics</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">gc</span><span class="o">,</span><span class="w"> </span><span class="nn">re</span><span class="o">,</span><span class="w"> </span><span class="nn">dask</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w">      </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w">       </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w">      </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w">       </span><span class="kn">import</span> <span class="n">Path</span>
<div class="viewcode-block" id="SeaIceMetrics">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SeaIceMetrics</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_clean_zarr_chunks</span><span class="p">(</span><span class="n">ds</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;chunks&#39;</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">encoding</span><span class="p">[</span><span class="s1">&#39;chunks&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="SeaIceMetrics.fast_ice_metrics_data_dict">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.fast_ice_metrics_data_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fast_ice_metrics_data_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FI_mask</span><span class="p">,</span> <span class="n">FI_data</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to create the dictionary for each FI type (dy, rl, bn).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;FI_mask&quot;</span>  <span class="p">:</span> <span class="n">FI_mask</span><span class="p">,</span>
                <span class="s1">&#39;aice&#39;</span>     <span class="p">:</span> <span class="n">FI_data</span><span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">],</span>
                <span class="s1">&#39;hi&#39;</span>       <span class="p">:</span> <span class="n">FI_data</span><span class="p">[</span><span class="s1">&#39;hi&#39;</span><span class="p">],</span>
                <span class="c1">#&#39;strength&#39; : FI_data[&#39;strength&#39;],</span>
                <span class="s1">&#39;dvidtt&#39;</span>   <span class="p">:</span> <span class="n">FI_data</span><span class="p">[</span><span class="s1">&#39;dvidtt&#39;</span><span class="p">],</span>
                <span class="s1">&#39;dvidtd&#39;</span>   <span class="p">:</span> <span class="n">FI_data</span><span class="p">[</span><span class="s1">&#39;dvidtd&#39;</span><span class="p">],</span>
                <span class="s1">&#39;daidtt&#39;</span>   <span class="p">:</span> <span class="n">FI_data</span><span class="p">[</span><span class="s1">&#39;daidtt&#39;</span><span class="p">],</span>
                <span class="s1">&#39;daidtd&#39;</span>   <span class="p">:</span> <span class="n">FI_data</span><span class="p">[</span><span class="s1">&#39;daidtd&#39;</span><span class="p">],</span>
                <span class="s1">&#39;tarea&#39;</span>    <span class="p">:</span> <span class="n">A</span><span class="p">}</span></div>



<div class="viewcode-block" id="SeaIceMetrics.pack_ice_metrics_data_dict">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.pack_ice_metrics_data_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pack_ice_metrics_data_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PI_mask</span><span class="p">,</span> <span class="n">PI_data</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="c1"># Utility function to create the dictionary for each PI type (dy, rl, bn).</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;PI_mask&quot;</span>  <span class="p">:</span> <span class="n">PI_mask</span><span class="p">,</span>
                <span class="s1">&#39;aice&#39;</span>     <span class="p">:</span> <span class="n">PI_data</span><span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">],</span>
                <span class="s1">&#39;hi&#39;</span>       <span class="p">:</span> <span class="n">PI_data</span><span class="p">[</span><span class="s1">&#39;hi&#39;</span><span class="p">],</span>
                <span class="c1">#&#39;strength&#39; : PI_data[&#39;strength&#39;],</span>
                <span class="s1">&#39;dvidtt&#39;</span>   <span class="p">:</span> <span class="n">PI_data</span><span class="p">[</span><span class="s1">&#39;dvidtt&#39;</span><span class="p">],</span>
                <span class="s1">&#39;dvidtd&#39;</span>   <span class="p">:</span> <span class="n">PI_data</span><span class="p">[</span><span class="s1">&#39;dvidtd&#39;</span><span class="p">],</span>
                <span class="s1">&#39;daidtt&#39;</span>   <span class="p">:</span> <span class="n">PI_data</span><span class="p">[</span><span class="s1">&#39;daidtt&#39;</span><span class="p">],</span>
                <span class="s1">&#39;daidtd&#39;</span>   <span class="p">:</span> <span class="n">PI_data</span><span class="p">[</span><span class="s1">&#39;daidtd&#39;</span><span class="p">],</span>
                <span class="s1">&#39;tarea&#39;</span>    <span class="p">:</span> <span class="n">A</span><span class="p">}</span></div>


<div class="viewcode-block" id="SeaIceMetrics.sea_ice_metrics_data_dict">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.sea_ice_metrics_data_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sea_ice_metrics_data_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SI_mask</span><span class="p">,</span> <span class="n">SI_data</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="c1"># Utility function to create the dictionary for SI (daily-only; no binary-day association).</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;SI_mask&quot;</span>  <span class="p">:</span> <span class="n">SI_mask</span><span class="p">,</span>
                <span class="s1">&#39;aice&#39;</span>     <span class="p">:</span> <span class="n">SI_data</span><span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">],</span>
                <span class="s1">&#39;hi&#39;</span>       <span class="p">:</span> <span class="n">SI_data</span><span class="p">[</span><span class="s1">&#39;hi&#39;</span><span class="p">],</span>
                <span class="c1">#&#39;strength&#39; : SI_data[&#39;strength&#39;],</span>
                <span class="s1">&#39;dvidtt&#39;</span>   <span class="p">:</span> <span class="n">SI_data</span><span class="p">[</span><span class="s1">&#39;dvidtt&#39;</span><span class="p">],</span>
                <span class="s1">&#39;dvidtd&#39;</span>   <span class="p">:</span> <span class="n">SI_data</span><span class="p">[</span><span class="s1">&#39;dvidtd&#39;</span><span class="p">],</span>
                <span class="s1">&#39;daidtt&#39;</span>   <span class="p">:</span> <span class="n">SI_data</span><span class="p">[</span><span class="s1">&#39;daidtt&#39;</span><span class="p">],</span>
                <span class="s1">&#39;daidtd&#39;</span>   <span class="p">:</span> <span class="n">SI_data</span><span class="p">[</span><span class="s1">&#39;daidtd&#39;</span><span class="p">],</span>
                <span class="s1">&#39;tarea&#39;</span>    <span class="p">:</span> <span class="n">A</span><span class="p">}</span></div>


<div class="viewcode-block" id="SeaIceMetrics.compute_sea_ice_metrics">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_sea_ice_metrics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_sea_ice_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da_dict</span><span class="p">,</span>
                                <span class="n">ice_type</span>       <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">dt0_str</span>        <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">dtN_str</span>        <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">P_mets_zarr</span>    <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">ice_area_scale</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sea ice metrics from a processed sea ice simulation and compare against observations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        da_dict : dict</span>
<span class="sd">            Dictionary containing xarray DataArrays or Datasets for the fields:</span>
<span class="sd">            &#39;aice&#39;, &#39;hi&#39;, &#39;tarea&#39;, and a corresponding mask (&#39;FI_mask&#39;, &#39;PI_mask&#39;, or &#39;SI_mask&#39;).</span>
<span class="sd">        ice_type : str, optional</span>
<span class="sd">            Type of ice to process (e.g., &#39;FI&#39;, &#39;FI_BT_bin&#39;, etc.). Will be cleaned internally.</span>
<span class="sd">        dt0_str : str, optional</span>
<span class="sd">            Start date of the analysis window in &#39;YYYY-MM-DD&#39;. Defaults to self.dt0_str.</span>
<span class="sd">        dtN_str : str, optional</span>
<span class="sd">            End date of the analysis window in &#39;YYYY-MM-DD&#39;. Defaults to self.dtN_str.</span>
<span class="sd">        P_mets_zarr : str or Path, optional</span>
<span class="sd">            Path to save Zarr archive of computed metrics. If None, uses default path.</span>
<span class="sd">        ice_area_scale : float, optional</span>
<span class="sd">            Scaling factor to apply to the area field. Defaults to self.FIC_scale.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.Dataset</span>
<span class="sd">            Dataset containing time series, spatial, and summary metrics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ice_type</span>       <span class="o">=</span> <span class="n">ice_type</span>  <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ice_type</span>
        <span class="n">dt0_str</span>        <span class="o">=</span> <span class="n">dt0_str</span>   <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt0_str</span>
        <span class="n">dtN_str</span>        <span class="o">=</span> <span class="n">dtN_str</span>   <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtN_str</span>
        <span class="n">P_mets_zarr</span>    <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">P_mets_zarr</span><span class="p">)</span> <span class="k">if</span> <span class="n">P_mets_zarr</span> <span class="k">else</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D_metrics</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type</span><span class="si">}</span><span class="s2">_mets.zarr&quot;</span><span class="p">)</span>
        <span class="n">ice_area_scale</span> <span class="o">=</span> <span class="n">ice_area_scale</span> <span class="k">if</span> <span class="n">ice_area_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIC_scale</span>
        <span class="n">spatial_dim_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s1">&#39;spatial_dims&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;¡¡¡ COMPUTING ICE METRICS for </span><span class="si">{</span><span class="n">ice_type</span><span class="si">}</span><span class="s2"> !!!&quot;</span><span class="p">)</span>
        <span class="n">ice_type_clean</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(_roll|_bin)?(_BT|_B|_Ta|_Tx)?$&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ice_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ice_type_clean</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;FI&quot;</span><span class="p">,</span> <span class="s2">&quot;PI&quot;</span><span class="p">,</span> <span class="s2">&quot;SI&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected cleaned ice_type: </span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;results will be written to </span><span class="si">{</span><span class="n">P_mets_zarr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">mask_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">_mask&quot;</span>
        <span class="k">if</span> <span class="n">mask_name</span> <span class="ow">in</span> <span class="n">da_dict</span><span class="p">:</span>
            <span class="n">I_mask</span> <span class="o">=</span> <span class="n">da_dict</span><span class="p">[</span><span class="n">mask_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;FI_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;PI_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;SI_mask&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">da_dict</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mask_name</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">I_mask</span> <span class="o">=</span> <span class="n">da_dict</span><span class="p">[</span><span class="n">mask_name</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mask key </span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">_mask not found; inferring </span><span class="si">{</span><span class="n">mask_name</span><span class="si">}</span><span class="s2"> from da_dict.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not resolve ice mask. Expected </span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">_mask, or exactly one of FI_mask/PI_mask/SI_mask. Found: </span><span class="si">{</span><span class="n">candidates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">I_C</span>       <span class="o">=</span> <span class="n">da_dict</span><span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">]</span>
        <span class="n">I_T</span>       <span class="o">=</span> <span class="n">da_dict</span><span class="p">[</span><span class="s1">&#39;hi&#39;</span><span class="p">]</span>
        <span class="c1">#I_S       = da_dict[&#39;strength&#39;]</span>
        <span class="n">I_TVT</span>     <span class="o">=</span> <span class="n">da_dict</span><span class="p">[</span><span class="s1">&#39;dvidtt&#39;</span><span class="p">]</span>
        <span class="n">I_MVT</span>     <span class="o">=</span> <span class="n">da_dict</span><span class="p">[</span><span class="s1">&#39;dvidtd&#39;</span><span class="p">]</span>
        <span class="n">I_TAT</span>     <span class="o">=</span> <span class="n">da_dict</span><span class="p">[</span><span class="s1">&#39;daidtt&#39;</span><span class="p">]</span>
        <span class="n">I_MAT</span>     <span class="o">=</span> <span class="n">da_dict</span><span class="p">[</span><span class="s1">&#39;daidtd&#39;</span><span class="p">]</span>
        <span class="n">A</span>         <span class="o">=</span> <span class="n">da_dict</span><span class="p">[</span><span class="s1">&#39;tarea&#39;</span><span class="p">]</span>
        <span class="c1"># --- Time Series Metrics ---</span>
        <span class="n">IA</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hemisphere_ice_area</span><span class="p">(</span><span class="n">I_C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">ice_area_scale</span><span class="o">=</span><span class="n">ice_area_scale</span><span class="p">)</span>
        <span class="n">IV</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hemisphere_ice_volume</span><span class="p">(</span><span class="n">I_C</span><span class="p">,</span> <span class="n">I_T</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">IT</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hemisphere_ice_thickness</span><span class="p">(</span><span class="n">I_C</span><span class="p">,</span> <span class="n">I_T</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="c1">#IS   = self.compute_hemisphere_ice_strength(I_C, I_T, I_S)</span>
        <span class="n">ITVR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hemisphere_ice_volume_rate</span><span class="p">(</span><span class="n">I_C</span><span class="p">,</span> <span class="n">I_TVT</span><span class="p">)</span>
        <span class="n">IMVR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hemisphere_ice_volume_rate</span><span class="p">(</span><span class="n">I_C</span><span class="p">,</span> <span class="n">I_MVT</span><span class="p">)</span>
        <span class="n">ITAR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hemisphere_ice_area_rate</span><span class="p">(</span><span class="n">I_TAT</span><span class="p">,</span> <span class="n">IA</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">IMAR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hemisphere_ice_area_rate</span><span class="p">(</span><span class="n">I_MAT</span><span class="p">,</span> <span class="n">IA</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">IP</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hemisphere_variable_aggregate</span><span class="p">(</span><span class="n">I_C</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;computing **ICE THICKNESS TEMPORAL-MEAN**&quot;</span><span class="p">)</span>
        <span class="n">IHI</span> <span class="o">=</span> <span class="n">I_T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">])</span>
        <span class="c1">#self.logger.info(&quot;computing **ICE STRENGTH TEMPORAL-SUM**; units mPa&quot;)</span>
        <span class="c1">#IST = (I_S/I_T).sum(dim=self.CICE_dict[&quot;time_dim&quot;]) / 1e6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;computing **ICE VOLUME TENDENCY (SPATIAL RATE)**; units m/yr&quot;</span><span class="p">)</span>
        <span class="n">ITVR_YR</span> <span class="o">=</span> <span class="p">(</span><span class="n">I_TVT</span><span class="o">*</span><span class="mf">1e2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.65</span>
        <span class="n">IMVR_YR</span> <span class="o">=</span> <span class="p">(</span><span class="n">I_MVT</span><span class="o">*</span><span class="mf">1e2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.65</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;computing **ICE AREA TENDENCY (SPATIAL RATE)**; units m/yr&quot;</span><span class="p">)</span>
        <span class="n">ITAR_YR</span> <span class="o">=</span> <span class="p">(</span><span class="n">I_TAT</span><span class="o">*</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mi">31_536_000</span>
        <span class="n">IMAR_YR</span> <span class="o">=</span> <span class="p">(</span><span class="n">I_MAT</span><span class="o">*</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mi">31_536_000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;loading data into output dictionary...&quot;</span><span class="p">)</span>
        <span class="n">METS</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">A&quot;</span>      <span class="p">:</span> <span class="n">IA</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>      <span class="c1">#1D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">V&quot;</span>      <span class="p">:</span> <span class="n">IV</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>      <span class="c1">#1D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">T&quot;</span>      <span class="p">:</span> <span class="n">IT</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>      <span class="c1">#1D</span>
                <span class="c1">#f&quot;{ice_type_clean}S&quot;      : IS.load(),      #1D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">TVR&quot;</span>    <span class="p">:</span> <span class="n">ITVR</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>    <span class="c1">#1D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">MVR&quot;</span>    <span class="p">:</span> <span class="n">IMVR</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>    <span class="c1">#1D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">TAR&quot;</span>    <span class="p">:</span> <span class="n">ITAR</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>    <span class="c1">#1D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">MAR&quot;</span>    <span class="p">:</span> <span class="n">IMAR</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>    <span class="c1">#1D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">P&quot;</span>      <span class="p">:</span> <span class="n">IP</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>      <span class="c1">#2D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">HI&quot;</span>     <span class="p">:</span> <span class="n">IHI</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>     <span class="c1">#2D</span>
                <span class="c1">#f&quot;{ice_type_clean}ST&quot;     : IST.load(),     #2D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">TVR_YR&quot;</span> <span class="p">:</span> <span class="n">ITVR_YR</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span> <span class="c1">#2D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">MVR_YR&quot;</span> <span class="p">:</span> <span class="n">IMVR_YR</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span> <span class="c1">#2D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">TAR_YR&quot;</span> <span class="p">:</span> <span class="n">ITAR_YR</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span> <span class="c1">#2D</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">MAR_YR&quot;</span> <span class="p">:</span> <span class="n">IMAR_YR</span><span class="o">.</span><span class="n">load</span><span class="p">()}</span> <span class="c1">#2D</span>
        <span class="c1"># --- Skill Statistics ---</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ice_type_clean</span> <span class="o">==</span> <span class="s2">&quot;FI&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;loading FI obs: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">AF_FI_dict</span><span class="p">[</span><span class="s1">&#39;P_AF2020_FIA&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">IA_obs</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AF_FI_dict</span><span class="p">[</span><span class="s1">&#39;P_AF2020_FIA&#39;</span><span class="p">],</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;netcdf4&quot;</span><span class="p">)[</span><span class="s2">&quot;AF2020&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ice_type_clean</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;PI&quot;</span><span class="p">,</span> <span class="s2">&quot;SI&quot;</span><span class="p">):</span>
                <span class="n">NSIDC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_NSIDC_metrics</span><span class="p">()</span>
                <span class="n">IA_obs</span> <span class="o">=</span> <span class="n">NSIDC</span><span class="p">[</span><span class="s1">&#39;SIA&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">IA_obs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">IA_obs</span>   <span class="o">=</span> <span class="n">IA_obs</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
            <span class="n">IA_skill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_skill_statistics</span><span class="p">(</span><span class="n">IA</span><span class="p">,</span> <span class="n">IA_obs</span><span class="p">)</span> <span class="k">if</span> <span class="n">IA_obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;compute_skill_statistics failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">IA_skill</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># --- Seasonal Statistics ---</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">IA_seasonal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_seasonal_statistics</span><span class="p">(</span><span class="n">IA</span><span class="p">,</span> <span class="n">stat_name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">A&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;compute_seasonal_statistics failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">IA_seasonal</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># --- Persistence Statistics ---</span>
        <span class="k">if</span> <span class="n">ice_type_clean</span> <span class="o">==</span> <span class="s2">&quot;FI&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">IP_stab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">persistence_stability_index</span><span class="p">(</span><span class="n">I_mask</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;persistence_stability_index failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">IP_stab</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">IP_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">persistence_ice_distance_mean_max</span><span class="p">(</span><span class="n">IP</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;persistence_ice_distance_mean_max failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">IP_dist</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">IP_stab</span><span class="p">,</span> <span class="n">IP_dist</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="c1"># --- Build Output Dataset ---</span>
        <span class="n">DS_METS</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">METS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
                <span class="n">DS_METS</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">DS_METS</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;nj&#39;</span><span class="p">,</span> <span class="s1">&#39;ni&#39;</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">DS_METS</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">DS_METS</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">())</span>
        <span class="c1"># --- Merge Metadata ---</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_clean</span><span class="si">}</span><span class="s2">A_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">IA_seasonal</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
                   <span class="o">**</span><span class="n">IP_stab</span><span class="p">,</span> <span class="o">**</span><span class="n">IP_dist</span><span class="p">,</span> <span class="o">**</span><span class="n">IA_skill</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_config</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">summary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_config</span><span class="p">:</span>
                <span class="n">DS_METS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">DS_METS</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">())</span>
        <span class="c1"># --- Save to Zarr ---</span>
        <span class="k">if</span> <span class="n">P_mets_zarr</span><span class="p">:</span>
            <span class="n">DS_METS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_zarr_chunks</span><span class="p">(</span><span class="n">DS_METS</span><span class="p">)</span>
            <span class="n">DS_METS</span><span class="o">.</span><span class="n">to_zarr</span><span class="p">(</span><span class="n">P_mets_zarr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">consolidated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zarr_format</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metrics written to </span><span class="si">{</span><span class="n">P_mets_zarr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DS_METS</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_subset_and_pad_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">dt0_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dtN_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                             <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="c1"># Nothing to do</span>
            <span class="k">return</span> <span class="n">ds</span>
        <span class="k">if</span> <span class="n">dt0_str</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dtN_str</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ds</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ds</span>
        <span class="c1"># Determine whether we&#39;re working with numpy datetime64 or cftime objects</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">is_datetime64</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span>
        <span class="c1"># Build start/end in matching type</span>
        <span class="k">if</span> <span class="n">is_datetime64</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">dt0_str</span><span class="p">)</span>
            <span class="n">end</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">dtN_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># cftime (dtype typically object)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">cftime</span>  <span class="c1"># noqa: F401</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Dataset time coordinate appears to be cftime/object, but cftime is not available.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
            <span class="c1"># Try to preserve calendar if present; default to &#39;standard&#39;</span>
            <span class="n">cal</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;calendar&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">t</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;calendar&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;standard&quot;</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">cftime_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">dt0_str</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="n">cal</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">end</span>   <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">cftime_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">dtN_str</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="n">cal</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Sanity</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Requested start &gt; end: </span><span class="si">{</span><span class="n">dt0_str</span><span class="si">}</span><span class="s2"> &gt; </span><span class="si">{</span><span class="n">dtN_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Infer step from dataset time (fallback: 1 day)</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_datetime64</span> <span class="k">else</span> <span class="nb">__import__</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Build the requested time axis (inclusive)</span>
        <span class="k">if</span> <span class="n">is_datetime64</span><span class="p">:</span>
            <span class="c1"># ensure inclusive end (np.arange is end-exclusive)</span>
            <span class="n">desired</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="n">step</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">desired</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">start</span>
            <span class="c1"># robust loop for cftime + timedelta</span>
            <span class="k">while</span> <span class="n">cur</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">desired</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">+</span> <span class="n">step</span>
            <span class="n">desired</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desired</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="c1"># Reindex onto the desired axis -&gt; pads with NaNs where outside original coverage</span>
        <span class="c1"># (keeps original values where they overlap)</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">reindex</span><span class="p">({</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">desired</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">ds_out</span>
    
<div class="viewcode-block" id="SeaIceMetrics.load_computed_metrics">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.load_computed_metrics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_computed_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">fast_ice_class_method</span> <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="s2">&quot;binary-days&quot;</span><span class="p">,</span>  <span class="c1"># &quot;raw&quot;, &quot;rolling-mean&quot;, &quot;binary-days&quot;</span>
                              <span class="n">BorC2T_type</span>           <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">ice_type</span>              <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">ispd_thresh</span>           <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">zarr_directory</span>        <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">clip_to_self</span>          <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                              <span class="n">time_dim</span>              <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">):</span>
        <span class="n">BorC2T_type</span> <span class="o">=</span> <span class="n">BorC2T_type</span>    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">BorC2T_type</span>
        <span class="n">ice_type</span>    <span class="o">=</span> <span class="n">ice_type</span>       <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ice_type</span>
        <span class="n">ispd_thresh</span> <span class="o">=</span> <span class="n">ispd_thresh</span>    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ispd_thresh</span>
        <span class="n">D_zarr</span>      <span class="o">=</span> <span class="n">zarr_directory</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_zarr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_classification_dir</span><span class="p">(</span><span class="n">ice_type</span> <span class="o">=</span> <span class="n">ice_type</span><span class="p">,</span> <span class="n">D_zarr</span> <span class="o">=</span> <span class="n">D_zarr</span><span class="p">,</span> <span class="n">ispd_thresh</span> <span class="o">=</span> <span class="n">ispd_thresh</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ice_type</span> <span class="o">==</span> <span class="s1">&#39;FI&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ice_type</span> <span class="o">==</span><span class="s1">&#39;PI&#39;</span><span class="p">):</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">define_fast_ice_class_name</span><span class="p">(</span><span class="n">BorC2T_type</span> <span class="o">=</span> <span class="n">BorC2T_type</span><span class="p">,</span> <span class="n">fast_ice_class_method</span> <span class="o">=</span> <span class="n">fast_ice_class_method</span><span class="p">)</span>
            <span class="n">P_mets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_class</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">FI_class</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics_name</span><span class="si">}</span><span class="s2">.zarr&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P_mets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_class</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics_name</span><span class="si">}</span><span class="s2">.zarr&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">P_mets</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clip_to_self</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subset_and_pad_time</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt0_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtN_str</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span></div>


<div class="viewcode-block" id="SeaIceMetrics.compute_hemisphere_ice_area_rate">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_hemisphere_ice_area_rate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hemisphere_ice_area_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DAT</span><span class="p">,</span> <span class="n">IA</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span>
                                           <span class="n">spatial_dim_names</span>  <span class="p">:</span> <span class="nb">list</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spatial_dim_names</span> <span class="o">=</span> <span class="n">spatial_dim_names</span> <span class="k">if</span> <span class="n">spatial_dim_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s1">&#39;spatial_dims&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing **DYNAMIC AREA TENDENCY** for hemisphere&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  • Spatial dimension names           : </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[Sea Ice Pressure Computation Steps]</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  1. multiply dynamic area tendency (1/s) by grid cell area (m^2) and sum</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  2. divide by ice area and volumetric scaling factor 1e9&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">DAT</span><span class="o">*</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spatial_dim_names</span><span class="p">)</span> <span class="o">/</span> <span class="n">IA</span> <span class="o">/</span> <span class="mf">1e9</span> <span class="c1"># m/s</span></div>


<div class="viewcode-block" id="SeaIceMetrics.compute_hemisphere_ice_volume_rate">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_hemisphere_ice_volume_rate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hemisphere_ice_volume_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SIC</span><span class="p">,</span> <span class="n">DVT</span><span class="p">,</span>
                                           <span class="n">spatial_dim_names</span>  <span class="p">:</span> <span class="nb">list</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                           <span class="n">sic_threshold</span>      <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sic_threshold</span>     <span class="o">=</span> <span class="n">sic_threshold</span>     <span class="k">if</span> <span class="n">sic_threshold</span>     <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span>
        <span class="n">spatial_dim_names</span> <span class="o">=</span> <span class="n">spatial_dim_names</span> <span class="k">if</span> <span class="n">spatial_dim_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s1">&#39;spatial_dims&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing **DYNAMIC VOLUME TENDENCY** for hemisphere&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  • Using SIC threshold               : </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  • Spatial dimension names           : </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[Sea Ice Pressure Computation Steps]</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  1. Apply SIC mask (SIC &gt; </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  2. Multiply by 100 cm/m, sum over spatial dims, then divide by seconds per day&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">SIC</span> <span class="o">&gt;</span> <span class="n">sic_threshold</span>
        <span class="n">DVT</span>  <span class="o">=</span> <span class="n">DVT</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">DVT</span><span class="o">*</span><span class="mf">1e2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spatial_dim_names</span><span class="p">)</span> <span class="o">/</span> <span class="mf">8.64e4</span> <span class="c1">#m/s</span></div>


<div class="viewcode-block" id="SeaIceMetrics.compute_hemisphere_ice_strength">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_hemisphere_ice_strength">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hemisphere_ice_strength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SIC</span><span class="p">,</span> <span class="n">HI</span><span class="p">,</span> <span class="n">IS</span><span class="p">,</span>
                                        <span class="n">spatial_dim_names</span>  <span class="p">:</span> <span class="nb">list</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">sic_threshold</span>      <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">ice_strength_scale</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute hemispheric mean sea ice pressure in hectopascals (hPa), based on masked concentration,</span>
<span class="sd">        thickness, strength, and area fields.</span>

<span class="sd">        This function calculates an area-weighted mean ice thickness (m) by dividing total</span>
<span class="sd">        ice volume by total ice-covered area. It then converts internal ice strength (N/m) </span>
<span class="sd">        into an equivalent pressure field (Pa = N/m²), and finally into hectopascals (hPa). </span>
<span class="sd">        Grid cells below a threshold sea ice concentration are masked from the analysis.</span>

<span class="sd">        INPUTS:</span>
<span class="sd">        -------------------</span>
<span class="sd">        SIC               : xr.DataArray; Sea ice concentration (unitless, typically 0–1), per grid cell.</span>
<span class="sd">        HI                : xr.DataArray; Sea ice thickness in meters, per grid cell.</span>
<span class="sd">        IS                : xr.DataArray; Internal ice strength in N/m, per grid cell.</span>
<span class="sd">        A                 : xr.DataArray; Grid cell area in m².</span>
<span class="sd">        spatial_dim_names : list, optional; Names of the spatial dimensions to reduce over (e.g., [&quot;nj&quot;, &quot;ni&quot;]).</span>
<span class="sd">                            If not provided, defaults to values in self.CICE_dict[&#39;spatial_dims&#39;].</span>
<span class="sd">        sic_threshold     : float, optional; Threshold for masking sea ice concentration (default: self.icon_thresh).</span>

<span class="sd">        OUTPUTS:</span>
<span class="sd">        -------</span>
<span class="sd">        P : xr.DataArray; Sea ice pressure in hectopascals (hPa), with masked cells excluded</span>
<span class="sd">            and computed as (IS / mean_thickness) / 100.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The output pressure is an approximation derived from CICE&#39;s internal strength field and is not a direct model output.</span>
<span class="sd">        - Use with caution where sea ice thickness is very small or near-zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sic_threshold</span>     <span class="o">=</span> <span class="n">sic_threshold</span>     <span class="k">if</span> <span class="n">sic_threshold</span>     <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span>
        <span class="n">spatial_dim_names</span> <span class="o">=</span> <span class="n">spatial_dim_names</span> <span class="k">if</span> <span class="n">spatial_dim_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s1">&#39;spatial_dims&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing **INTERNAL ICE PRESSURE** for hemisphere&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  • Using SIC threshold               : </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  • Spatial dimension names           : </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[Sea Ice Pressure Computation Steps]</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  1. Apply SIC mask (SIC &gt; </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  2. Divide internal ice strength (N/m = kg*m/s^2) by thickness (m) to get ice pressure (kg/m*s^2 = Pa) then divide by 100 to get hPa&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">SIC</span> <span class="o">&gt;</span> <span class="n">sic_threshold</span>
        <span class="n">HI</span>   <span class="o">=</span> <span class="n">HI</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">IS</span>   <span class="o">=</span> <span class="n">IS</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">IS</span> <span class="o">/</span> <span class="n">HI</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spatial_dim_names</span><span class="p">)</span> <span class="o">/</span> <span class="n">ice_strength_scale</span></div>


<div class="viewcode-block" id="SeaIceMetrics.compute_sector_ice_area">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_sector_ice_area">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_sector_ice_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I_mask</span><span class="p">,</span> <span class="n">area_grid</span><span class="p">,</span> <span class="n">sector_defs</span><span class="p">,</span> <span class="n">GI_area</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Compute ice area per geographic sector and a domain total, from an arbitrary ice mask.</span>
        <span class="c1"># This generalises compute_sector_FIA while preserving the original FI-specific wrapper.</span>
        <span class="k">if</span> <span class="n">GI_area</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_grounded_iceberg_area</span><span class="p">()</span>
            <span class="n">GI_ttl_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_grounded_iceberg_area</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1e6</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;adding </span><span class="si">{</span><span class="n">GI_ttl_area</span><span class="si">}</span><span class="s2"> to ice area computation&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">GI_ttl_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sector_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sector_defs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">ia_values</span>    <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sec_name</span> <span class="ow">in</span> <span class="n">sector_names</span><span class="p">:</span>
            <span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">,</span> <span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span> <span class="o">=</span> <span class="n">sector_defs</span><span class="p">[</span><span class="n">sec_name</span><span class="p">][</span><span class="s2">&quot;geo_region&quot;</span><span class="p">]</span>
            <span class="n">sec_mask</span> <span class="o">=</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="p">(</span><span class="n">area_grid</span><span class="o">.</span><span class="n">lon</span> <span class="o">&gt;=</span> <span class="n">lon_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">area_grid</span><span class="o">.</span><span class="n">lon</span> <span class="o">&lt;=</span> <span class="n">lon_max</span><span class="p">)</span> <span class="o">&amp;</span>
                <span class="p">(</span><span class="n">area_grid</span><span class="o">.</span><span class="n">lat</span> <span class="o">&gt;=</span> <span class="n">lat_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">area_grid</span><span class="o">.</span><span class="n">lat</span> <span class="o">&lt;=</span> <span class="n">lat_max</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sec_mask</span> <span class="o">*</span> <span class="n">area_grid</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;compute&quot;</span><span class="p">):</span>
                <span class="n">ia_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ia_val</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;item&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">ia_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia_val</span><span class="p">)</span>
        <span class="n">IA_da</span>  <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">ia_values</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sector&quot;</span><span class="p">],</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;sector&quot;</span><span class="p">:</span> <span class="n">sector_names</span><span class="p">})</span>
        <span class="n">IA_tot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ia_values</span><span class="p">)</span> <span class="o">+</span> <span class="n">GI_ttl_area</span>
        <span class="k">return</span> <span class="n">IA_da</span><span class="p">,</span> <span class="n">IA_tot</span></div>


<div class="viewcode-block" id="SeaIceMetrics.compute_sector_FIA">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_sector_FIA">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_sector_FIA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FI_mask</span><span class="p">,</span> <span class="n">area_grid</span><span class="p">,</span> <span class="n">sector_defs</span><span class="p">,</span> <span class="n">GI_area</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Backwards-compatible wrapper for fast-ice area (FIA).</span>

<span class="sd">        For new workflows, prefer `compute_sector_ice_area`, which is ice-type agnostic.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_sector_ice_area</span><span class="p">(</span><span class="n">FI_mask</span><span class="p">,</span> <span class="n">area_grid</span><span class="p">,</span> <span class="n">sector_defs</span><span class="p">,</span> <span class="n">GI_area</span><span class="o">=</span><span class="n">GI_area</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeaIceMetrics.compute_hemisphere_ice_area">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_hemisphere_ice_area">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hemisphere_ice_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SIC</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span>
                                    <span class="n">ice_area_scale</span>            <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">spatial_dim_names</span>         <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">sic_threshold</span>             <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">add_grounded_iceberg_area</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">grounded_iceberg_area</span>     <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">region</span>                    <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the total sea ice area (IA) by integrating sea ice concentration (SIC) over the grid area, and optionally </span>
<span class="sd">        including the grounded iceberg area (GI_total_area).</span>

<span class="sd">        This method computes the sea ice area by multiplying the sea ice concentration (SIC) by the grid cell area (GC_area),</span>
<span class="sd">        summing the result over the specified spatial dimensions, and optionally adding the grounded iceberg area. The final</span>
<span class="sd">        result is then scaled by an optional ice area scale factor.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        SIC : xarray.DataArray</span>
<span class="sd">            Sea ice concentration field with dimensions (nj, ni) representing the concentration of sea ice at each grid point.</span>
<span class="sd">            </span>
<span class="sd">        A : xarray.DataArray</span>
<span class="sd">            Grid cell area with the same dimensions (nj, ni) as SIC, representing the area of each grid cell in square meters.</span>
<span class="sd">            </span>
<span class="sd">        ice_area_scale : float, optional</span>
<span class="sd">            A scale factor for the sea ice area calculation. If not provided, the default scale is used from the `FIC_scale` attribute.</span>
<span class="sd">            </span>
<span class="sd">        spatial_dim_names : list of str, optional</span>
<span class="sd">            The dimension names over which to sum the sea ice area (typically latitude and longitude). If not provided, the default spatial dimensions </span>
<span class="sd">            are used from the `CICE_dict` attribute.</span>

<span class="sd">        sic_threshold : float, optional</span>
<span class="sd">            Minimum SIC value to be included in the area calculation. Points with SIC below this threshold are excluded.</span>
<span class="sd">            Defaults to `self.icon_thresh`.</span>
<span class="sd">            </span>
<span class="sd">        add_grounded_iceberg_area : bool, optional</span>
<span class="sd">            A flag indicating whether to include the grounded iceberg area in the ice area calculation. Defaults to the class attribute `use_gi`.</span>
<span class="sd">            </span>
<span class="sd">        grounded_iceberg_area : float, optional</span>
<span class="sd">            The grounded iceberg area in square meters to be added to the sea ice area. If not provided, the grounded iceberg area is computed using </span>
<span class="sd">            `compute_grounded_iceberg_area()`.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        IA : xarray.DataArray</span>
<span class="sd">            The total sea ice area, including the optional grounded iceberg area, with the same spatial dimensions as SIC and GC_area.</span>
<span class="sd">            The value is returned after summing over the spatial dimensions and scaling by the provided `ice_area_scale`.</span>

<span class="sd">        Notes:</span>
<span class="sd">        ------</span>
<span class="sd">        - The grounded iceberg area is added to the sea ice area calculation if `add_grounded_iceberg_area` is `True`. If no grounded iceberg area </span>
<span class="sd">        is provided, the method will compute it using the `compute_grounded_iceberg_area()` method.</span>
<span class="sd">        - The sea ice area is computed as the sum of SIC * GC_area across the specified spatial dimensions, and then scaled by `ice_area_scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">add_grounded_iceberg_area</span> <span class="o">=</span> <span class="n">add_grounded_iceberg_area</span> <span class="k">if</span> <span class="n">add_grounded_iceberg_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gi</span>
        <span class="n">sic_threshold</span>             <span class="o">=</span> <span class="n">sic_threshold</span>             <span class="k">if</span> <span class="n">sic_threshold</span>             <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span>
        <span class="n">spatial_dim_names</span>         <span class="o">=</span> <span class="n">spatial_dim_names</span>         <span class="k">if</span> <span class="n">spatial_dim_names</span>         <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s1">&#39;spatial_dims&#39;</span><span class="p">]</span>
        <span class="n">ice_area_scale</span>            <span class="o">=</span> <span class="n">ice_area_scale</span>            <span class="k">if</span> <span class="n">ice_area_scale</span>            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIC_scale</span>
        <span class="k">if</span> <span class="n">region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing Ice **AREA** for </span><span class="si">{</span><span class="n">region</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing Ice **AREA** &quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  • Using SIC threshold               : </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  • Spatial dimension names           : </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  • Ice area scaling factor           : </span><span class="si">{</span><span class="n">ice_area_scale</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> (to convert m² → km² or other units)</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  • Include grounded iceberg area     : </span><span class="si">{</span><span class="n">add_grounded_iceberg_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_grounded_iceberg_area</span><span class="p">:</span>
            <span class="n">GI_total_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">grounded_iceberg_area</span> <span class="k">if</span> <span class="n">grounded_iceberg_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_grounded_iceberg_area</span><span class="p">()</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">GI_total_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[Sea Ice Area Computation Steps]</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  1. Apply SIC mask (SIC &gt; </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  2. Multiply SIC × area and sum over </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  3. Add grounded iceberg area (GIA) = </span><span class="si">{</span><span class="n">GI_total_area</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> m²</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  4. Divide by scale factor </span><span class="si">{</span><span class="n">ice_area_scale</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> to convert units&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">SIC</span> <span class="o">&gt;</span> <span class="n">sic_threshold</span>
        <span class="n">SIC</span>  <span class="o">=</span> <span class="n">SIC</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">A</span>    <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">IA</span>   <span class="o">=</span> <span class="p">((</span><span class="n">SIC</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spatial_dim_names</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">IA</span> <span class="o">+</span> <span class="n">GI_total_area</span><span class="p">)</span> <span class="o">/</span> <span class="n">ice_area_scale</span> </div>


<div class="viewcode-block" id="SeaIceMetrics.compute_hemisphere_ice_volume">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_hemisphere_ice_volume">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hemisphere_ice_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SIC</span><span class="p">,</span> <span class="n">HI</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span>
                                      <span class="n">add_grounded_iceberg_area</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">ice_volume_scale</span>          <span class="o">=</span> <span class="mf">1e12</span><span class="p">,</span> 
                                      <span class="n">spatial_dim_names</span>         <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">sic_threshold</span>             <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">grounded_iceberg_area</span>     <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute total sea ice volume by integrating sea ice concentration, thickness, and grid cell area.</span>

<span class="sd">        This method calculates the total sea ice volume as the sum of the product of sea ice concentration (SIC),</span>
<span class="sd">        thickness (HI), and grid cell area (GC_area) across the model domain. A SIC threshold can be applied to exclude</span>
<span class="sd">        grid cells with low concentrations. Optionally includes grounded iceberg volume and applies a scaling factor </span>
<span class="sd">        for unit conversion.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        SIC : xarray.DataArray</span>
<span class="sd">            Sea ice concentration (unitless, typically between 0 and 1).</span>
<span class="sd">            </span>
<span class="sd">        HI : xarray.DataArray</span>
<span class="sd">            Sea ice thickness in meters.</span>
<span class="sd">            </span>
<span class="sd">        A : xarray.DataArray</span>
<span class="sd">            Grid cell area in square meters (m²).</span>

<span class="sd">        ice_volume_scale : float, optional</span>
<span class="sd">            Scale factor for the output volume. Default is `1e12`, converting m³ to 1000 km³.</span>

<span class="sd">        spatial_dim_names : list of str, optional</span>
<span class="sd">            Names of spatial dimensions to sum over (e.g., [&#39;nj&#39;, &#39;ni&#39;]). Defaults to `self.CICE_dict[&#39;spatial_dims&#39;]`.</span>

<span class="sd">        sic_threshold : float, optional</span>
<span class="sd">            Minimum SIC value to be included in the volume calculation. Grid cells with SIC ≤ `sic_threshold` are masked.</span>
<span class="sd">            Defaults to `self.icon_thresh`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Total sea ice volume, optionally including grounded ice and scaled (e.g., in 1000 km³ if default scale is used).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - SIC, HI, and GC_area must share the same grid and be broadcastable.</span>
<span class="sd">        - Grid cells below `sic_threshold` are excluded from the volume calculation.</span>
<span class="sd">        - If `self.use_gi` is True, a grounded iceberg area is converted to volume and included.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">add_grounded_iceberg_area</span> <span class="o">=</span> <span class="n">add_grounded_iceberg_area</span> <span class="k">if</span> <span class="n">add_grounded_iceberg_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gi</span>
        <span class="n">spatial_dim_names</span>         <span class="o">=</span> <span class="n">spatial_dim_names</span>         <span class="k">if</span> <span class="n">spatial_dim_names</span>         <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s1">&#39;spatial_dims&#39;</span><span class="p">]</span>
        <span class="n">sic_threshold</span>             <span class="o">=</span> <span class="n">sic_threshold</span>             <span class="k">if</span> <span class="n">sic_threshold</span>             <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing Ice **VOLUME** &quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  • Using SIC threshold               : </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  • Spatial dimension names           : </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  • Ice volume scaling factor         : </span><span class="si">{</span><span class="n">ice_volume_scale</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> (to convert </span><span class="si">{</span><span class="mf">1e6</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">-km^3)</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  • Include grounded iceberg area     : </span><span class="si">{</span><span class="n">add_grounded_iceberg_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_grounded_iceberg_area</span><span class="p">:</span>
            <span class="n">GI_total_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">grounded_iceberg_area</span> <span class="k">if</span> <span class="n">grounded_iceberg_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_grounded_iceberg_area</span><span class="p">()</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">GI_total_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[Sea Ice Volume Computation Steps]</span><span class="se">\n</span><span class="s2">&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;  1. Apply SIC mask (SIC &gt; </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;  2. Multiply SIC × thickness × area and sum over </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;  3. Add grounded iceberg area (GIA) = </span><span class="si">{</span><span class="n">GI_total_area</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> m²</span><span class="se">\n</span><span class="s2">&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;  4. Divide by scale factor </span><span class="si">{</span><span class="n">ice_volume_scale</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> to convert units&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">SIC</span> <span class="o">&gt;</span> <span class="n">sic_threshold</span>
        <span class="n">HI</span>   <span class="o">=</span> <span class="n">HI</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">SIC</span>  <span class="o">=</span> <span class="n">SIC</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">A</span>    <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">IV</span>   <span class="o">=</span> <span class="p">(</span><span class="n">SIC</span> <span class="o">*</span> <span class="n">HI</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spatial_dim_names</span><span class="p">)</span><span class="c1">#.chunk({&#39;time&#39;: -1}).compute()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">IV</span> <span class="o">+</span> <span class="n">GI_total_area</span><span class="p">)</span> <span class="o">/</span> <span class="n">ice_volume_scale</span> </div>


<div class="viewcode-block" id="SeaIceMetrics.compute_hemisphere_ice_thickness">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_hemisphere_ice_thickness">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hemisphere_ice_thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SIC</span><span class="p">,</span> <span class="n">HI</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> 
                                         <span class="n">spatial_dim_names</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                         <span class="n">sic_threshold</span>     <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute average sea ice thickness weighted by grid cell area and sea ice concentration.</span>

<span class="sd">        This method calculates the domain-averaged sea ice thickness as the ratio of the total sea ice volume to </span>
<span class="sd">        the total sea ice area. A SIC threshold is used to exclude low-concentration grid cells from both the numerator </span>
<span class="sd">        and denominator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        HI : xarray.DataArray</span>
<span class="sd">            Sea ice thickness in meters.</span>

<span class="sd">        SIC : xarray.DataArray</span>
<span class="sd">            Sea ice concentration (unitless, typically between 0 and 1).</span>

<span class="sd">        GC_area : xarray.DataArray</span>
<span class="sd">            Grid cell area in square meters (m²).</span>

<span class="sd">        spatial_dim_names : list of str, optional</span>
<span class="sd">            Names of spatial dimensions over which to compute the sums. Defaults to `self.CICE_dict[&#39;spatial_dims&#39;]`.</span>

<span class="sd">        sic_threshold : float, optional</span>
<span class="sd">            Minimum SIC value to include in the average. Grid cells with SIC ≤ `sic_threshold` are excluded.</span>
<span class="sd">            Defaults to `self.icon_thresh`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or xarray.DataArray</span>
<span class="sd">            Domain-averaged sea ice thickness, computed as the total volume divided by total area.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Computed as: ∑(HI × area) / ∑(SIC × area), with masking by `sic_threshold`.</span>
<span class="sd">        - Excludes cells with SIC below threshold from both numerator and denominator.</span>
<span class="sd">        - Units are in meters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spatial_dim_names</span> <span class="o">=</span> <span class="n">spatial_dim_names</span> <span class="k">if</span> <span class="n">spatial_dim_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s1">&#39;spatial_dims&#39;</span><span class="p">]</span>
        <span class="n">sic_threshold</span>     <span class="o">=</span> <span class="n">sic_threshold</span>     <span class="k">if</span> <span class="n">sic_threshold</span>     <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing Ice **THICKNESS** &quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  • Using SIC threshold               : </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;  • Spatial dimension names           : </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[Sea Ice Thickness Computation Steps]</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  1. Apply SIC mask (SIC &gt; </span><span class="si">{</span><span class="n">sic_threshold</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  2. Compute ice area: Multiply SIC × area and sum over </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  3. Compute ice volume: Multiply SIC × thickness × area and sum over </span><span class="si">{</span><span class="n">spatial_dim_names</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  4. Divide by area / volume = thickness in metres&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">SIC</span> <span class="o">&gt;</span> <span class="n">sic_threshold</span>
        <span class="n">HI</span>   <span class="o">=</span> <span class="n">HI</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">SIC</span>  <span class="o">=</span> <span class="n">SIC</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">A</span>    <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">IA</span>   <span class="o">=</span> <span class="p">(</span><span class="n">SIC</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spatial_dim_names</span><span class="p">)</span>
        <span class="n">IV</span>   <span class="o">=</span> <span class="p">(</span><span class="n">HI</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spatial_dim_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">IV</span> <span class="o">/</span> <span class="n">IA</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeaIceMetrics.compute_hemisphere_variable_aggregate">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_hemisphere_variable_aggregate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hemisphere_variable_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">time_coord_name</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">flat_mean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">da2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a time-aggregated field from a DataArray across the specified time dimension.</span>

<span class="sd">        This method calculates the mean of the input variable over time, with an optional</span>
<span class="sd">        normalisation step based on the maximum value across the time dimension.</span>
<span class="sd">        Designed for Dask-backed DataArrays to support scalable computation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        da : xarray.DataArray</span>
<span class="sd">            Input data array to aggregate over time. Typically a geophysical variable such as</span>
<span class="sd">            sea ice thickness (m), strength (N/m), or velocity (m/s), with time as one of the dimensions.</span>
<span class="sd">        time_coord_name : str, optional</span>
<span class="sd">            Name of the time dimension to aggregate over. Default is &#39;time&#39;.</span>
<span class="sd">        flat_mean : bool, optional</span>
<span class="sd">            If True, the data has simple mean over time, Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            A time-aggregated version of the input array. If `normalise_max` is True,</span>
<span class="sd">            the result represents the normalised mean occurrence across the time dimension;</span>
<span class="sd">            otherwise, it is the simple time mean.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If the specified `time_coord_name` is not found in the input DataArray,</span>
<span class="sd">        the original array is returned with a warning.</span>
<span class="sd">        - If `normalise_max` is enabled, the output represents a relative frequency-like</span>
<span class="sd">        measure, especially useful for thresholded or binary input fields (e.g., fast ice presence).</span>
<span class="sd">        - Assumes that all non-time dimensions are to be preserved in the output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing Ice **AGGREGATE OVER TIME** (percentage of occurence)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_coord_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No time dimension &#39;</span><span class="si">{</span><span class="n">time_coord_name</span><span class="si">}</span><span class="s2">&#39; found. Returning original array.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">da</span>
        <span class="n">time_len</span> <span class="o">=</span> <span class="n">da</span><span class="p">[</span><span class="n">time_coord_name</span><span class="p">]</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">time_coord_name</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flat_mean</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">time_coord_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">da2</span> <span class="ow">and</span> <span class="n">scale</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">da</span><span class="o">/</span><span class="n">da2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">time_coord_name</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">time_coord_name</span><span class="p">)</span> <span class="o">/</span> <span class="n">time_len</span></div>


    <span class="c1"># SEASONAL METRICS</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ensure_odd</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_safe_slope</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_days</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">scaling</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Least-squares slope without polyfit overhead; returns None if flat/NaN.&quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">t_days</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t_days</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># improves conditioning</span>
        <span class="n">t_mean</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">y_mean</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">t</span> <span class="o">-</span> <span class="n">t_mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">t</span> <span class="o">-</span> <span class="n">t_mean</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_mean</span><span class="p">))</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">slope</span> <span class="o">*</span> <span class="n">scaling</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_year_index_slices</span><span class="p">(</span><span class="n">times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">years</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">values</span>
        <span class="n">uniq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">years</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">years</span> <span class="o">==</span> <span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">uniq</span><span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_drop_leap_day</span><span class="p">(</span><span class="n">times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="c1"># Remove Feb 29 for DOY-consistent filters</span>
        <span class="n">di</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">di</span><span class="o">.</span><span class="n">month</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">di</span><span class="o">.</span><span class="n">day</span> <span class="o">==</span> <span class="mi">29</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">[</span><span class="n">keep</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_summary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="SeaIceMetrics.compute_seasonal_statistics">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_seasonal_statistics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_seasonal_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span>
                                    <span class="n">stat_name</span>           <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;FIA&#39;</span><span class="p">,</span>
                                    <span class="n">window</span>              <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
                                    <span class="n">polyorder</span>           <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                                    <span class="n">min_onset_doy</span>       <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                                    <span class="n">min_retreat_doy</span>     <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">240</span><span class="p">,</span>
                                    <span class="n">growth_range</span>        <span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">71</span><span class="p">,</span> <span class="mi">273</span><span class="p">),</span>
                                    <span class="n">retreat_early_range</span> <span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">273</span><span class="p">,</span> <span class="mi">330</span><span class="p">),</span>
                                    <span class="n">retreat_late_range</span>  <span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">331</span><span class="p">,</span> <span class="mi">365</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">71</span><span class="p">)),</span>
                                    <span class="n">scaling_factor</span>      <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">,</span>
                                    <span class="n">drop_leap_day</span>       <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">return_per_year</span>     <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast version that loads once, computes derivatives once per year, and uses NumPy slicing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        da : xr.DataArray  # 1D, daily, with &#39;time&#39;</span>
<span class="sd">        window, polyorder, min_onset_doy, min_retreat_doy : as before</span>
<span class="sd">        growth_range, retreat_early_range, retreat_late_range : as before</span>
<span class="sd">        scaling_factor : float  # multiplies slopes for nicer units</span>
<span class="sd">        drop_leap_day : bool    # remove Feb 29 to keep DOY logic simple</span>
<span class="sd">        return_per_year : bool  # also return a per-year table if True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : dict[str, float | None]</span>
<span class="sd">        (optional) per_year : pandas.DataFrame  # one row per year (except last, by design)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">savgol_filter</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w">         </span><span class="kn">import</span> <span class="n">tqdm</span>
        <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input DataArray must have a &#39;time&#39; dimension&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;computing SEASONAL STATISTICS for </span><span class="si">{</span><span class="n">stat_name</span><span class="si">}</span><span class="s2"> ... &quot;</span><span class="p">)</span>
        <span class="c1"># 1) Load once (small 1D array) and optionally drop leap days</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;   1. loading array &quot;</span><span class="p">)</span>
        <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>  <span class="c1"># safe for 1D daily series</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_full</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;   2. drop leap-days&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_leap_day</span><span class="p">:</span>
            <span class="n">times</span><span class="p">,</span> <span class="n">y_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drop_leap_day</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">y_full</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;   3. compute DOY indeces once&quot;</span><span class="p">)</span>
        <span class="n">doy_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">.</span><span class="n">dayofyear</span><span class="o">.</span><span class="n">values</span>
        <span class="n">idx_by_year</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_year_index_slices</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="n">years_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx_by_year</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;   4. prepare statistical lists&quot;</span><span class="p">)</span>
        <span class="n">per_year_rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_list</span><span class="p">,</span> <span class="n">min_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">grow_list</span><span class="p">,</span> <span class="n">ret_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">ret_early_list</span><span class="p">,</span> <span class="n">ret_late_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">min_doy_list</span><span class="p">,</span> <span class="n">max_doy_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">onset_list</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="n">duration_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;   5. Ensure Savitzky–Golay (savgol) settings are valid&quot;</span><span class="p">)</span>
        <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_odd</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">window</span> <span class="o">&lt;</span> <span class="n">polyorder</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">polyorder</span> <span class="o">+</span> <span class="mi">3</span> <span class="k">if</span> <span class="p">(</span><span class="n">polyorder</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">polyorder</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;   6. compute derivatives once per-year&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">year</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">years_sorted</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     ....</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">idx_this</span> <span class="o">=</span> <span class="n">idx_by_year</span><span class="p">[</span><span class="n">year</span><span class="p">]</span>
            <span class="n">idx_next</span> <span class="o">=</span> <span class="n">idx_by_year</span><span class="p">[</span><span class="n">years_sorted</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">t_this</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_this</span><span class="p">]</span>
            <span class="n">y_this</span> <span class="o">=</span> <span class="n">y_full</span><span class="p">[</span><span class="n">idx_this</span><span class="p">]</span>
            <span class="n">doy_this</span> <span class="o">=</span> <span class="n">doy_full</span><span class="p">[</span><span class="n">idx_this</span><span class="p">]</span>
            <span class="c1"># Skip tiny years</span>
            <span class="k">if</span> <span class="n">y_this</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># Derivatives once per year</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dy_dt</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">y_this</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">polyorder</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
                <span class="n">d2y_dt2</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">y_this</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">polyorder</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># window too long for this year, skip</span>
                <span class="k">continue</span>
            <span class="c1"># --- Max/Min &amp; their DOY ---</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_this</span><span class="p">)):</span>
                <span class="c1"># skip year with all NaN</span>
                <span class="k">continue</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">y_this</span><span class="p">))</span>
                <span class="n">min_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">y_this</span><span class="p">))</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y_this</span><span class="p">[</span><span class="n">max_idx</span><span class="p">])</span>
            <span class="n">min_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y_this</span><span class="p">[</span><span class="n">min_idx</span><span class="p">])</span>
            <span class="n">max_doy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">doy_this</span><span class="p">[</span><span class="n">max_idx</span><span class="p">])</span>
            <span class="n">min_doy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">doy_this</span><span class="p">[</span><span class="n">min_idx</span><span class="p">])</span>
            <span class="n">max_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_val</span><span class="p">);</span> <span class="n">min_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_val</span><span class="p">)</span>
            <span class="n">max_doy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_doy</span><span class="p">);</span> <span class="n">min_doy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_doy</span><span class="p">)</span>
            <span class="c1"># --- Onset via derivative (first positive slope after min_onset_doy) ---</span>
            <span class="n">onset_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">((</span><span class="n">dy_dt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">doy_this</span> <span class="o">&gt;=</span> <span class="n">min_onset_doy</span><span class="p">))</span>
            <span class="n">onset_doy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">doy_this</span><span class="p">[</span><span class="n">onset_candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">if</span> <span class="n">onset_candidates</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="c1"># --- Retreat via inflection (last negative curvature after min_retreat_doy) ---</span>
            <span class="n">retreat_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">((</span><span class="n">d2y_dt2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">doy_this</span> <span class="o">&gt;=</span> <span class="n">min_retreat_doy</span><span class="p">))</span>
            <span class="n">retreat_doy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">doy_this</span><span class="p">[</span><span class="n">retreat_candidates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="k">if</span> <span class="n">retreat_candidates</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="c1"># --- Duration (onset → retreat, handle wrap) ---</span>
            <span class="k">if</span> <span class="n">onset_doy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">retreat_doy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">retreat_doy</span> <span class="o">-</span> <span class="n">onset_doy</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">retreat_doy</span> <span class="o">&gt;</span> <span class="n">onset_doy</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="mi">365</span> <span class="o">-</span> <span class="n">onset_doy</span> <span class="o">+</span> <span class="n">retreat_doy</span><span class="p">)</span>
                <span class="n">duration_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">duration</span><span class="p">))</span>
                <span class="n">onset_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">onset_doy</span><span class="p">))</span>
            <span class="c1"># --- Slopes (growth / retreat early / retreat late / overall retreat) ---</span>
            <span class="c1"># Build masks once (NumPy, no xarray .where)</span>
            <span class="n">doy_mask</span> <span class="o">=</span> <span class="n">doy_this</span>  <span class="c1"># alias</span>
            <span class="n">g0</span><span class="p">,</span> <span class="n">g1</span> <span class="o">=</span> <span class="n">growth_range</span>
            <span class="n">re0</span><span class="p">,</span> <span class="n">re1</span> <span class="o">=</span> <span class="n">retreat_early_range</span>
            <span class="n">rl0a</span><span class="p">,</span> <span class="n">rl1a</span> <span class="o">=</span> <span class="n">retreat_late_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rl0b</span><span class="p">,</span> <span class="n">rl1b</span> <span class="o">=</span> <span class="n">retreat_late_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># growth season (this year)</span>
            <span class="n">g_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">doy_mask</span> <span class="o">&gt;=</span> <span class="n">g0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">doy_mask</span> <span class="o">&lt;=</span> <span class="n">g1</span><span class="p">)</span>
            <span class="n">y_grow</span> <span class="o">=</span> <span class="n">y_this</span><span class="p">[</span><span class="n">g_mask</span><span class="p">]</span>
            <span class="n">t_grow</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_this</span><span class="p">[</span><span class="n">g_mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_this</span><span class="p">[</span><span class="n">g_mask</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">y_grow</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">slope_grow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_slope</span><span class="p">(</span><span class="n">y_grow</span><span class="p">,</span> <span class="n">t_grow</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">slope_grow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grow_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_grow</span><span class="p">)</span>
            <span class="c1"># retreat early (this year)</span>
            <span class="n">e_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">doy_mask</span> <span class="o">&gt;=</span> <span class="n">re0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">doy_mask</span> <span class="o">&lt;=</span> <span class="n">re1</span><span class="p">)</span>
            <span class="n">y_early</span> <span class="o">=</span> <span class="n">y_this</span><span class="p">[</span><span class="n">e_mask</span><span class="p">]</span>
            <span class="n">t_early</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_this</span><span class="p">[</span><span class="n">e_mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_this</span><span class="p">[</span><span class="n">e_mask</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">y_early</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">slope_early</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_slope</span><span class="p">(</span><span class="n">y_early</span><span class="p">,</span> <span class="n">t_early</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">slope_early</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret_early_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_early</span><span class="p">)</span>
            <span class="c1"># retreat late (next year)</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_next</span><span class="p">]</span>
            <span class="n">y_next</span> <span class="o">=</span> <span class="n">y_full</span><span class="p">[</span><span class="n">idx_next</span><span class="p">]</span>
            <span class="n">doy_next</span> <span class="o">=</span> <span class="n">doy_full</span><span class="p">[</span><span class="n">idx_next</span><span class="p">]</span>
            <span class="n">l_mask_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">doy_mask</span> <span class="o">&gt;=</span> <span class="n">rl0a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">doy_mask</span> <span class="o">&lt;=</span> <span class="n">rl1a</span><span class="p">)</span>
            <span class="n">l_mask_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">doy_next</span> <span class="o">&gt;=</span> <span class="n">rl0b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">doy_next</span> <span class="o">&lt;=</span> <span class="n">rl1b</span><span class="p">)</span>
            <span class="n">y_late</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">y_this</span><span class="p">[</span><span class="n">l_mask_a</span><span class="p">],</span> <span class="n">y_next</span><span class="p">[</span><span class="n">l_mask_b</span><span class="p">]])</span>
            <span class="n">t_late</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([(</span><span class="n">t_this</span><span class="p">[</span><span class="n">l_mask_a</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_this</span><span class="p">[</span><span class="n">l_mask_a</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">l_mask_a</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                                      <span class="c1"># Continue time axis across year boundary</span>
                                     <span class="p">((</span><span class="n">t_next</span><span class="p">[</span><span class="n">l_mask_b</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_this</span><span class="p">[</span><span class="n">l_mask_a</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">))</span> <span class="k">if</span> <span class="n">l_mask_b</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">l_mask_a</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span>
                                     <span class="p">((</span><span class="n">t_next</span><span class="p">[</span><span class="n">l_mask_b</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_next</span><span class="p">[</span><span class="n">l_mask_b</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">))</span> <span class="k">if</span> <span class="n">l_mask_b</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])])</span> <span class="k">if</span> <span class="p">(</span><span class="n">l_mask_a</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">l_mask_b</span><span class="o">.</span><span class="n">any</span><span class="p">())</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">slope_late</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_slope</span><span class="p">(</span><span class="n">y_late</span><span class="p">,</span> <span class="n">t_late</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">slope_late</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret_late_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_late</span><span class="p">)</span>
            <span class="c1"># overall retreat (early + late concatenated)</span>
            <span class="k">if</span> <span class="n">y_early</span><span class="o">.</span><span class="n">size</span> <span class="ow">or</span> <span class="n">y_late</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">y_ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">y_early</span><span class="p">,</span> <span class="n">y_late</span><span class="p">])</span>
                <span class="c1"># stitch time so it&#39;s strictly increasing</span>
                <span class="n">t_ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">t_early</span> <span class="k">if</span> <span class="n">y_early</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="p">(</span><span class="n">t_late</span> <span class="o">+</span> <span class="p">(</span><span class="n">t_early</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">y_early</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">y_late</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">t_late</span><span class="p">)])</span>
                <span class="n">slope_ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_slope</span><span class="p">(</span><span class="n">y_ret</span><span class="p">,</span> <span class="n">t_ret</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">slope_ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Keep sign convention negative (ablation)</span>
                    <span class="n">ret_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">slope_ret</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">return_per_year</span><span class="p">:</span>
                <span class="n">per_year_rows</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;year&#39;</span>                <span class="p">:</span> <span class="n">year</span><span class="p">,</span>
                                      <span class="s1">&#39;max&#39;</span>                 <span class="p">:</span> <span class="n">max_val</span><span class="p">,</span>   <span class="s1">&#39;min&#39;</span>         <span class="p">:</span> <span class="n">min_val</span><span class="p">,</span>
                                      <span class="s1">&#39;doy_max&#39;</span>             <span class="p">:</span> <span class="n">max_doy</span><span class="p">,</span>   <span class="s1">&#39;doy_min&#39;</span>     <span class="p">:</span> <span class="n">min_doy</span><span class="p">,</span>
                                      <span class="s1">&#39;onset_doy&#39;</span>           <span class="p">:</span> <span class="n">onset_doy</span><span class="p">,</span> <span class="s1">&#39;retreat_doy&#39;</span> <span class="p">:</span> <span class="n">retreat_doy</span><span class="p">,</span>
                                      <span class="s1">&#39;duration_days&#39;</span>       <span class="p">:</span> <span class="n">duration</span> <span class="k">if</span> <span class="p">(</span><span class="n">onset_doy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">retreat_doy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="s1">&#39;growth_slope&#39;</span>        <span class="p">:</span> <span class="n">slope_grow</span><span class="p">,</span>
                                      <span class="s1">&#39;retreat_early_slope&#39;</span> <span class="p">:</span> <span class="n">slope_early</span><span class="p">,</span>
                                      <span class="s1">&#39;retreat_late_slope&#39;</span>  <span class="p">:</span> <span class="n">slope_late</span><span class="p">,</span>
                                      <span class="s1">&#39;retreat_slope&#39;</span>       <span class="p">:</span> <span class="n">slope_ret</span> <span class="k">if</span> <span class="n">slope_ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;   7. compile summary and return&quot;</span><span class="p">)</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Maximum Mean&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">max_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>       <span class="s2">&quot;Maximum Std&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">max_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="s2">&quot;Minimum Mean&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">min_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>       <span class="s2">&quot;Minimum Std&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">min_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="s2">&quot;Growth Mean&quot;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">grow_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>      <span class="s2">&quot;Growth Std&quot;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">grow_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="s2">&quot;Retreat Mean&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">ret_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>       <span class="s2">&quot;Retreat Std&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">ret_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="s2">&quot;Retreat Early Mean&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">ret_early_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Retreat Early Std&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">ret_early_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="s2">&quot;Retreat Late Mean&quot;</span>  <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">ret_late_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>  <span class="s2">&quot;Retreat Late Std&quot;</span>  <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">ret_late_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="s2">&quot;Duration-days Mean&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">duration_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>  <span class="s2">&quot;Duration-days Std&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">duration_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="s2">&quot;DOY Min Mean&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">min_doy_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>   <span class="s2">&quot;DOY Min Std&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">min_doy_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="s2">&quot;DOY Max Mean&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">max_doy_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>   <span class="s2">&quot;DOY Max Std&quot;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">max_doy_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="s2">&quot;DOY Onset Mean&quot;</span>     <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">onset_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>     <span class="s2">&quot;DOY Onset Std&quot;</span>     <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">onset_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">],}</span>
        <span class="k">if</span> <span class="n">return_per_year</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">summary</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">per_year_rows</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;year&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">summary</span></div>


    <span class="c1"># PERSISTENCE METRICS</span>
<div class="viewcode-block" id="SeaIceMetrics.persistence_stability_index">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.persistence_stability_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">persistence_stability_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I_mask</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span>
                                    <span class="n">persistence_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
                                    <span class="n">winter_months</span>        <span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                                    <span class="n">area_scale</span>           <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e9</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute FIPSI (Fast-Ice Persistence Stability Index) from a binary fast-ice mask.</span>

<span class="sd">        Definition</span>
<span class="sd">        ----------</span>
<span class="sd">        FIPSI = (area of grid cells whose WINTER fast-ice persistence ≥ threshold)</span>
<span class="sd">                / (area of grid cells that have fast ice at least once in WINTER),</span>
<span class="sd">        where persistence is the fraction of winter days (e.g., May–Oct) that a cell is fast.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I_mask : xarray.DataArray or xarray.Dataset</span>
<span class="sd">            Binary fast-ice mask (0/1) with a &#39;time&#39; dimension; if a Dataset is given,</span>
<span class="sd">            a variable named &#39;FI_mask&#39; is used.</span>
<span class="sd">        A : xarray.DataArray or xarray.Dataset</span>
<span class="sd">            Grid-cell area on the same grid; if a Dataset is given, the first of</span>
<span class="sd">            {&#39;tarea&#39;,&#39;area&#39;,&#39;TAREA&#39;} is used. If A has a &#39;time&#39; dim, the first slice is used.</span>
<span class="sd">        persistence_threshold : float, optional</span>
<span class="sd">            Minimum winter persistence to classify a cell as persistent (default 0.8).</span>
<span class="sd">        winter_months : tuple[int], optional</span>
<span class="sd">            Months to include for the winter persistence (default May–Oct).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict:</span>
<span class="sd">            {&#39;persistence_stability_index&#39;: float,   # FIPSI in [0,1] or NaN if undefined</span>
<span class="sd">             &#39;area_persistent_winter&#39;: float,        # area of persistent winter FI (units of A)</span>
<span class="sd">             &#39;area_ever_winter&#39;: float               # area with any winter FI (units of A)}</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        • Uses the class&#39;s `spatial_dims` to sum areas.</span>
<span class="sd">        • Assumes `I_mask` is truly binary (0/1). For classification outputs that are boolean, they will be cast to float internally.</span>
<span class="sd">        • Designed to be Dask-friendly: only two area reductions are computed eagerly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing FIPSI: persistent-winter area / ever-winter area&quot;</span><span class="p">)</span>
        <span class="n">I_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_da_mask</span><span class="p">(</span><span class="n">I_mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">A</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_da_area</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="c1"># Ensure A has only spatial dims</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="c1"># safer than drop_vars which can produce a Dataset</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">spat_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;spatial_dims&quot;</span><span class="p">]</span>
        <span class="c1"># restrict to winter months and form persistence (fraction in [0,1])</span>
        <span class="n">in_winter</span> <span class="o">=</span> <span class="n">I_mask</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">winter_months</span><span class="p">))</span>
        <span class="n">FI_winter</span> <span class="o">=</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">in_winter</span><span class="p">)</span>
        <span class="n">prstnc</span>    <span class="o">=</span> <span class="n">FI_winter</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># masks for footprints</span>
        <span class="n">persistent_mask</span> <span class="o">=</span> <span class="n">prstnc</span> <span class="o">&gt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">persistence_threshold</span><span class="p">)</span>       <span class="c1"># persistent winter FI</span>
        <span class="n">ever_mask</span>       <span class="o">=</span> <span class="n">FI_winter</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>   <span class="c1"># ever-winter FI</span>
        <span class="c1"># # area-weighted sums over spatial dims</span>
        <span class="n">prstnc_A</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">persistent_mask</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spat_dims</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ttl_A</span>    <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ever_mask</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spat_dims</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">):</span>   <span class="c1"># or &quot;synchronous&quot;</span>
            <span class="n">prstnc_A</span> <span class="o">=</span> <span class="n">prstnc_A</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">ttl_A</span>    <span class="o">=</span> <span class="n">ttl_A</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">prstnc_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_float_scalar</span><span class="p">(</span><span class="n">prstnc_A</span><span class="p">)</span>
        <span class="n">ttl_A</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_float_scalar</span><span class="p">(</span><span class="n">ttl_A</span><span class="p">)</span>
        <span class="n">psi</span>      <span class="o">=</span> <span class="p">(</span><span class="n">prstnc_A</span> <span class="o">/</span> <span class="n">ttl_A</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ttl_A</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ttl_A</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;persistence_stability_index&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span>
                <span class="s2">&quot;area_persistent_winter&quot;</span>     <span class="p">:</span> <span class="n">prstnc_A</span><span class="o">/</span><span class="n">area_scale</span><span class="p">,</span>
                <span class="s2">&quot;area_ever_winter&quot;</span>           <span class="p">:</span> <span class="n">ttl_A</span><span class="o">/</span><span class="n">area_scale</span><span class="p">}</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_BAS_coast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">path_coast_shape</span>  <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span>  <span class="kc">None</span><span class="p">,</span>
                           <span class="n">crs_out</span>           <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="s2">&quot;EPSG:3031&quot;</span><span class="p">,</span>
                           <span class="n">target_spacing_km</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load BAS high-res coastline polygons and build a KD-Tree of densified coastline points in a metric CRS (default EPSG:3031).</span>
<span class="sd">        Caches results on `self` to avoid repeated work.</span>

<span class="sd">        source: https://add-catalogue.data.bas.ac.uk/records/9b4fab56-4999-4fe1-b17f-1466e41151c4.html</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shp_path : str</span>
<span class="sd">            Path to the polygon shapefile (e.g., &quot;.../add_coastline_high_res_polygon_v7_9.shp&quot;).</span>
<span class="sd">        crs_out : str</span>
<span class="sd">            Target projected CRS for metric distances (e.g., EPSG:3031).</span>
<span class="sd">        target_spacing_km : float</span>
<span class="sd">            Approx spacing along the coastline (km) for densification.</span>

<span class="sd">        Sets</span>
<span class="sd">        ----</span>
<span class="sd">        self._coast_kdtree  : scipy.spatial.cKDTree instance in projected coords</span>
<span class="sd">        self._coast_xy_proj : (x_coast, y_coast) ndarray tuple (meters)</span>
<span class="sd">        self._coast_crs     : str of the projected CRS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w">      </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w">    </span><span class="kn">import</span> <span class="n">cKDTree</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.ops</span><span class="w">      </span><span class="kn">import</span> <span class="n">unary_union</span>
        <span class="n">P_shp</span> <span class="o">=</span> <span class="n">path_coast_shape</span> <span class="k">if</span> <span class="n">path_coast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">BAS_dict</span><span class="p">[</span><span class="s2">&quot;P_Ant_Cstln&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading coastline polygons: </span><span class="si">{</span><span class="n">P_shp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">P_shp</span><span class="p">)</span>
        <span class="c1"># Reproject to metric CRS (EPSG:3031 by default)</span>
        <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Input CRS is None; assuming EPSG:4326 (lon/lat).&quot;</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">allow_override</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs_out</span><span class="p">)</span>
        <span class="c1"># Merge polygons to avoid duplicate edges (optional but helpful)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Merging polygons and extracting boundaries...&quot;</span><span class="p">)</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># MultiPolygon | Polygon</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">geom</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In case the file already has lines, just take them</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Convert polygon exteriors to lines (ignore interiors/holes for coastline)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LineString</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># If there are already line features in the shapefile, add them too</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">geom_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;linestring&quot;</span><span class="p">)])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No coastline linework could be derived from the polygons/lines in the shapefile.&quot;</span><span class="p">)</span>
        <span class="c1"># Densify lines at ~target spacing</span>
        <span class="n">spacing_m</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">100.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">target_spacing_km</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">)</span>  <span class="c1"># clip at &gt;=100 m</span>
        <span class="n">pts_x</span><span class="p">,</span> <span class="n">pts_y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">ln</span><span class="o">.</span><span class="n">length</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="ow">or</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">length</span> <span class="o">/</span> <span class="n">spacing_m</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># sample [0,1] along the line</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">ln</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">xy</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">pts_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">pts_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="n">x_coast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pts_x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">y_coast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pts_y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_coast</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Coastline densification produced zero points.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Built coastline point set: </span><span class="si">{</span><span class="n">x_coast</span><span class="o">.</span><span class="n">size</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> pts @ ~</span><span class="si">{</span><span class="n">target_spacing_km</span><span class="si">}</span><span class="s2"> km spacing.&quot;</span><span class="p">)</span>
        <span class="n">kdt</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x_coast</span><span class="p">,</span> <span class="n">y_coast</span><span class="p">]))</span>
        <span class="c1"># Cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coast_kdtree</span>  <span class="o">=</span> <span class="n">kdt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coast_xy_proj</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_coast</span><span class="p">,</span> <span class="n">y_coast</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coast_crs</span>     <span class="o">=</span> <span class="n">crs_out</span>

<div class="viewcode-block" id="SeaIceMetrics.persistence_ice_distance_mean_max">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.persistence_ice_distance_mean_max">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">persistence_ice_distance_mean_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ice_prstnc</span><span class="p">,</span>
                                          <span class="n">persistence_threshold</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
                                          <span class="n">path_coast_shape</span>      <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                          <span class="n">crs_out</span>               <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;EPSG:3031&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mean/max distance from the USNIC/ADD coastline for persistent fast ice.</span>
<span class="sd">        Uses a densified coastline KD-Tree in a metric CRS (default EPSG:3031).</span>

<span class="sd">        Assumes `ice_prstnc` is a persistence field in [0..1] computed from a</span>
<span class="sd">        binary fast-ice mask over the austral-winter window (e.g., May–Oct).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyproj</span><span class="w"> </span><span class="kn">import</span> <span class="n">Transformer</span>
        <span class="n">P_shp</span> <span class="o">=</span> <span class="n">path_coast_shape</span> <span class="k">if</span> <span class="n">path_coast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">BAS_dict</span><span class="p">[</span><span class="s2">&quot;P_Ant_Cstln&quot;</span><span class="p">]</span>
        <span class="n">spat_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;spatial_dims&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing persistence distance (USNIC coastline KD-Tree)&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">):</span>
            <span class="n">ice_prstnc</span> <span class="o">=</span> <span class="n">ice_prstnc</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  <span class="c1"># instead of .load()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bgrid_loaded&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_grid</span><span class="p">(</span><span class="n">slice_hem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Gt</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span>
        <span class="n">lon_name</span> <span class="o">=</span> <span class="s1">&#39;TLON&#39;</span> <span class="k">if</span> <span class="s1">&#39;TLON&#39;</span> <span class="ow">in</span> <span class="n">Gt</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;lon&#39;</span> <span class="k">if</span> <span class="s1">&#39;lon&#39;</span> <span class="ow">in</span> <span class="n">Gt</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">lat_name</span> <span class="o">=</span> <span class="s1">&#39;TLAT&#39;</span> <span class="k">if</span> <span class="s1">&#39;TLAT&#39;</span> <span class="ow">in</span> <span class="n">Gt</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;lat&#39;</span> <span class="k">if</span> <span class="s1">&#39;lat&#39;</span> <span class="ow">in</span> <span class="n">Gt</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lon_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lat_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Could not find lon/lat fields (TLON/TLAT or lon/lat) in self.G_t.&quot;</span><span class="p">)</span>
        <span class="n">grid_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ice_prstnc</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">spat_dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grid_shape</span> <span class="o">!=</span> <span class="n">Gt</span><span class="p">[</span><span class="n">lon_name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Grid mismatch detected; reloading b-grid with slice_hem=True&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_grid</span><span class="p">(</span><span class="n">slice_hem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">Gt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span>
            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ice_prstnc</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">spat_dims</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Gt</span><span class="p">[</span><span class="n">lon_name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ice_prstnc and grid coordinate shapes still mismatch after reload.&quot;</span><span class="p">)</span>
        <span class="c1"># Prepare coastline KD-tree once (unchanged)</span>
        <span class="n">need_kdtree</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_coast_kdtree&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_coast_crs&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="n">crs_out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">need_kdtree</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_BAS_coast</span><span class="p">(</span><span class="n">P_shp</span><span class="p">,</span> <span class="n">crs_out</span><span class="o">=</span><span class="n">crs_out</span><span class="p">,</span> <span class="n">target_spacing_km</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="c1"># Build persistent mask from fully-realized array</span>
        <span class="n">prst</span> <span class="o">=</span> <span class="p">(</span><span class="n">ice_prstnc</span> <span class="o">&gt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">persistence_threshold</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prst</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No persistent fast-ice cells found at this threshold.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;persistence_mean_distance&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">),</span>
                    <span class="s2">&quot;persistence_max_distance&quot;</span><span class="p">:</span>  <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)}</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Gt</span><span class="p">[</span><span class="n">lon_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Gt</span><span class="p">[</span><span class="n">lat_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">transformer</span> <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">crs_out</span><span class="p">,</span> <span class="n">always_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x_all</span><span class="p">,</span> <span class="n">y_all</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">prst</span><span class="p">)</span>  <span class="c1"># spat_dims order (nj, ni)</span>
        <span class="n">x_p</span> <span class="o">=</span> <span class="n">x_all</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
        <span class="n">y_p</span> <span class="o">=</span> <span class="n">y_all</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">x_p</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;persistence_mean_distance&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">),</span>
                    <span class="s2">&quot;persistence_max_distance&quot;</span><span class="p">:</span>  <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)}</span>
        <span class="n">d_m</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coast_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x_p</span><span class="p">,</span> <span class="n">y_p</span><span class="p">]),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">d_km</span> <span class="o">=</span> <span class="n">d_m</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;persistence_mean_distance&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">d_km</span><span class="p">)),</span>
                <span class="s2">&quot;persistence_max_distance&quot;</span><span class="p">:</span>  <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">d_km</span><span class="p">))}</span></div>


    <span class="c1"># INTER-COMPARISONS</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_skill_stats</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">mean_squared_error</span><span class="p">,</span> <span class="n">mean_absolute_error</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w">     </span><span class="kn">import</span> <span class="n">pearsonr</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span>  <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;Bias&quot;</span>     <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span>
                <span class="s2">&quot;RMSE&quot;</span>     <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                <span class="s2">&quot;MAE&quot;</span>      <span class="p">:</span> <span class="n">mean_absolute_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
                <span class="s2">&quot;Corr&quot;</span>     <span class="p">:</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;SD_Model&quot;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="s2">&quot;SD_Obs&quot;</span>   <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y</span><span class="p">)}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_safe_load_array_to_memory</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># --- Force local computation to avoid serializing Dask HLGs to the cluster ---</span>
        <span class="c1"># Keep memory light and avoid shipping graphs to distributed workers</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s2">&quot;single-threaded&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s2">&quot;single-threaded&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;compute&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
        
<div class="viewcode-block" id="SeaIceMetrics.compute_skill_statistics">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.compute_skill_statistics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_skill_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">min_points</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute statistical skill metrics between model and observational time series.</span>
<span class="sd">        If time alignment fails and `climatology_if_mismatch` is True, computes climatological</span>
<span class="sd">        skill instead (e.g., using day-of-year climatologies).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mod : xarray.DataArray; Time series of modelled values.</span>
<span class="sd">        obs : xarray.DataArray; Time series of observed values (must be aligned with model, or climatology is used).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict; Dictionary of skill metrics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_load_array_to_memory</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_load_array_to_memory</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">):</span>
            <span class="n">dt_mod</span>  <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span>
            <span class="n">dt_obs</span>  <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span>
            <span class="n">dt_xsct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">dt_mod</span><span class="p">,</span> <span class="n">dt_obs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_xsct</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_points</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;more than </span><span class="si">{</span><span class="n">min_points</span><span class="si">}</span><span class="s2"> date-times intersected, therefore do stats on time series&quot;</span><span class="p">)</span>
                <span class="n">mod_data</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">dt_xsct</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="n">obs_data</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">dt_xsct</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skill_stats</span><span class="p">(</span><span class="n">mod_data</span><span class="p">,</span> <span class="n">obs_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;date-time mismatch detected — falling back to climatology comparison.&quot;</span><span class="p">)</span>
                <span class="n">mod_clim</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;time.dayofyear&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
                <span class="n">obs_clim</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;time.dayofyear&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
                <span class="n">doy_xsct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">mod_clim</span><span class="o">.</span><span class="n">dayofyear</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">obs_clim</span><span class="o">.</span><span class="n">dayofyear</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="n">mod_data</span> <span class="o">=</span> <span class="n">mod_clim</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">dayofyear</span><span class="o">=</span><span class="n">doy_xsct</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="n">obs_data</span> <span class="o">=</span> <span class="n">obs_clim</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">dayofyear</span><span class="o">=</span><span class="n">doy_xsct</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skill_stats</span><span class="p">(</span><span class="n">mod_data</span><span class="p">,</span> <span class="n">obs_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Time dimension not found or could not align. Returning empty stats.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;Bias&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;RMSE&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;MAE&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;Corr&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                <span class="s2">&quot;SD_Model&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;SD_Obs&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span></div>


<div class="viewcode-block" id="SeaIceMetrics.antarctic_year_labels">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.antarctic_year_labels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">antarctic_year_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an &#39;ayear&#39; label for Jul→Jun years (e.g., 2000.5 dates -&gt; ayear=2000).&quot;&quot;&quot;</span>
        <span class="n">year</span>  <span class="o">=</span> <span class="n">time_da</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span>
        <span class="n">month</span> <span class="o">=</span> <span class="n">time_da</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span>
        <span class="n">ayear</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">month</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">year</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ayear</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;ayear&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeaIceMetrics.extrema_means_antarctic_year">
<a class="viewcode-back" href="../api.html#sea_ice_metrics.SeaIceMetrics.extrema_means_antarctic_year">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrema_means_antarctic_year</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da_ts</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        da_ts: 1-D (time,) fast-ice area time series (km^2).</span>
<span class="sd">        Returns dict with:</span>
<span class="sd">        - max_mean: mean of per-AY maxima</span>
<span class="sd">        - min_mean: mean of per-AY minima</span>
<span class="sd">        - max_ts  : per-AY maxima time series (indexed by &#39;ayear&#39;)</span>
<span class="sd">        - min_ts  : per-AY minima time series (indexed by &#39;ayear&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for tiny 1D series, it&#39;s fine to fully chunk or even compute up front</span>
        <span class="c1"># da_ts = da_ts.chunk({&quot;time&quot;: -1})</span>
        <span class="n">ay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antarctic_year_labels</span><span class="p">(</span><span class="n">da_ts</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
        <span class="n">g</span>  <span class="o">=</span> <span class="n">da_ts</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">ay</span><span class="p">)</span>
        <span class="n">max_ts</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                  <span class="c1"># dims: ayear</span>
        <span class="n">min_ts</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;max_mean&quot;</span><span class="p">:</span> <span class="n">max_ts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s2">&quot;ayear&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="s2">&quot;min_mean&quot;</span><span class="p">:</span> <span class="n">min_ts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s2">&quot;ayear&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="s2">&quot;max_ts&quot;</span><span class="p">:</span> <span class="n">max_ts</span><span class="p">,</span>
            <span class="s2">&quot;min_ts&quot;</span><span class="p">:</span> <span class="n">min_ts</span><span class="p">,</span>
        <span class="p">}</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Daniel Atwater.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>