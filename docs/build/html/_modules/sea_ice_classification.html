

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sea_ice_classification &mdash; AFIM 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=01f34227"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            AFIM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AFIM_sensitivity_methodology.html">Methodology: Antarctic (Land)Fast (Sea) Ice Modelling and Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lateral_drag_form_factor_creation.html">Coastal-drag form factors from high-resolution coastline and grounded icebergs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AFIM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">sea_ice_classification</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sea_ice_classification</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SeaIceClassification</span>
<span class="sd">====================</span>

<span class="sd">Class utilities for classifying Antarctic fast ice using sea-ice concentration</span>
<span class="sd">(`aice`) and speed thresholds on multiple grids:</span>

<span class="sd">- B  : native CICE B-grid (cell centers) magnitude computed from (uvel, vvel)</span>
<span class="sd">- Ta : 2×2 B-grid box average (area-like) magnitude</span>
<span class="sd">- Tb : 2×2 B-grid box average (grid-like) magnitude</span>
<span class="sd">- Tx : B-grid regridded to T-grid magnitude via precomputed weights</span>

<span class="sd">High-level API</span>
<span class="sd">--------------</span>
<span class="sd">- classify_fast_ice(...): end-to-end daily fast-ice mask, binary-day mask, and</span>
<span class="sd">  optional rolling-mean variant.</span>
<span class="sd">- classify_binary_days_fast_ice(...): “persistence” classification over a sliding</span>
<span class="sd">  window (N days) requiring ≥M fast-ice days within the window.</span>

<span class="sd">Assumptions / required attributes</span>
<span class="sd">---------------------------------</span>
<span class="sd">Before calling the high-level methods, the following attributes/methods must exist:</span>

<span class="sd">Attributes (populated externally or via your toolbox manager):</span>
<span class="sd">- self.CICE_dict: dict with keys</span>
<span class="sd">    &quot;y_dim_length&quot;, &quot;x_dim_length&quot;, &quot;time_dim&quot;, &quot;FI_chunks&quot;,</span>
<span class="sd">    &quot;spatial_dims&quot;, &quot;drop_coords&quot;</span>
<span class="sd">- self.icon_thresh: float   (sea-ice concentration threshold, e.g., 0.15)</span>
<span class="sd">- self.ispd_thresh: float   (speed threshold for fast ice, e.g., 1e-4 m/s)</span>
<span class="sd">- self.bin_win_days: int    (persistence window length, e.g., 31)</span>
<span class="sd">- self.bin_min_days: int    (min fast-ice count in window, e.g., 16)</span>
<span class="sd">- self.mean_period: int     (rolling mean length in days)</span>
<span class="sd">- self.BorC2T_type: some combination of {&quot;B&quot;,&quot;C&quot;,&quot;Ta&quot;,&quot;Tb&quot;,&quot;Tc&quot;,&quot;Tx&quot;} to average into composite</span>
<span class="sd">- self.G_t, self.G_u: dicts providing T- and U-grid lon/lat arrays</span>
<span class="sd">- self.dt_range: pandas.DatetimeIndex used by np3d_to_xr3d</span>

<span class="sd">Methods (provided elsewhere in your stack):</span>
<span class="sd">- self.load_cice_grid()</span>
<span class="sd">- self.define_reG_weights()</span>
<span class="sd">- self.load_cice_zarr(...)</span>
<span class="sd">- self.slice_hemisphere(xr.DataArray/xr.Dataset)</span>
<span class="sd">- self.define_datetime_vars(dt0_str, dtN_str)</span>
<span class="sd">- self.reG(xr.DataArray)   (B→T regridding using precomputed weights)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">json</span><span class="o">,</span><span class="w"> </span><span class="nn">os</span><span class="o">,</span><span class="w"> </span><span class="nn">shutil</span><span class="o">,</span><span class="w"> </span><span class="nn">logging</span><span class="o">,</span><span class="w"> </span><span class="nn">re</span><span class="o">,</span><span class="w"> </span><span class="nn">dask</span><span class="o">,</span><span class="w"> </span><span class="nn">gc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w">    </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w">    </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w">     </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xesmf</span><span class="w">     </span><span class="k">as</span><span class="w"> </span><span class="nn">xe</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w">     </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w">    </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.lib.stride_tricks</span><span class="w"> </span><span class="kn">import</span> <span class="n">sliding_window_view</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">concurrent.futures</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

<div class="viewcode-block" id="SeaIceClassification">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SeaIceClassification</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classify fast ice from CICE outputs using concentration and speed thresholds,</span>
<span class="sd">    with support for daily, persistence (binary-day), and rolling-mean variants.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sim_name : str, optional</span>
<span class="sd">        Name/identifier of the simulation (used for logs/paths).</span>
<span class="sd">    logger : logging.Logger, optional</span>
<span class="sd">        Logger instance. If None, uses a module-level logger.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Arbitrary configuration attributes set directly on `self`. Common keys</span>
<span class="sd">        include thresholds, window lengths, and dictionaries noted in the module</span>
<span class="sd">        docstring.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The “daily” fast-ice mask is defined where:</span>
<span class="sd">        (aice &gt; icon_thresh) AND (0 &lt; ispd &lt;= ispd_thresh)</span>
<span class="sd">      after composing `ispd` from one or more of {B, Ta, Tb, Tx}.</span>
<span class="sd">    - The binary-day mask applies a centered sliding window that marks a day as</span>
<span class="sd">      “persistent fast ice” if at least `bin_min_days` within `bin_win_days` are</span>
<span class="sd">      fast-ice days.</span>
<span class="sd">    - Several operations use Dask via `xr.apply_ufunc(..., dask=&quot;parallelized&quot;)`,</span>
<span class="sd">      but key intermediates are explicitly `.compute()`’d for determinism. Ensure</span>
<span class="sd">      available memory/cluster config is appropriate for your domain size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_name</span> <span class="o">=</span> <span class="n">sim_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span> <span class="ow">or</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rolling_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">mean_period</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a centered rolling mean along the model time dimension.</span>

<span class="sd">        This helper supports both xarray-backed (optionally Dask-chunked) arrays and</span>
<span class="sd">        plain NumPy arrays:</span>

<span class="sd">        - For `xarray.DataArray`, uses `DataArray.rolling(...).mean()` which can run</span>
<span class="sd">        in parallel under Dask. The time chunk size is adjusted to be no larger</span>
<span class="sd">        than the rolling window to improve rolling performance and avoid large</span>
<span class="sd">        rechunk overheads.</span>
<span class="sd">        - For NumPy input, uses `scipy.ndimage.uniform_filter1d` as a fast fallback.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mag : xarray.DataArray or array-like</span>
<span class="sd">            Magnitude-like array with time on axis 0 (NumPy) or on the dimension</span>
<span class="sd">            named by `self.CICE_dict[&quot;time_dim&quot;]` (xarray). Typically shape</span>
<span class="sd">            (time, y, x).</span>
<span class="sd">        mean_period : int, optional</span>
<span class="sd">            Window length (number of timesteps/days) for the rolling mean. If None,</span>
<span class="sd">            defaults to `self.mean_period`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : xarray.DataArray or numpy.ndarray</span>
<span class="sd">            Rolling-mean result cast to float32. For xarray input, coordinates and</span>
<span class="sd">            dimension names are preserved.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The xarray path uses `center=True` and `min_periods=mean_period`, which</span>
<span class="sd">        yields NaNs at the edges (no partial-window averaging).</span>
<span class="sd">        - The NumPy fallback uses `mode=&quot;nearest&quot;`, which does not introduce NaNs at</span>
<span class="sd">        edges but will bias edge values relative to the strict full-window xarray</span>
<span class="sd">        behaviour.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mean_period</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mean_period</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_period</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="n">time_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">]</span>
            <span class="c1"># ensure time chunks aren&#39;t larger than the window (helps parallel rolling)</span>
            <span class="n">tlen</span> <span class="o">=</span> <span class="n">mag</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tch</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">mean_period</span><span class="p">,</span> <span class="n">tlen</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">mag</span><span class="o">.</span><span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mag</span><span class="o">.</span><span class="n">chunksizes</span><span class="p">[</span><span class="n">time_dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tch</span><span class="p">:</span>
                    <span class="n">mag</span> <span class="o">=</span> <span class="n">mag</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">tch</span><span class="p">})</span>
            <span class="c1"># centered rolling mean; require full window to avoid edge bias</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">mag</span><span class="o">.</span><span class="n">rolling</span><span class="p">({</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">mean_period</span><span class="p">},</span>
                                <span class="n">center</span>      <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                <span class="n">min_periods</span> <span class="o">=</span> <span class="n">mean_period</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># NumPy fallback</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">uniform_filter1d</span>
            <span class="k">return</span> <span class="n">uniform_filter1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mag</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">mean_period</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<div class="viewcode-block" id="SeaIceClassification.Bavg_methA">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.Bavg_methA">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Bavg_methA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B_component</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Average a corner-staggered (B-grid) field onto T-cell centers via a 2x2 mean.</span>

<span class="sd">        This method computes the simple arithmetic mean of the four corner values</span>
<span class="sd">        surrounding each T-cell:</span>
<span class="sd">            avg = (v00 + v01 + v10 + v11) / 4</span>

<span class="sd">        It then pads the result back to the target T-grid shape and optionally</span>
<span class="sd">        wraps the x-direction by copying the first column into the last column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B_component : numpy.ndarray</span>
<span class="sd">            Corner-staggered field with shape (time, y, x). Typically a velocity</span>
<span class="sd">            component (u or v) on B-grid corners.</span>
<span class="sd">        y_len : int</span>
<span class="sd">            Target T-grid y dimension length. (Note: current implementation reads</span>
<span class="sd">            `self.CICE_dict[&quot;y_dim_length&quot;]` and ignores the passed value.)</span>
<span class="sd">        x_len : int</span>
<span class="sd">            Target T-grid x dimension length. (Note: current implementation reads</span>
<span class="sd">            `self.CICE_dict[&quot;x_dim_length&quot;]` and ignores the passed value.)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        avg_T : numpy.ndarray</span>
<span class="sd">            T-centered field with shape (time, y_len, x_len). Padding is filled with</span>
<span class="sd">            NaN. dtype is unchanged until returned (typically float).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method does not apply a no-slip treatment: NaNs in the input propagate</span>
<span class="sd">        into the 2x2 average.</span>
<span class="sd">        - X wrapping is implemented by setting the last x column equal to the first,</span>
<span class="sd">        which is appropriate for cyclic/periodic global grids.</span>
<span class="sd">        - If the input has insufficient halo/extent for the 2x2 operation, the output</span>
<span class="sd">        will contain NaNs introduced by padding.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;y_dim_length&quot;</span><span class="p">]</span>
        <span class="n">x_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;x_dim_length&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input shape to Ta spatial averaging: </span><span class="si">{</span><span class="n">B_component</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Compute average of 4 neighboring cells</span>
        <span class="n">v00</span> <span class="o">=</span> <span class="n">B_component</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">v01</span> <span class="o">=</span> <span class="n">B_component</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">v10</span> <span class="o">=</span> <span class="n">B_component</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">v11</span> <span class="o">=</span> <span class="n">B_component</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="p">(</span><span class="n">v00</span> <span class="o">+</span> <span class="n">v01</span> <span class="o">+</span> <span class="n">v10</span> <span class="o">+</span> <span class="n">v11</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>
        <span class="c1"># Pad to restore shape (time, y_len, x_len)</span>
        <span class="n">pad_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_len</span> <span class="o">-</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pad_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_len</span> <span class="o">-</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">)),</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1"># Wrap x-dimension if necessary</span>
        <span class="k">if</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">avg</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Final trim in case padding overshoots</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">[:,</span> <span class="p">:</span><span class="n">y_len</span><span class="p">,</span> <span class="p">:</span><span class="n">x_len</span><span class="p">]</span></div>


<div class="viewcode-block" id="SeaIceClassification.Bavg_methB">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.Bavg_methB">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Bavg_methB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B_component</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">,</span> <span class="n">wrap_x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Average a corner-staggered (B-grid) field onto T-cell centers using a 2x2 mean</span>
<span class="sd">        with no-slip handling at land corners (NaNs treated as zero).</span>

<span class="sd">        The method forms the mean of the four corner values surrounding each T-cell,</span>
<span class="sd">        but first converts NaNs to 0.0 to enforce a no-slip-style boundary at masked</span>
<span class="sd">        corners:</span>
<span class="sd">            out = 0.25 * (nan_to_num(v00) + nan_to_num(v01) + nan_to_num(v10) + nan_to_num(v11))</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B_component : array-like</span>
<span class="sd">            Corner-staggered field with shape (time, y, x), e.g., uvel or vvel on a</span>
<span class="sd">            CICE B-grid.</span>
<span class="sd">        y_len : int</span>
<span class="sd">            Target T-grid y dimension length.</span>
<span class="sd">        x_len : int</span>
<span class="sd">            Target T-grid x dimension length.</span>
<span class="sd">        wrap_x : bool</span>
<span class="sd">            If True, enforce cyclic boundary in x by copying the first column to the</span>
<span class="sd">            last column after padding.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_T : numpy.ndarray</span>
<span class="sd">            T-centered field with shape (time, y_len, x_len), dtype float32.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - NaN-to-zero treatment is intentional and corresponds to a no-slip behaviour</span>
<span class="sd">        at land/corner masks; this differs from `Bavg_methA`, where NaNs propagate.</span>
<span class="sd">        - Padding (if needed) is filled with NaN after averaging.</span>
<span class="sd">        - For cyclic grids, the wrap is applied after padding and before trimming.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">B_component</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">v01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">B_component</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">:],</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">v10</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">B_component</span><span class="p">[:,</span>  <span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">v11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">B_component</span><span class="p">[:,</span>  <span class="mi">1</span><span class="p">:,</span>  <span class="mi">1</span><span class="p">:],</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">v00</span> <span class="o">+</span> <span class="n">v01</span> <span class="o">+</span> <span class="n">v10</span> <span class="o">+</span> <span class="n">v11</span><span class="p">)</span>
        <span class="n">pad_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_len</span> <span class="o">-</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pad_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_len</span> <span class="o">-</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pad_y</span> <span class="ow">or</span> <span class="n">pad_x</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">)),</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrap_x</span> <span class="ow">and</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[:,</span> <span class="p">:</span><span class="n">y_len</span><span class="p">,</span> <span class="p">:</span><span class="n">x_len</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SeaIceClassification.Cavg_meth">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.Cavg_meth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Cavg_meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C_component</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                  <span class="n">y_len</span>       <span class="p">:</span> <span class="nb">int</span>  <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">x_len</span>       <span class="p">:</span> <span class="nb">int</span>  <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">wrap_x</span>      <span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">nan_to_zero</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Average a C-grid edge-centered field onto T-cell centers.</span>

<span class="sd">        This is the C-grid analogue of your B-grid corner-to-center averaging, but uses</span>
<span class="sd">        a 1D average along the staggered direction:</span>

<span class="sd">        - direction=&quot;x&quot;: average along x (typical for U-grid / east-west faces)</span>
<span class="sd">        - direction=&quot;y&quot;: average along y (typical for V-grid / north-south faces)</span>

<span class="sd">        Supports both xarray.DataArray (Dask-friendly) and NumPy arrays.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C_component : xarray.DataArray or array-like</span>
<span class="sd">            C-grid edge-centered field. Expected to have time as the first dimension</span>
<span class="sd">            and the last two dims as (y, x) in some order consistent with typical CICE</span>
<span class="sd">            output. For xarray input, dims are inferred from the last two dims.</span>
<span class="sd">        direction : {&quot;x&quot;,&quot;y&quot;}</span>
<span class="sd">            Stagger direction to average over:</span>
<span class="sd">            - &quot;x&quot;: average adjacent points in x to map U-grid → T-grid</span>
<span class="sd">            - &quot;y&quot;: average adjacent points in y to map V-grid → T-grid</span>
<span class="sd">        y_len, x_len : int, optional</span>
<span class="sd">            Target T-grid spatial sizes. Defaults to `self.CICE_dict[&quot;y_dim_length&quot;]`</span>
<span class="sd">            and `self.CICE_dict[&quot;x_dim_length&quot;]`.</span>
<span class="sd">        wrap_x : bool, optional</span>
<span class="sd">            Whether to enforce cyclic wrap in the x-direction (seam handling). Defaults</span>
<span class="sd">            to `self.CICE_dict.get(&quot;wrap_x&quot;, True)`.</span>
<span class="sd">        nan_to_zero : bool, default True</span>
<span class="sd">            If True, treat NaNs as 0.0 before averaging (no-slip-like treatment near</span>
<span class="sd">            land/masks). If False, NaNs propagate into the average.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_T : same type as input</span>
<span class="sd">            T-centered field with shape (time, y_len, x_len), float32 for NumPy input.</span>
<span class="sd">            For xarray input, coords/dims are preserved as much as possible.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Size handling:</span>
<span class="sd">        - If the staggered dimension has length (target+1), a straightforward adjacent</span>
<span class="sd">        slice-average is used and yields the target length.</span>
<span class="sd">        - If it has length (target), we average using roll/shift:</span>
<span class="sd">            * wrap_x=True uses roll (periodic)</span>
<span class="sd">            * wrap_x=False uses shift (non-periodic; last column becomes NaN)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cavg_meth: direction must be &#39;x&#39; or &#39;y&#39;&quot;</span><span class="p">)</span>
        <span class="n">y_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_len</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;y_dim_length&quot;</span><span class="p">])</span>
        <span class="n">x_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_len</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;x_dim_length&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">wrap_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wrap_x</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;wrap_x&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="c1"># -------------------------</span>
        <span class="c1"># xarray / Dask-friendly</span>
        <span class="c1"># -------------------------</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">C_component</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">C_component</span>
            <span class="n">ydim</span><span class="p">,</span> <span class="n">xdim</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nan_to_zero</span><span class="p">:</span>
                <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">xdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">nx</span> <span class="o">==</span> <span class="n">x_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">left</span>  <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">xdim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_len</span><span class="p">)})</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">xdim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)})</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># length == x_len (or unknown): roll/shift based averaging</span>
                    <span class="k">if</span> <span class="n">wrap_x</span><span class="p">:</span>
                        <span class="n">shifted</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">roll</span><span class="p">({</span><span class="n">xdim</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="n">roll_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">shifted</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">shift</span><span class="p">({</span><span class="n">xdim</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">})</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">da</span> <span class="o">+</span> <span class="n">shifted</span><span class="p">)</span>
                    <span class="c1"># ensure target length</span>
                    <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">xdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">x_len</span><span class="p">:</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">xdim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_len</span><span class="p">)})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ydim</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ny</span> <span class="o">==</span> <span class="n">y_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">ydim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_len</span><span class="p">)})</span>
                    <span class="n">bot</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">ydim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)})</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">bot</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shifted</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">shift</span><span class="p">({</span><span class="n">ydim</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">})</span>  <span class="c1"># no wrap in y by default</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">da</span> <span class="o">+</span> <span class="n">shifted</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ydim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y_len</span><span class="p">:</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">ydim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_len</span><span class="p">)})</span>

            <span class="c1"># pad to target if needed (rare, but keeps behaviour consistent with Bavg)</span>
            <span class="n">pad_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_len</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ydim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">pad_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_len</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">xdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pad_y</span> <span class="ow">or</span> <span class="n">pad_x</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">pad</span><span class="p">({</span><span class="n">ydim</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">),</span> <span class="n">xdim</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">)},</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="c1"># -------------------------</span>
        <span class="c1"># NumPy fallback</span>
        <span class="c1"># -------------------------</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">C_component</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nan_to_zero</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cavg_meth (NumPy): expected array with at least 3 dims (time,y,x)&quot;</span><span class="p">)</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="o">==</span> <span class="n">x_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">wrap_x</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">core</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ny</span> <span class="o">==</span> <span class="n">y_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">core</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1"># pad/crop to target</span>
        <span class="n">pad_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_len</span> <span class="o">-</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pad_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_len</span> <span class="o">-</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pad_y</span> <span class="ow">or</span> <span class="n">pad_x</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">)),</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrap_x</span> <span class="ow">and</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[:,</span> <span class="p">:</span><span class="n">y_len</span><span class="p">,</span> <span class="p">:</span><span class="n">x_len</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeaIceClassification.B2Ta">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.B2Ta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">B2Ta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uB</span><span class="p">,</span> <span class="n">vB</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute T-cell speed magnitude by B-&gt;T averaging (method A) of u and v.</span>

<span class="sd">        This routine:</span>
<span class="sd">        1) Averages corner-staggered u and v to T-cell centers using `Bavg_methA`.</span>
<span class="sd">        2) Computes speed magnitude: sqrt(uT^2 + vT^2).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uB, vB : numpy.ndarray</span>
<span class="sd">            Corner-staggered velocity components with shape (time, y, x).</span>
<span class="sd">        y_len, x_len : int</span>
<span class="sd">            Target T-grid spatial dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sT : numpy.ndarray</span>
<span class="sd">            T-centered speed magnitude with shape (time, y_len, x_len).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Because `Bavg_methA` propagates NaNs, this speed product will also be NaN</span>
<span class="sd">        where any of the contributing corners are NaN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bavg_methA</span><span class="p">(</span><span class="n">uB</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">)</span>
        <span class="n">vT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bavg_methA</span><span class="p">(</span><span class="n">vB</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">)</span>
        <span class="n">sT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uT</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">vT</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sT</span></div>


<div class="viewcode-block" id="SeaIceClassification.B2Tb">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.B2Tb">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">B2Tb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uB</span><span class="p">,</span> <span class="n">vB</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">,</span> <span class="n">wrap_x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute T-cell speed magnitude by B-&gt;T averaging (method B) of u and v.</span>

<span class="sd">        This routine:</span>
<span class="sd">        1) Averages corner-staggered u and v to T-cell centers using `Bavg_methB`</span>
<span class="sd">            (NaNs treated as 0.0 to enforce no-slip at masked corners).</span>
<span class="sd">        2) Computes speed magnitude: sqrt(uT^2 + vT^2).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uB, vB : numpy.ndarray</span>
<span class="sd">            Corner-staggered velocity components with shape (time, y, x).</span>
<span class="sd">        y_len, x_len : int</span>
<span class="sd">            Target T-grid spatial dimensions.</span>
<span class="sd">        wrap_x : bool</span>
<span class="sd">            Whether to wrap the x-direction cyclically during averaging.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sT : numpy.ndarray</span>
<span class="sd">            T-centered speed magnitude with shape (time, y_len, x_len).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is typically more robust near land masks because NaNs are treated</span>
<span class="sd">        as 0.0 prior to averaging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bavg_methB</span><span class="p">(</span><span class="n">uB</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">,</span> <span class="n">wrap_x</span><span class="p">)</span>
        <span class="n">vT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bavg_methB</span><span class="p">(</span><span class="n">vB</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">,</span> <span class="n">wrap_x</span><span class="p">)</span>
        <span class="n">sT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uT</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">vT</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sT</span><span class="c1">#, uT, vT</span></div>


<div class="viewcode-block" id="SeaIceClassification.B2Tx">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.B2Tx">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">B2Tx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uB_da</span><span class="p">,</span> <span class="n">vB_da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Regrid B-grid velocity components to T points via xESMF and compute speed.</span>

<span class="sd">        This method uses a pre-defined regridder `self.reG` (constructed by</span>
<span class="sd">        `define_reG_weights` / `_ensure_reG_defined`) to map B-grid corner fields onto</span>
<span class="sd">        the T-grid. Prior to regridding, NaNs are replaced by 0.0 to enforce a</span>
<span class="sd">        no-slip-style boundary condition.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uB_da, vB_da : xarray.DataArray</span>
<span class="sd">            Corner-staggered velocity components. Must be compatible with the</span>
<span class="sd">            configured xESMF regridder. Typically dims are (time, y, x) or similar.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ispd_Tx : xarray.DataArray</span>
<span class="sd">            T-grid speed magnitude computed as hypot(uT, vT), dtype float32. Uses</span>
<span class="sd">            `xr.apply_ufunc(..., dask=&quot;parallelized&quot;)` for Dask compatibility.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This is distinct from the simple 2x2 averaging methods (`B2Ta`, `B2Tb`);</span>
<span class="sd">        it uses spatial regridding (often bilinear) and may yield smoother fields.</span>
<span class="sd">        - Because NaNs are converted to 0.0, masked/corner land values do not</span>
<span class="sd">        propagate into neighbouring T cells in the same way as NaN-preserving</span>
<span class="sd">        averages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_reG_defined</span><span class="p">()</span>
        <span class="n">uTx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reG</span><span class="p">(</span><span class="n">uB_da</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>  <span class="c1"># no-slip: NaNs-&gt;0</span>
        <span class="n">vTx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reG</span><span class="p">(</span><span class="n">vB_da</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">,</span> <span class="n">uTx</span><span class="p">,</span> <span class="n">vTx</span><span class="p">,</span> <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span> <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">])</span></div>

    
<div class="viewcode-block" id="SeaIceClassification.C2T">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.C2T">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">C2T</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvelE</span><span class="p">,</span> <span class="n">uvelN</span><span class="p">,</span> <span class="n">vvelE</span><span class="p">,</span> <span class="n">vvelN</span><span class="p">,</span>
            <span class="n">y_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">x_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">wrap_x</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">combine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
            <span class="n">nan_to_zero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct T-grid east/north velocity components from C-grid edge fields.</span>

<span class="sd">        Inputs are assumed to be *physical* components in the local east/north basis:</span>
<span class="sd">        - uvelE, uvelN: (E,N) components defined on the U-stagger (x-faces)</span>
<span class="sd">        - vvelE, vvelN: (E,N) components defined on the V-stagger (y-faces)</span>

<span class="sd">        The mapping is performed by edge-to-center averaging:</span>
<span class="sd">        - U-stagger → T via direction=&quot;x&quot;</span>
<span class="sd">        - V-stagger → T via direction=&quot;y&quot;</span>

<span class="sd">        Then the two estimates are combined to produce a single (E,N) pair at T.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uvelE, uvelN, vvelE, vvelN : xarray.DataArray or array-like</span>
<span class="sd">            C-grid velocity components on the U and V staggers.</span>
<span class="sd">        y_len, x_len : int, optional</span>
<span class="sd">            Target T-grid spatial sizes. Defaults to `self.CICE_dict[&quot;*_dim_length&quot;]`.</span>
<span class="sd">        wrap_x : bool, optional</span>
<span class="sd">            Seam handling in x. Defaults to `self.CICE_dict.get(&quot;wrap_x&quot;, True)`.</span>
<span class="sd">        combine : {&quot;mean&quot;,&quot;uv&quot;}, default &quot;mean&quot;</span>
<span class="sd">            How to combine U- and V-stagger estimates at T:</span>
<span class="sd">            - &quot;mean&quot;: E_T = 0.5*(E_from_U + E_from_V), N_T = 0.5*(N_from_U + N_from_V)</span>
<span class="sd">            - &quot;uv&quot;  : E_T = E_from_U, N_T = N_from_V (classic C-grid intuition)</span>
<span class="sd">        nan_to_zero : bool, default True</span>
<span class="sd">            If True, treat NaNs as 0 prior to averaging (no-slip-like).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        velE_T, velN_T : same type as inputs</span>
<span class="sd">            Eastward and northward velocity components at T-cell centers.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you only need speed, you can compute `hypot(velE_T, velN_T)` downstream</span>
<span class="sd">        using `xr.apply_ufunc(np.hypot, ...)` for Dask-parallel execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_len</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;y_dim_length&quot;</span><span class="p">])</span>
        <span class="n">x_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_len</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;x_dim_length&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">wrap_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wrap_x</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;wrap_x&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="c1"># Map each stagger to T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;averaging uvelE to T-grid&quot;</span><span class="p">)</span>
        <span class="n">EU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cavg_meth</span><span class="p">(</span><span class="n">uvelE</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y_len</span><span class="o">=</span><span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="o">=</span><span class="n">x_len</span><span class="p">,</span> <span class="n">wrap_x</span><span class="o">=</span><span class="n">wrap_x</span><span class="p">,</span> <span class="n">nan_to_zero</span><span class="o">=</span><span class="n">nan_to_zero</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;averaging uvelN to T-grid&quot;</span><span class="p">)</span>
        <span class="n">NU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cavg_meth</span><span class="p">(</span><span class="n">uvelN</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y_len</span><span class="o">=</span><span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="o">=</span><span class="n">x_len</span><span class="p">,</span> <span class="n">wrap_x</span><span class="o">=</span><span class="n">wrap_x</span><span class="p">,</span> <span class="n">nan_to_zero</span><span class="o">=</span><span class="n">nan_to_zero</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;averaging vvelE to T-grid&quot;</span><span class="p">)</span>
        <span class="n">EV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cavg_meth</span><span class="p">(</span><span class="n">vvelE</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y_len</span><span class="o">=</span><span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="o">=</span><span class="n">x_len</span><span class="p">,</span> <span class="n">wrap_x</span><span class="o">=</span><span class="n">wrap_x</span><span class="p">,</span> <span class="n">nan_to_zero</span><span class="o">=</span><span class="n">nan_to_zero</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;averaging vvelN to T-grid&quot;</span><span class="p">)</span>
        <span class="n">NV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cavg_meth</span><span class="p">(</span><span class="n">vvelN</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y_len</span><span class="o">=</span><span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="o">=</span><span class="n">x_len</span><span class="p">,</span> <span class="n">wrap_x</span><span class="o">=</span><span class="n">wrap_x</span><span class="p">,</span> <span class="n">nan_to_zero</span><span class="o">=</span><span class="n">nan_to_zero</span><span class="p">)</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="p">(</span><span class="n">combine</span> <span class="ow">or</span> <span class="s2">&quot;mean&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">combine</span> <span class="o">==</span> <span class="s2">&quot;uv&quot;</span><span class="p">:</span>
            <span class="n">velE_T</span> <span class="o">=</span> <span class="n">EU</span>
            <span class="n">velN_T</span> <span class="o">=</span> <span class="n">NV</span>
        <span class="k">elif</span> <span class="n">combine</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">velE_T</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">EU</span> <span class="o">+</span> <span class="n">EV</span><span class="p">)</span>
            <span class="n">velN_T</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">NU</span> <span class="o">+</span> <span class="n">NV</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;C2T: combine must be &#39;mean&#39; or &#39;uv&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">velE_T</span><span class="p">,</span> <span class="n">velN_T</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_binary_days</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> 
                     <span class="n">win</span>     <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                     <span class="n">min_days</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="n">centered</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a binary-day (persistence) filter to a 0/1 mask using a sliding window.</span>

<span class="sd">        For each time index, this computes the number of &#39;1&#39; days within a window of</span>
<span class="sd">        length `win`. The output is 1 where the count is at least `min_days`, else 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : numpy.ndarray</span>
<span class="sd">            Input mask of shape (time, nj, ni). Values may be bool or {0,1}. NaNs are</span>
<span class="sd">            treated as 0.</span>
<span class="sd">        win : int</span>
<span class="sd">            Window length in timesteps/days.</span>
<span class="sd">        min_days : int</span>
<span class="sd">            Minimum number of &#39;1&#39; values required within the window to mark the</span>
<span class="sd">            central/trailing time as 1. Values greater than `win` are clipped to `win`.</span>
<span class="sd">        centered : bool, default=True</span>
<span class="sd">            If True, the window is centered on each time. If False, uses a trailing</span>
<span class="sd">            window ending at each time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : numpy.ndarray</span>
<span class="sd">            uint8 array of shape (time, nj, ni) with values {0,1}.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Uses `numpy.lib.stride_tricks.sliding_window_view` along the time axis,</span>
<span class="sd">        producing an intermediate array of shape (T-win+1, nj, ni, win).</span>
<span class="sd">        - Edge handling is by zero padding (i.e., edges default to 0 where a full</span>
<span class="sd">        window is not available). This differs from xarray rolling with partial</span>
<span class="sd">        windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="c1"># convert {NaN,0,1} → {0,0,1}</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">win</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win</span><span class="p">);</span> <span class="n">min_days</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_days</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_days</span> <span class="o">&gt;</span> <span class="n">win</span><span class="p">:</span>
            <span class="n">min_days</span> <span class="o">=</span> <span class="n">win</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">wv</span> <span class="o">=</span> <span class="n">sliding_window_view</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">window_shape</span><span class="o">=</span><span class="n">win</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># (T-win+1, ny, nx, win)</span>
        <span class="n">meets</span> <span class="o">=</span> <span class="p">(</span><span class="n">wv</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_days</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">centered</span><span class="p">:</span>
            <span class="n">pad_before</span> <span class="o">=</span> <span class="p">(</span><span class="n">win</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">pad_after</span>  <span class="o">=</span> <span class="p">(</span><span class="n">win</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">pad_before</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># trailing window</span>
            <span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span> <span class="o">=</span> <span class="n">win</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">meets</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="SeaIceClassification.classify_binary_days_mask">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.classify_binary_days_mask">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_binary_days_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I_mask</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                                 <span class="n">mask_name</span>   <span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                 <span class="n">bin_win_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">bin_min_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">time_dim</span>    <span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">centered</span>    <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a generic binary-day persistence mask using xarray rolling counts.</span>

<span class="sd">        In each rolling window of length W, the mask is set to 1 if at least M days</span>
<span class="sd">        are True/1 within that window:</span>
<span class="sd">            mask_bin(t) = 1 if sum(mask[t-window]) &gt;= M else 0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I_mask : xarray.DataArray</span>
<span class="sd">            Input boolean or 0/1 mask with dimensions (time, y, x).</span>
<span class="sd">        mask_name : str</span>
<span class="sd">            Name of the output variable (e.g., &quot;FI_mask&quot;, &quot;PI_mask&quot;).</span>
<span class="sd">        bin_win_days : int, optional</span>
<span class="sd">            Window length W. Defaults to `self.bin_win_days` when None.</span>
<span class="sd">        bin_min_days : int, optional</span>
<span class="sd">            Minimum days M. Defaults to `self.bin_min_days` when None.</span>
<span class="sd">        time_dim : str, optional</span>
<span class="sd">            Name of the time dimension. Defaults to `self.CICE_dict[&quot;time_dim&quot;]`.</span>
<span class="sd">        centered : bool, default=True</span>
<span class="sd">            If True, uses a centered window. If False, uses a trailing window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds : xarray.Dataset</span>
<span class="sd">            Dataset containing one uint8 variable named `mask_name`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Time chunking is adjusted so that time chunks are not larger than the</span>
<span class="sd">        rolling window, which generally improves Dask rolling performance.</span>
<span class="sd">        - Rolling uses `min_periods=M`, so partial windows can contribute when at</span>
<span class="sd">        least M samples are available; this differs from a strict “full-window only”</span>
<span class="sd">        approach.</span>
<span class="sd">        - If the input has zero time length, returns an empty dataset (with logging).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_dim</span> <span class="o">=</span> <span class="n">time_dim</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">]</span>
        <span class="n">W</span>        <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_win_days</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_win_days</span><span class="p">)</span>
        <span class="n">M</span>        <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_min_days</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_min_days</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">mask_name</span><span class="si">}</span><span class="s2"> has zero time length for this slice; returning empty dataset.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">mask_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span>
        <span class="n">tlen</span> <span class="o">=</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span>
        <span class="n">tch</span>  <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">tlen</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">chunksizes</span><span class="p">[</span><span class="n">time_dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">chunksizes</span><span class="p">[</span><span class="n">time_dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tch</span><span class="p">:</span>
            <span class="n">I_mask</span> <span class="o">=</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">tch</span><span class="p">})</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rolling</span><span class="p">({</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">W</span><span class="p">},</span> <span class="n">center</span><span class="o">=</span><span class="n">centered</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">da_bin</span> <span class="o">=</span> <span class="p">(</span><span class="n">counts</span> <span class="o">&gt;=</span> <span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">mask_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_bin</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span></div>


<div class="viewcode-block" id="SeaIceClassification.classify_binary_days_fast_ice">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.classify_binary_days_fast_ice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_binary_days_fast_ice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FI_mask</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                                      <span class="n">bin_win_days</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">bin_min_days</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">time_dim</span>     <span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">centered</span>     <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Backward-compatible wrapper: binary-day persistence for fast-ice masks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        FI_mask : xarray.DataArray</span>
<span class="sd">            Input fast-ice mask (boolean or 0/1) with dimensions (time, y, x).</span>
<span class="sd">        bin_win_days, bin_min_days : int, optional</span>
<span class="sd">            Window length and minimum count passed to `classify_binary_days_mask`.</span>
<span class="sd">        time_dim : str, optional</span>
<span class="sd">            Time dimension name passed to `classify_binary_days_mask`.</span>
<span class="sd">        centered : bool, default=True</span>
<span class="sd">            Center the rolling window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.Dataset</span>
<span class="sd">            Dataset containing a uint8 variable named &quot;FI_mask&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classify_binary_days_mask</span><span class="p">(</span><span class="n">FI_mask</span><span class="p">,</span>
                                             <span class="n">mask_name</span>    <span class="o">=</span> <span class="s2">&quot;FI_mask&quot;</span><span class="p">,</span>
                                             <span class="n">bin_win_days</span> <span class="o">=</span> <span class="n">bin_win_days</span><span class="p">,</span>
                                             <span class="n">bin_min_days</span> <span class="o">=</span> <span class="n">bin_min_days</span><span class="p">,</span>
                                             <span class="n">time_dim</span>     <span class="o">=</span> <span class="n">time_dim</span><span class="p">,</span>
                                             <span class="n">centered</span>     <span class="o">=</span> <span class="n">centered</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeaIceClassification.classify_binary_days_pack_ice">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.classify_binary_days_pack_ice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_binary_days_pack_ice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PI_mask</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                                      <span class="n">bin_win_days</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">bin_min_days</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">time_dim</span>     <span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">centered</span>     <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper: binary-day persistence for pack-ice masks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        PI_mask : xarray.DataArray</span>
<span class="sd">            Input pack-ice mask (boolean or 0/1) with dimensions (time, y, x).</span>
<span class="sd">        bin_win_days, bin_min_days : int, optional</span>
<span class="sd">            Window length and minimum count passed to `classify_binary_days_mask`.</span>
<span class="sd">        time_dim : str, optional</span>
<span class="sd">            Time dimension name passed to `classify_binary_days_mask`.</span>
<span class="sd">        centered : bool, default=True</span>
<span class="sd">            Center the rolling window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.Dataset</span>
<span class="sd">            Dataset containing a uint8 variable named &quot;PI_mask&quot;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        “Pack ice” here is the converse classification of fast ice under the same</span>
<span class="sd">        concentration threshold and a speed threshold (defined elsewhere).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classify_binary_days_mask</span><span class="p">(</span><span class="n">PI_mask</span><span class="p">,</span>
                                             <span class="n">mask_name</span>    <span class="o">=</span> <span class="s2">&quot;PI_mask&quot;</span><span class="p">,</span>
                                             <span class="n">bin_win_days</span> <span class="o">=</span> <span class="n">bin_win_days</span><span class="p">,</span>
                                             <span class="n">bin_min_days</span> <span class="o">=</span> <span class="n">bin_min_days</span><span class="p">,</span>
                                             <span class="n">time_dim</span>     <span class="o">=</span> <span class="n">time_dim</span><span class="p">,</span>
                                             <span class="n">centered</span>     <span class="o">=</span> <span class="n">centered</span><span class="p">)</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_wrap_x_last_equals_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="n">xdim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;x_dim&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">xdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">da</span>
        <span class="k">if</span> <span class="n">xdim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="n">xdim</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">xdim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)})</span>
        <span class="n">last_label</span> <span class="o">=</span> <span class="n">da</span><span class="p">[</span><span class="n">xdim</span><span class="p">]</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">xdim</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">})</span>
        <span class="n">first_col</span>  <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">xdim</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="n">xdim</span><span class="p">]</span> <span class="o">!=</span> <span class="n">last_label</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">first_col</span><span class="p">)</span>
    
<div class="viewcode-block" id="SeaIceClassification.compute_ispdT">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.compute_ispdT">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_ispdT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvel</span><span class="p">,</span> <span class="n">vvel</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute T-grid sea-ice speed magnitude using the configured staggering→T strategy.</span>

<span class="sd">        Supported conversion modes in `self.BorC2T_type`:</span>
<span class="sd">        - &quot;Ta&quot;: B-grid corner 2x2 mean (NaNs propagate) via `B2Ta`</span>
<span class="sd">        - &quot;Tb&quot;: B-grid corner 2x2 mean (NaNs-&gt;0, no-slip) via `B2Tb`</span>
<span class="sd">        - &quot;Tx&quot;: regrid (xESMF) via `B2Tx`</span>
<span class="sd">        - &quot;Tc&quot;: C-grid edge→center reconstruction from (uvelE/uvelN/vvelE/vvelN) via `C2T`</span>

<span class="sd">        IMPORTANT: &quot;Tc&quot; is exclusive. If &quot;Tc&quot; is selected, it must be the only mode</span>
<span class="sd">        and the result is NOT averaged with other modes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uvel, vvel : xarray.DataArray or xarray.Dataset</span>
<span class="sd">            For Ta/Tb/Tx:</span>
<span class="sd">                uvel and vvel are the usual B-grid corner-staggered components.</span>
<span class="sd">            For Tc:</span>
<span class="sd">                pass a Dataset (or mapping-like object) containing the four required</span>
<span class="sd">                variables: uvelE, uvelN, vvelE, vvelN. `vvel` is ignored in this case.</span>
<span class="sd">        label : str, optional</span>
<span class="sd">            Optional label for logging; not required.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ispd_T : xarray.DataArray</span>
<span class="sd">            T-grid speed magnitude (float32).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If &quot;Tc&quot; is combined with other modes, or if required C-grid variables</span>
<span class="sd">            are missing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sel</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b2t_selection_set</span><span class="p">()</span>
        <span class="n">is_Tc</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Tc&quot;</span> <span class="ow">in</span> <span class="n">sel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_Tc</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uvel</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">uvel</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uvel</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">uvel</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tc requires `uvel` to be an xarray.Dataset (or dict-like) containing uvelE, uvelN, vvelE, vvelN.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">req</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;uvelE&quot;</span><span class="p">,</span> <span class="s2">&quot;uvelN&quot;</span><span class="p">,</span> <span class="s2">&quot;vvelE&quot;</span><span class="p">,</span> <span class="s2">&quot;vvelN&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tc requested but missing required C-grid variable &#39;</span><span class="si">{</span><span class="n">req</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="n">y_len</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;y_dim_length&quot;</span><span class="p">]</span>
            <span class="n">x_len</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;x_dim_length&quot;</span><span class="p">]</span>
            <span class="n">wrap_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;wrap_x&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing ice speeds from C-grid to T-grid&quot;</span><span class="p">)</span>
            <span class="n">velE_T</span><span class="p">,</span> <span class="n">velN_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C2T</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="s2">&quot;uvelE&quot;</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;uvelN&quot;</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;vvelE&quot;</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;vvelN&quot;</span><span class="p">],</span>
                                      <span class="n">y_len</span>       <span class="o">=</span> <span class="n">y_len</span><span class="p">,</span>
                                      <span class="n">x_len</span>       <span class="o">=</span> <span class="n">x_len</span><span class="p">,</span>
                                      <span class="n">wrap_x</span>      <span class="o">=</span> <span class="n">wrap_x</span><span class="p">,</span>
                                      <span class="n">combine</span>     <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> 
                                      <span class="n">nan_to_zero</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">ispd_Tc</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">,</span> <span class="n">velE_T</span><span class="p">,</span> <span class="n">velN_T</span><span class="p">,</span>
                                     <span class="n">dask</span>          <span class="o">=</span> <span class="s2">&quot;parallelized&quot;</span><span class="p">,</span> 
                                     <span class="n">output_dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;wrap_x&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">ispd_Tc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_x_last_equals_first</span><span class="p">(</span><span class="n">ispd_Tc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ispd_Tc</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;ispd_Tc&quot;</span><span class="p">)</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># Existing multi-member branch</span>
        <span class="c1"># -----------------------------</span>
        <span class="n">y_len</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;y_dim_length&quot;</span><span class="p">]</span>
        <span class="n">x_len</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;x_dim_length&quot;</span><span class="p">]</span>
        <span class="n">wrap_x</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;wrap_x&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">members</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s2">&quot;Ta&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BorC2T_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;B2Ta&quot;</span><span class="p">):</span>
                <span class="n">ispd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B2Ta</span><span class="p">(</span><span class="n">uvel</span><span class="p">,</span> <span class="n">vvel</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">ispd_Ta</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">ispd</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;three_dims&quot;</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ispd_Ta&quot;</span><span class="p">)</span>
                <span class="n">members</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ispd_Ta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Ta requested in BorC2T_type but B2Ta not defined. Skipping Ta.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;Tb&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BorC2T_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;B2Tb&quot;</span><span class="p">):</span>
                <span class="n">ispd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B2Tb</span><span class="p">(</span><span class="n">uvel</span><span class="p">,</span> <span class="n">vvel</span><span class="p">,</span> <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span><span class="p">,</span> <span class="n">wrap_x</span><span class="o">=</span><span class="n">wrap_x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">ispd_Tb</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">ispd</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;three_dims&quot;</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ispd_Tb&quot;</span><span class="p">)</span>
                <span class="n">members</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ispd_Tb</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Tb requested in BorC2T_type but B2Tb not defined. Skipping Tb.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;Tx&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BorC2T_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;B2Tx&quot;</span><span class="p">):</span>
                <span class="n">ispd_Tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B2Tx</span><span class="p">(</span><span class="n">uvel</span><span class="p">,</span> <span class="n">vvel</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;ispd_Tx&quot;</span><span class="p">)</span>
                <span class="n">members</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ispd_Tx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Tx requested in BorC2T_type but B2Tx not defined. Skipping Tx.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">members</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">members</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">members</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;__concat_dim__&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s2">&quot;__concat_dim__&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_thresholds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">ispd_T</span>   <span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                          <span class="n">aice</span>     <span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                          <span class="n">label</span>    <span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                          <span class="n">ice_type</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;FI&quot;</span><span class="p">,</span>
                          <span class="n">mask_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply hemisphere slicing and speed/concentration thresholds to build an ice-class mask.</span>

<span class="sd">        This method slices both speed and concentration to the configured hemisphere,</span>
<span class="sd">        applies class-dependent threshold logic, and returns a compact chunked dataset</span>
<span class="sd">        containing a single 0/1 mask variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ispd_T : xarray.DataArray</span>
<span class="sd">            T-grid ice-speed magnitude with dimensions (time, y, x).</span>
<span class="sd">        aice : xarray.DataArray</span>
<span class="sd">            Sea-ice concentration on the same grid and dimensions as `ispd_T`.</span>
<span class="sd">        label : str</span>
<span class="sd">            Descriptive label used in log messages (e.g., &quot;daily&quot;, &quot;rolling-mean&quot;).</span>
<span class="sd">        ice_type : {&quot;FI&quot;,&quot;PI&quot;}, default=&quot;FI&quot;</span>
<span class="sd">            Classification type:</span>
<span class="sd">            - FI (fast ice): (aice &gt; icon_thresh) AND (0 &lt; speed &lt;= ispd_thresh)</span>
<span class="sd">            - PI (pack ice): (aice &gt; icon_thresh) AND (speed &gt; ispd_thresh)</span>
<span class="sd">        mask_name : str, optional</span>
<span class="sd">            Output variable name. Defaults to &quot;{ice_type}_mask&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds : xarray.Dataset</span>
<span class="sd">            Dataset with one boolean variable named `mask_name`, chunked according to</span>
<span class="sd">            `self.CICE_dict[&quot;FI_chunks&quot;]` and computed into memory.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `ice_type` is not one of {&quot;FI&quot;,&quot;PI&quot;}.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Hemisphere slicing is performed via `self.slice_hemisphere`.</span>
<span class="sd">        - The result is `.compute()`&#39;d to materialize the mask (and avoid deferred</span>
<span class="sd">        graphs in downstream workflows).</span>
<span class="sd">        - Any coordinate variables that duplicate spatial dims are dropped to keep the</span>
<span class="sd">        dataset compact and consistent for writing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ice_type_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">ice_type</span> <span class="ow">or</span> <span class="s2">&quot;FI&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">mask_name</span>  <span class="o">=</span> <span class="n">mask_name</span> <span class="ow">or</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ice_type_u</span><span class="si">}</span><span class="s2">_mask&quot;</span>
        <span class="n">ispd_hem</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="n">ispd_T</span><span class="p">)</span>
        <span class="n">aice_hem</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="n">aice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ice_type_u</span> <span class="o">==</span> <span class="s2">&quot;FI&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   thresholding (</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">): aice&gt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> and 0&lt;speed&lt;=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ispd_thresh</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">I_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">aice_hem</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ispd_hem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ispd_hem</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ispd_thresh</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ice_type_u</span> <span class="o">==</span> <span class="s2">&quot;PI&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   thresholding (</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">): aice&gt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> and speed&gt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ispd_thresh</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">)</span>
            <span class="n">I_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">aice_hem</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ispd_hem</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ispd_thresh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported ice_type=&#39;</span><span class="si">{</span><span class="n">ice_type</span><span class="si">}</span><span class="s2">&#39;. Expected &#39;FI&#39; or &#39;PI&#39;.&quot;</span><span class="p">)</span>
        <span class="n">DS</span> <span class="o">=</span> <span class="n">I_mask</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">mask_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;FI_chunks&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="c1"># Drop any spatial coords that duplicate dims (keeps output compact/consistent)</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spatial_dims&#39;</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">DS</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="n">DS</span> <span class="o">=</span> <span class="n">DS</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DS</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_with_T_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attach standard T-grid auxiliary coordinates (lon, lat, angle, area) to a DataArray.</span>

<span class="sd">        This is a convenience utility to ensure diagnostic fields (e.g., speed) carry</span>
<span class="sd">        T-grid geolocation and cell metadata. The method assumes the spatial</span>
<span class="sd">        dimensions match `self.CICE_dict[&quot;spatial_dims&quot;]` and that `self.G_t` has been</span>
<span class="sd">        loaded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        da : xarray.DataArray</span>
<span class="sd">            DataArray with spatial dims matching the model T-grid, typically with</span>
<span class="sd">            overall dims (time, y, x).</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            New name for the DataArray. If None, keeps `da.name`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        da_out : xarray.DataArray</span>
<span class="sd">            DataArray with added coordinates:</span>
<span class="sd">            - lon(y,x), lat(y,x), angle(y,x), area(y,x)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This attaches coordinates as 2D arrays; it does not modify the underlying data</span>
<span class="sd">        or rechunk by itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ydim</span><span class="p">,</span> <span class="n">xdim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;spatial_dims&quot;</span><span class="p">]</span>
        <span class="n">da</span>         <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="n">da</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">da</span>         <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s2">&quot;lon&quot;</span>  <span class="p">:</span> <span class="p">((</span><span class="n">ydim</span><span class="p">,</span> <span class="n">xdim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
                                       <span class="s2">&quot;lat&quot;</span>  <span class="p">:</span> <span class="p">((</span><span class="n">ydim</span><span class="p">,</span> <span class="n">xdim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
                                       <span class="s2">&quot;angle&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">ydim</span><span class="p">,</span> <span class="n">xdim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;angle&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
                                       <span class="s2">&quot;area&quot;</span> <span class="p">:</span> <span class="p">((</span><span class="n">ydim</span><span class="p">,</span> <span class="n">xdim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)})</span>
        <span class="k">return</span> <span class="n">da</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_b2t_selection_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize self.BorC2T_type into a set of mode tokens, e.g. {&quot;Ta&quot;,&quot;Tb&quot;} or {&quot;Tc&quot;}.</span>
<span class="sd">        Accepts list/tuple/set or a string (optionally comma/space separated).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b2t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;BorC2T_type&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b2t</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">b2t</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()}</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;logger&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BorC2T_type raw=</span><span class="si">{</span><span class="n">b2t</span><span class="si">!r}</span><span class="s2"> (iterable) -&gt; selection=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sel</span>

        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">b2t</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="k">if</span> <span class="n">s</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;logger&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BorC2T_type raw=</span><span class="si">{</span><span class="n">b2t</span><span class="si">!r}</span><span class="s2"> (string) -&gt; normalized=</span><span class="si">{</span><span class="n">s</span><span class="si">!r}</span><span class="s2"> -&gt; selection=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sel</span>

<div class="viewcode-block" id="SeaIceClassification.classify_fast_ice">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.classify_fast_ice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_fast_ice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">dt0_str</span>               <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">dtN_str</span>               <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">bin_win_days</span>          <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">bin_min_days</span>          <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">enable_rolling_output</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">roll_win_days</span>         <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">time_dim_name</span>         <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify fast ice (FI) from model output using daily, persistence, and optional rolling criteria.</span>

<span class="sd">        Fast ice is defined where sea-ice concentration exceeds a threshold and ice</span>
<span class="sd">        speed is small (immobile) but non-zero:</span>
<span class="sd">            FI := (aice &gt; icon_thresh) AND (0 &lt; speed &lt;= ispd_thresh)</span>

<span class="sd">        The method returns:</span>
<span class="sd">        1) A daily FI mask computed directly from instantaneous (daily) T-grid speed.</span>
<span class="sd">        2) A binary-day (persistence) FI mask computed from the *extended-range* daily</span>
<span class="sd">            mask using a W-day window requiring at least M FI days.</span>
<span class="sd">        3) Optionally, a rolling-mean FI mask computed from a rolling-mean speed field.</span>
<span class="sd">        4) Speed diagnostics (daily and optional rolling speed) in `ispd_out`.</span>

<span class="sd">        To avoid edge artefacts in persistence and rolling calculations, the input time</span>
<span class="sd">        range is extended by half the largest window on each side, masks are computed</span>
<span class="sd">        on the extended range, and then cropped back to [dt0_str, dtN_str].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt0_str, dtN_str : str</span>
<span class="sd">            Start and end dates (inclusive) in a pandas-parsable format (e.g., &quot;YYYY-MM-DD&quot;).</span>
<span class="sd">        bin_win_days : int, optional</span>
<span class="sd">            Persistence window length W (days). Defaults to `self.bin_win_days`.</span>
<span class="sd">        bin_min_days : int, optional</span>
<span class="sd">            Minimum FI days M within the window. Defaults to `self.bin_min_days`.</span>
<span class="sd">        enable_rolling_output : bool, default=False</span>
<span class="sd">            If True, also compute a rolling-mean speed field and corresponding FI mask.</span>
<span class="sd">        roll_win_days : int, optional</span>
<span class="sd">            Rolling-mean window length (days). Defaults to `self.mean_period`.</span>
<span class="sd">        time_dim_name : str, optional</span>
<span class="sd">            Name of the time dimension. Defaults to `self.CICE_dict[&quot;time_dim&quot;]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        FI_dly : xarray.Dataset</span>
<span class="sd">            Daily fast-ice mask dataset with variable &quot;FI_mask&quot; over [dt0_str, dtN_str].</span>
<span class="sd">        FI_bin : xarray.Dataset</span>
<span class="sd">            Binary-day (persistence) fast-ice mask dataset with variable &quot;FI_mask&quot; over</span>
<span class="sd">            [dt0_str, dtN_str].</span>
<span class="sd">        FI_roll : xarray.Dataset or None</span>
<span class="sd">            Rolling-mean fast-ice mask dataset with variable &quot;FI_mask&quot; over [dt0_str, dtN_str],</span>
<span class="sd">            or None if `enable_rolling_output` is False.</span>
<span class="sd">        ispd_out : dict</span>
<span class="sd">            Dictionary with speed diagnostics:</span>
<span class="sd">            - &quot;daily&quot;: DataArray &quot;ispd_T&quot;</span>
<span class="sd">            - &quot;rolly&quot;: DataArray &quot;ispd_T_roll&quot; (if enabled), else None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Loads variables [&#39;aice&#39;,&#39;uvel&#39;,&#39;vvel&#39;] over an extended time range.</span>
<span class="sd">        - Computes T-grid speed once on the extended range and reuses it.</span>
<span class="sd">        - Uses Dask-friendly chunking with small time chunks to improve rolling operations.</span>
<span class="sd">        - The binary-day mask is computed from the extended daily mask to prevent “all-zero”</span>
<span class="sd">        behaviour near the analysis window edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_dim</span>      <span class="o">=</span> <span class="n">time_dim_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">]</span>
        <span class="n">bin_win_days</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_win_days</span>  <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_win_days</span><span class="p">)</span>
        <span class="n">bin_min_days</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_min_days</span>  <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_min_days</span><span class="p">)</span>
        <span class="n">roll_win_days</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">roll_win_days</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_period</span><span class="p">)</span>
        <span class="n">sel</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b2t_selection_set</span><span class="p">()</span>
        <span class="n">is_Tc</span>         <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Tc&quot;</span> <span class="ow">in</span> <span class="n">sel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_Tc</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="n">sel</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Ta&quot;</span><span class="p">,</span> <span class="s2">&quot;Tb&quot;</span><span class="p">,</span> <span class="s2">&quot;Tx&quot;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;BorC2T_type includes &#39;Tc&#39; but also Ta/Tb/Tx. &#39;Tc&#39; must be exclusive.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_grid</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_Tc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">define_reG_weights</span><span class="p">()</span>
        <span class="n">ispd_out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;daily&#39;</span> <span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="s1">&#39;rolly&#39;</span> <span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="c1"># extend enough time for BOTH methods</span>
        <span class="n">ext_per</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bin_win_days</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">roll_win_days</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">enable_rolling_output</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">dt0_ext</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">dt0_str</span><span class="p">)</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">ext_per</span><span class="p">)</span>
        <span class="n">dtN_ext</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">dtN_str</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">ext_per</span><span class="p">)</span>
        <span class="c1"># Load (extended) data</span>
        <span class="k">if</span> <span class="n">is_Tc</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;aice&quot;</span><span class="p">,</span> <span class="s2">&quot;uvelE&quot;</span><span class="p">,</span> <span class="s2">&quot;uvelN&quot;</span><span class="p">,</span> <span class="s2">&quot;vvelE&quot;</span><span class="p">,</span> <span class="s2">&quot;vvelN&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">,</span><span class="s1">&#39;uvel&#39;</span><span class="p">,</span><span class="s1">&#39;vvel&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;loading model data between </span><span class="si">{</span><span class="n">dt0_ext</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">dtN_ext</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">CICE_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_zarr</span><span class="p">(</span><span class="n">slice_hem</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span><span class="p">,</span>
                                       <span class="n">dt0_str</span>   <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dt0_ext</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                       <span class="n">dtN_str</span>   <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dtN_ext</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Compact coords &amp; set friendly chunks</span>
        <span class="n">aice</span> <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_Tc</span><span class="p">:</span>
            <span class="n">uvelE</span> <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;uvelE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">uvelN</span> <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;uvelN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">vvelE</span> <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;vvelE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">vvelN</span> <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;vvelN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>            
            <span class="n">uvel</span> <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;uvel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">vvel</span> <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;vvel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># chunking is an art form</span>
        <span class="n">yck</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y_chunk&quot;</span><span class="p">,</span> <span class="mi">540</span><span class="p">)</span>
        <span class="n">xck</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x_chunk&quot;</span><span class="p">,</span> <span class="mi">1440</span><span class="p">)</span>
        <span class="n">tch</span>    <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">bin_win_days</span><span class="p">,</span> <span class="n">roll_win_days</span><span class="p">))</span>  <span class="c1"># small time chunks help rolling parallelism</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">]:</span> <span class="n">tch</span><span class="p">,</span> 
                  <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;y_dim&quot;</span><span class="p">]</span>   <span class="p">:</span> <span class="n">yck</span><span class="p">,</span> 
                  <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;x_dim&quot;</span><span class="p">]</span>   <span class="p">:</span> <span class="n">xck</span><span class="p">}</span>
        <span class="n">aice</span>   <span class="o">=</span> <span class="n">aice</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="c1"># Build T-grid speed ONCE over the extended span</span>
        <span class="k">if</span> <span class="n">is_Tc</span><span class="p">:</span>
            <span class="n">ds_vel</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">({</span><span class="s2">&quot;uvelE&quot;</span><span class="p">:</span> <span class="n">uvelE</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">),</span>
                                 <span class="s2">&quot;uvelN&quot;</span><span class="p">:</span> <span class="n">uvelN</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">),</span> 
                                 <span class="s2">&quot;vvelE&quot;</span><span class="p">:</span> <span class="n">vvelE</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">),</span>
                                 <span class="s2">&quot;vvelN&quot;</span><span class="p">:</span> <span class="n">vvelN</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">)})</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>
            <span class="n">ispd_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_ispdT</span><span class="p">(</span><span class="n">ds_vel</span><span class="p">)</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uvel</span><span class="p">,</span> <span class="n">vvel</span> <span class="o">=</span> <span class="n">uvel</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">),</span> <span class="n">vvel</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
            <span class="n">ispd_T</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_ispdT</span><span class="p">(</span><span class="n">uvel</span><span class="p">,</span> <span class="n">vvel</span><span class="p">)</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>
        <span class="c1"># DAILY ispd</span>
        <span class="n">ispd_T</span>            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_T_coords</span><span class="p">(</span><span class="n">ispd_T</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ispd_T&quot;</span><span class="p">)</span>
        <span class="n">ispd_out</span><span class="p">[</span><span class="s1">&#39;daily&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ispd_T</span>
        <span class="c1"># DAILY mask on the EXTENDED range, THEN crop</span>
        <span class="n">FI_dly_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_thresholds</span><span class="p">(</span><span class="n">ispd_T</span><span class="p">,</span> <span class="n">aice</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;daily&quot;</span><span class="p">)</span>
        <span class="n">FI_dly</span>     <span class="o">=</span> <span class="n">FI_dly_ext</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">dt0_str</span><span class="p">,</span> <span class="n">dtN_str</span><span class="p">))</span>
        <span class="c1"># BINARY-DAYS on the EXTENDED DAILY mask, THEN crop  &lt;-- this fixes your all-zero issue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;classifying binary-day fast ice mask&quot;</span><span class="p">)</span>
        <span class="n">FI_bin_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classify_binary_days_fast_ice</span><span class="p">(</span><span class="n">FI_dly_ext</span><span class="p">[</span><span class="s2">&quot;FI_mask&quot;</span><span class="p">],</span>  <span class="c1"># use extended</span>
                                                        <span class="n">bin_win_days</span> <span class="o">=</span> <span class="n">bin_win_days</span><span class="p">,</span>
                                                        <span class="n">bin_min_days</span> <span class="o">=</span> <span class="n">bin_min_days</span><span class="p">,</span>
                                                        <span class="n">time_dim</span>     <span class="o">=</span> <span class="n">time_dim</span><span class="p">,</span>
                                                        <span class="n">centered</span>     <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">FI_bin</span> <span class="o">=</span> <span class="n">FI_bin_ext</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">dt0_str</span><span class="p">,</span> <span class="n">dtN_str</span><span class="p">))</span>
        <span class="c1"># Optional ROLLING on the extended speed, THEN crop (unchanged in spirit)</span>
        <span class="n">FI_roll</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">enable_rolling_output</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;applying rolling mean on T-grid speed (period=</span><span class="si">{</span><span class="n">roll_win_days</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">ispd_T_roll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rolling_mean</span><span class="p">(</span><span class="n">ispd_T</span><span class="p">,</span> <span class="n">mean_period</span><span class="o">=</span><span class="n">roll_win_days</span><span class="p">)</span>
            <span class="n">ispd_T_roll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_T_coords</span><span class="p">(</span><span class="n">ispd_T_roll</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ispd_T_roll&quot;</span><span class="p">)</span>
            <span class="n">FI_roll_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_thresholds</span><span class="p">(</span><span class="n">ispd_T_roll</span><span class="p">,</span> <span class="n">aice</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;rolling-mean&quot;</span><span class="p">)</span>
            <span class="n">FI_roll</span>     <span class="o">=</span> <span class="n">FI_roll_ext</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">dt0_str</span><span class="p">,</span> <span class="n">dtN_str</span><span class="p">))</span>
            <span class="n">ispd_out</span><span class="p">[</span><span class="s1">&#39;rolly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ispd_T_roll</span>
        <span class="k">return</span> <span class="n">FI_dly</span><span class="p">,</span> <span class="n">FI_bin</span><span class="p">,</span> <span class="n">FI_roll</span><span class="p">,</span> <span class="n">ispd_out</span></div>


<div class="viewcode-block" id="SeaIceClassification.classify_pack_ice">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.classify_pack_ice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_pack_ice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">dt0_str</span>               <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">dtN_str</span>               <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">bin_win_days</span>          <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">bin_min_days</span>          <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">enable_rolling_output</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="n">roll_win_days</span>         <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">time_dim_name</span>         <span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify pack ice (PI) from model output using daily, persistence, and optional rolling criteria.</span>

<span class="sd">        Pack ice is defined as the complement of fast ice under the same concentration</span>
<span class="sd">        threshold, using a speed threshold:</span>
<span class="sd">            PI := (aice &gt; icon_thresh) AND (speed &gt; ispd_thresh)</span>

<span class="sd">        The method returns:</span>
<span class="sd">        1) A daily PI mask computed from instantaneous (daily) T-grid speed.</span>
<span class="sd">        2) A binary-day (persistence) PI mask computed from the *extended-range* daily</span>
<span class="sd">            mask using a W-day window requiring at least M PI days.</span>
<span class="sd">        3) Optionally, a rolling-mean PI mask computed from rolling-mean speed.</span>
<span class="sd">        4) Speed diagnostics (daily and optional rolling speed) in `ispd_out`.</span>

<span class="sd">        As with fast-ice classification, the input time range is extended to avoid</span>
<span class="sd">        edge artefacts in persistence/rolling calculations, and products are cropped</span>
<span class="sd">        back to [dt0_str, dtN_str].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt0_str, dtN_str : str</span>
<span class="sd">            Start and end dates (inclusive) in a pandas-parsable format (e.g., &quot;YYYY-MM-DD&quot;).</span>
<span class="sd">        bin_win_days : int, optional</span>
<span class="sd">            Persistence window length W (days). Defaults to `self.bin_win_days`.</span>
<span class="sd">        bin_min_days : int, optional</span>
<span class="sd">            Minimum PI days M within the window. Defaults to `self.bin_min_days`.</span>
<span class="sd">        enable_rolling_output : bool, default=False</span>
<span class="sd">            If True, also compute a rolling-mean speed field and corresponding PI mask.</span>
<span class="sd">        roll_win_days : int, optional</span>
<span class="sd">            Rolling-mean window length (days). Defaults to `self.mean_period`.</span>
<span class="sd">        time_dim_name : str, optional</span>
<span class="sd">            Name of the time dimension. Defaults to `self.CICE_dict[&quot;time_dim&quot;]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PI_dly : xarray.Dataset</span>
<span class="sd">            Daily pack-ice mask dataset with variable &quot;PI_mask&quot; over [dt0_str, dtN_str].</span>
<span class="sd">        PI_bin : xarray.Dataset</span>
<span class="sd">            Binary-day (persistence) pack-ice mask dataset with variable &quot;PI_mask&quot; over</span>
<span class="sd">            [dt0_str, dtN_str].</span>
<span class="sd">        PI_roll : xarray.Dataset or None</span>
<span class="sd">            Rolling-mean pack-ice mask dataset with variable &quot;PI_mask&quot; over [dt0_str, dtN_str],</span>
<span class="sd">            or None if `enable_rolling_output` is False.</span>
<span class="sd">        ispd_out : dict</span>
<span class="sd">            Dictionary with speed diagnostics:</span>
<span class="sd">            - &quot;daily&quot;: DataArray &quot;ispd_T&quot;</span>
<span class="sd">            - &quot;rolly&quot;: DataArray &quot;ispd_T_roll&quot; (if enabled), else None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Pack ice is only classified where `aice &gt; icon_thresh`.</span>
<span class="sd">        - Binary-day persistence is computed on the extended daily mask to avoid</span>
<span class="sd">        edge-related bias and truncation artefacts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_dim</span>      <span class="o">=</span> <span class="n">time_dim_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">]</span>
        <span class="n">bin_win_days</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_win_days</span>  <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_win_days</span><span class="p">)</span>
        <span class="n">bin_min_days</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_min_days</span>  <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_min_days</span><span class="p">)</span>
        <span class="n">roll_win_days</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">roll_win_days</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_period</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_grid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_reG_weights</span><span class="p">()</span>
        <span class="n">ispd_out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;daily&#39;</span> <span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="s1">&#39;rolly&#39;</span> <span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="c1"># extend enough time for BOTH methods</span>
        <span class="n">ext_per</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bin_win_days</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">roll_win_days</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">enable_rolling_output</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">dt0_ext</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">dt0_str</span><span class="p">)</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">ext_per</span><span class="p">)</span>
        <span class="n">dtN_ext</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">dtN_str</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">ext_per</span><span class="p">)</span>
        <span class="c1"># Load (extended) data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;loading model data between </span><span class="si">{</span><span class="n">dt0_ext</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">dtN_ext</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">CICE_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_zarr</span><span class="p">(</span><span class="n">slice_hem</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">,</span><span class="s1">&#39;uvel&#39;</span><span class="p">,</span><span class="s1">&#39;vvel&#39;</span><span class="p">],</span>
                                       <span class="n">dt0_str</span>   <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dt0_ext</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                       <span class="n">dtN_str</span>   <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dtN_ext</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Compact coords &amp; set friendly chunks</span>
        <span class="n">aice</span>   <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">uvel</span>   <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;uvel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">vvel</span>   <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;vvel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">yck</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y_chunk&quot;</span><span class="p">,</span> <span class="mi">540</span><span class="p">)</span>
        <span class="n">xck</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x_chunk&quot;</span><span class="p">,</span> <span class="mi">1440</span><span class="p">)</span>
        <span class="n">tch</span>    <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">bin_win_days</span><span class="p">,</span> <span class="n">roll_win_days</span><span class="p">))</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">]:</span> <span class="n">tch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;y_dim&quot;</span><span class="p">]:</span> <span class="n">yck</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;x_dim&quot;</span><span class="p">]:</span> <span class="n">xck</span><span class="p">}</span>
        <span class="n">aice</span><span class="p">,</span> <span class="n">uvel</span><span class="p">,</span> <span class="n">vvel</span> <span class="o">=</span> <span class="n">aice</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">),</span> <span class="n">uvel</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">),</span> <span class="n">vvel</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="c1"># Build T-grid speed ONCE over the extended span</span>
        <span class="n">ispd_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_ispdT</span><span class="p">(</span><span class="n">uvel</span><span class="p">,</span> <span class="n">vvel</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>
        <span class="n">ispd_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_T_coords</span><span class="p">(</span><span class="n">ispd_T</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ispd_T&quot;</span><span class="p">)</span>
        <span class="n">ispd_out</span><span class="p">[</span><span class="s1">&#39;daily&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ispd_T</span>
        <span class="c1"># DAILY mask on the EXTENDED range, THEN crop</span>
        <span class="n">PI_dly_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_thresholds</span><span class="p">(</span><span class="n">ispd_T</span><span class="p">,</span> <span class="n">aice</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;daily&quot;</span><span class="p">,</span> <span class="n">ice_type</span><span class="o">=</span><span class="s2">&quot;PI&quot;</span><span class="p">,</span> <span class="n">mask_name</span><span class="o">=</span><span class="s2">&quot;PI_mask&quot;</span><span class="p">)</span>
        <span class="n">PI_dly</span>     <span class="o">=</span> <span class="n">PI_dly_ext</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">dt0_str</span><span class="p">,</span> <span class="n">dtN_str</span><span class="p">))</span>
        <span class="c1"># BINARY-DAYS on the EXTENDED DAILY mask, THEN crop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;classifying binary-day pack ice mask&quot;</span><span class="p">)</span>
        <span class="n">PI_bin_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classify_binary_days_pack_ice</span><span class="p">(</span><span class="n">PI_dly_ext</span><span class="p">[</span><span class="s2">&quot;PI_mask&quot;</span><span class="p">],</span>
                                                        <span class="n">bin_win_days</span> <span class="o">=</span> <span class="n">bin_win_days</span><span class="p">,</span>
                                                        <span class="n">bin_min_days</span> <span class="o">=</span> <span class="n">bin_min_days</span><span class="p">,</span>
                                                        <span class="n">time_dim</span>     <span class="o">=</span> <span class="n">time_dim</span><span class="p">,</span>
                                                        <span class="n">centered</span>     <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">PI_bin</span> <span class="o">=</span> <span class="n">PI_bin_ext</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">dt0_str</span><span class="p">,</span> <span class="n">dtN_str</span><span class="p">))</span>
        <span class="c1"># Optional ROLLING on the extended speed, THEN crop</span>
        <span class="n">PI_roll</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">enable_rolling_output</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;applying rolling mean on T-grid speed (period=</span><span class="si">{</span><span class="n">roll_win_days</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">ispd_T_roll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rolling_mean</span><span class="p">(</span><span class="n">ispd_T</span><span class="p">,</span> <span class="n">mean_period</span><span class="o">=</span><span class="n">roll_win_days</span><span class="p">)</span>
            <span class="n">ispd_T_roll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_T_coords</span><span class="p">(</span><span class="n">ispd_T_roll</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ispd_T_roll&quot;</span><span class="p">)</span>
            <span class="n">PI_roll_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_thresholds</span><span class="p">(</span><span class="n">ispd_T_roll</span><span class="p">,</span> <span class="n">aice</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;rolling-mean&quot;</span><span class="p">,</span> <span class="n">ice_type</span><span class="o">=</span><span class="s2">&quot;PI&quot;</span><span class="p">,</span> <span class="n">mask_name</span><span class="o">=</span><span class="s2">&quot;PI_mask&quot;</span><span class="p">)</span>
            <span class="n">PI_roll</span>     <span class="o">=</span> <span class="n">PI_roll_ext</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">dt0_str</span><span class="p">,</span> <span class="n">dtN_str</span><span class="p">))</span>
            <span class="n">ispd_out</span><span class="p">[</span><span class="s1">&#39;rolly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ispd_T_roll</span>
        <span class="k">return</span> <span class="n">PI_dly</span><span class="p">,</span> <span class="n">PI_bin</span><span class="p">,</span> <span class="n">PI_roll</span><span class="p">,</span> <span class="n">ispd_out</span></div>


<div class="viewcode-block" id="SeaIceClassification.classify_sea_ice">
<a class="viewcode-back" href="../api.html#sea_ice_classification.SeaIceClassification.classify_sea_ice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_sea_ice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">dt0_str</span>       <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">dtN_str</span>       <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">time_dim_name</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify total sea ice (SI) using only a concentration threshold.</span>

<span class="sd">        Total sea ice is defined as:</span>
<span class="sd">            SI := (aice &gt; icon_thresh)</span>

<span class="sd">        This classification does not use speed, and therefore does not produce</span>
<span class="sd">        binary-day (persistence) or rolling-mean products.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt0_str, dtN_str : str</span>
<span class="sd">            Start and end dates (inclusive) in a pandas-parsable format (e.g., &quot;YYYY-MM-DD&quot;).</span>
<span class="sd">        time_dim_name : str, optional</span>
<span class="sd">            Name of the time dimension. Defaults to `self.CICE_dict[&quot;time_dim&quot;]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SI_dly : xarray.Dataset</span>
<span class="sd">            Daily sea-ice mask dataset with variable &quot;SI_mask&quot; over [dt0_str, dtN_str].</span>
<span class="sd">        SI_bin : None</span>
<span class="sd">            Always None (no persistence product for SI).</span>
<span class="sd">        SI_roll : None</span>
<span class="sd">            Always None (no rolling-mean product for SI).</span>
<span class="sd">        ispd_out : dict</span>
<span class="sd">            Empty dict, returned for API consistency with FI/PI classifiers.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Loads only `aice` (no velocity fields required).</span>
<span class="sd">        - Applies hemisphere slicing via `self.slice_hemisphere`.</span>
<span class="sd">        - Output is chunked using `self.CICE_dict[&quot;FI_chunks&quot;]` and computed into memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_dim</span> <span class="o">=</span> <span class="n">time_dim_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">]</span>
        <span class="c1"># Load aice only (no need to compute speed)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;loading model data between </span><span class="si">{</span><span class="n">dt0_str</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">dtN_str</span><span class="si">}</span><span class="s2"> (aice only)&quot;</span><span class="p">)</span>
        <span class="n">CICE_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_zarr</span><span class="p">(</span><span class="n">slice_hem</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">],</span>
                                       <span class="n">dt0_str</span>   <span class="o">=</span> <span class="n">dt0_str</span><span class="p">,</span>
                                       <span class="n">dtN_str</span>   <span class="o">=</span> <span class="n">dtN_str</span><span class="p">)</span>
        <span class="n">aice</span> <span class="o">=</span> <span class="n">CICE_all</span><span class="p">[</span><span class="s1">&#39;aice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;drop_coords&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># Chunk in a similar manner to FI/PI products</span>
        <span class="n">yck</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y_chunk&quot;</span><span class="p">,</span> <span class="mi">540</span><span class="p">)</span>
        <span class="n">xck</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x_chunk&quot;</span><span class="p">,</span> <span class="mi">1440</span><span class="p">)</span>
        <span class="n">tlen</span>   <span class="o">=</span> <span class="n">aice</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tch</span>    <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="n">tlen</span><span class="p">))</span> <span class="k">if</span> <span class="n">tlen</span> <span class="k">else</span> <span class="mi">8</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;time_dim&quot;</span><span class="p">]:</span> <span class="n">tch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;y_dim&quot;</span><span class="p">]:</span> <span class="n">yck</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;x_dim&quot;</span><span class="p">]:</span> <span class="n">xck</span><span class="p">}</span>
        <span class="n">aice</span>   <span class="o">=</span> <span class="n">aice</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="n">aice_hem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="n">aice</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   thresholding (sea-ice): aice&gt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> (no speed constraint)&quot;</span><span class="p">)</span>
        <span class="n">SI_mask</span>  <span class="o">=</span> <span class="p">(</span><span class="n">aice_hem</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">icon_thresh</span><span class="p">)</span>
        <span class="n">SI_dly</span> <span class="o">=</span> <span class="n">SI_mask</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;SI_mask&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;FI_chunks&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spatial_dims&#39;</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">SI_dly</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="n">SI_dly</span> <span class="o">=</span> <span class="n">SI_dly</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="c1"># Maintain the same return signature as classify_fast_ice / classify_pack_ice</span>
        <span class="k">return</span> <span class="n">SI_dly</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">{}</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Daniel Atwater.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>