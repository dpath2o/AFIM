

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sea_ice_gridwork &mdash; AFIM 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=01f34227"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            AFIM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AFIM_sensitivity_methodology.html">Methodology: Antarctic (Land)Fast (Sea) Ice Modelling and Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lateral_drag_form_factor_creation.html">Coastal-drag form factors from high-resolution coastline and grounded icebergs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AFIM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">sea_ice_gridwork</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sea_ice_gridwork</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w">  </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w">  </span><span class="kn">import</span> <span class="n">Path</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SeaIceGridWork&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="SeaIceGridWork">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SeaIceGridWork</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span>

<div class="viewcode-block" id="SeaIceGridWork.normalise_longitudes">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.normalise_longitudes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">normalise_longitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;0-360&quot;</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap longitudes to either [0, 360) or (-180, 180].</span>
<span class="sd">        Works with numpy arrays, scalars, and xarray objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First get [0, 360)</span>
        <span class="n">lon_wrapped</span> <span class="o">=</span> <span class="p">((</span><span class="n">lon</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>  <span class="c1"># safe for negatives, NaNs pass through</span>
        <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s2">&quot;0-360&quot;</span><span class="p">:</span>
            <span class="c1"># Collapse values extremely close to 360 back to 0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon_wrapped</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
                <span class="n">lon_wrapped</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lon_wrapped</span><span class="p">,</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">eps</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">lon_wrapped</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lon_wrapped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lon_wrapped</span><span class="p">,</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">eps</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">lon_wrapped</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lon_wrapped</span>
        <span class="k">elif</span> <span class="n">to</span> <span class="o">==</span> <span class="s2">&quot;-180-180&quot;</span><span class="p">:</span>
            <span class="n">lon_180</span> <span class="o">=</span> <span class="p">((</span><span class="n">lon_wrapped</span> <span class="o">+</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.0</span>  <span class="c1"># -&gt; (-180, 180]</span>
            <span class="c1"># Prefer [-180, 180) by mapping exactly 180 to -180</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon_180</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
                <span class="n">lon_180</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lon_180</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">eps</span><span class="p">),</span> <span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="n">lon_180</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lon_180</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lon_180</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">eps</span><span class="p">),</span> <span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="n">lon_180</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lon_180</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;to must be &#39;0-360&#39; or &#39;-180-180&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeaIceGridWork.reapply_landmask">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.reapply_landmask">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reapply_landmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DS</span><span class="p">,</span> <span class="n">apply_unmodified</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Apply landmask to all spatial variables in the dataset.</span>

<span class="sd">        Uses the modified bathymetry (`kmt_mod`) field from the model grid to mask out land cells.</span>
<span class="sd">        Applies this mask to all variables with dimensions `(&quot;nj&quot;, &quot;ni&quot;)`, ensuring that land areas</span>
<span class="sd">        are excluded from any subsequent analysis or output.</span>

<span class="sd">        INPUTS:</span>
<span class="sd">           DS : xarray.Dataset; Dataset containing sea ice fields to be masked.</span>

<span class="sd">        OUTPUTS:</span>
<span class="sd">           xarray.Dataset; Same dataset with land cells set to NaN for spatial variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">apply_unmodified</span><span class="p">:</span>
            <span class="n">kmt_mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P_KMT_mod</span><span class="p">)[</span><span class="s1">&#39;kmt&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kmt_mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P_KMT_org</span><span class="p">)[</span><span class="s1">&#39;kmt&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">DS</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">DS</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">{</span><span class="s2">&quot;nj&quot;</span><span class="p">,</span> <span class="s2">&quot;ni&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>  <span class="c1"># Only apply to spatial fields</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Masking land for variable: </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">DS</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">kmt_mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applied landmask to rolled dataset&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DS</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_circular_mean_lon_deg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">lon_deg_arrays</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Circular mean for longitudes in degrees. Inputs must be broadcastable to same shape.</span>
<span class="sd">        Returns degrees in [0, 360).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">lon_deg_arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># (n, ...)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;0-360&quot;</span><span class="p">)</span>
        <span class="n">lonr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lonr</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lonr</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;0-360&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SeaIceGridWork.build_grid_faces">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.build_grid_faces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_grid_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">source_in_radians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build C-grid geometry from *cell-centre* lon/lat arrays.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon, lat : array-like</span>
<span class="sd">            2D arrays of cell-centre lon/lat, either in degrees or radians.</span>
<span class="sd">            Shape (nj, ni).</span>
<span class="sd">        source_in_radians : bool</span>
<span class="sd">            If True, lon/lat are radians and will be converted to degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lon_b, lat_b : ndarray</span>
<span class="sd">            Corner coordinates, shape (nj+1, ni+1)</span>
<span class="sd">        lon_e, lat_e : ndarray</span>
<span class="sd">            Vertical face centres (E/W faces), shape (nj, ni+1)</span>
<span class="sd">            (dims can be interpreted as (nj, ni_b))</span>
<span class="sd">        lon_n, lat_n : ndarray</span>
<span class="sd">            Horizontal face centres (N/S faces), shape (nj+1, ni)</span>
<span class="sd">            (dims can be interpreted as (nj_b, ni))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">source_in_radians</span><span class="p">:</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;0-360&quot;</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>

        <span class="n">nj</span><span class="p">,</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># --- corners (nj+1, ni+1)</span>
        <span class="n">lon_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">lat_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Interior corners: mean of surrounding 4 cell centres</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">lat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_mean_lon_deg</span><span class="p">(</span><span class="n">lon</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lon</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># Edges: mean of adjacent 2 cell centres (more consistent than copying)</span>
        <span class="c1"># top edge (j=0): between cells (0, i-1) and (0, i)</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_mean_lon_deg</span><span class="p">(</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># bottom edge (j=nj): between cells (nj-1, i-1) and (nj-1, i)</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_mean_lon_deg</span><span class="p">(</span><span class="n">lon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># left edge (i=0): between cells (j-1,0) and (j,0)</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_mean_lon_deg</span><span class="p">(</span><span class="n">lon</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># right edge (i=ni): between cells (j-1,ni-1) and (j,ni-1)</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_mean_lon_deg</span><span class="p">(</span><span class="n">lon</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Four outer corners: nearest cell centre</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">lon_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">lon_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon_b</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;0-360&quot;</span><span class="p">)</span>

        <span class="c1"># --- face centres from corners</span>
        <span class="c1"># Vertical faces (E/W): average corners above/below along a vertical edge</span>
        <span class="c1"># shape (nj, ni+1) = (nj, ni_b)</span>
        <span class="n">lat_e</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lat_b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">lat_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
        <span class="n">lon_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_mean_lon_deg</span><span class="p">(</span><span class="n">lon_b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lon_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>

        <span class="c1"># Horizontal faces (N/S): average corners left/right along a horizontal edge</span>
        <span class="c1"># shape (nj+1, ni) = (nj_b, ni)</span>
        <span class="n">lat_n</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lat_b</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat_b</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="n">lon_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_mean_lon_deg</span><span class="p">(</span><span class="n">lon_b</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lon_b</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>

        <span class="k">return</span> <span class="n">lon_b</span><span class="p">,</span> <span class="n">lat_b</span><span class="p">,</span> <span class="n">lon_e</span><span class="p">,</span> <span class="n">lat_e</span><span class="p">,</span> <span class="n">lon_n</span><span class="p">,</span> <span class="n">lat_n</span></div>



<div class="viewcode-block" id="SeaIceGridWork.build_grid_corners">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.build_grid_corners">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_grid_corners</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_rads</span><span class="p">,</span> <span class="n">lon_rads</span><span class="p">,</span> <span class="n">grid_res</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">source_in_radians</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">source_in_radians</span><span class="p">:</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">lon_rads</span><span class="p">)</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">lat_rads</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">lon_rads</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">lat_rads</span>
        <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span>               <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">lat_b</span>                <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">lon_b</span>                <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="o">=</span> <span class="n">grid_res</span> <span class="o">*</span> <span class="p">(</span><span class="n">lat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="o">=</span> <span class="n">grid_res</span> <span class="o">*</span> <span class="p">(</span><span class="n">lon</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lon</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="n">lat_b</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lon_b</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>          <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>         <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>         <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lat_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>        <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>          <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>         <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>         <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lon_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>        <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lon_b</span>                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon_b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lon_b</span><span class="p">,</span> <span class="n">lat_b</span></div>


<div class="viewcode-block" id="SeaIceGridWork.load_cice_grid">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.load_cice_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_cice_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_hem</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_faces</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unified grid loader.</span>

<span class="sd">        Sets class attributes (no return):</span>
<span class="sd">        - self.G_t : t-grid dataset (centres + corners, mask, angle, area)</span>
<span class="sd">        - self.G_u : legacy u-grid dataset (centres + corners, mask, angle, area)</span>
<span class="sd">        - self.G_e : C-grid vertical-face coords derived from t-grid corners (lon_e/lat_e)</span>
<span class="sd">        - self.G_n : C-grid horizontal-face coords derived from t-grid corners (lon_n/lat_n)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        slice_hem : bool</span>
<span class="sd">            If True, applies self.slice_hemisphere() to all constructed grid datasets.</span>
<span class="sd">        build_faces : bool</span>
<span class="sd">            If True, compute C-grid face coordinate datasets (G_e, G_n).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;CICE grid previously loaded ... returning&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">nat_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;spatial_dims&quot;</span><span class="p">]</span>      <span class="c1"># e.g. (&quot;nj&quot;,&quot;ni&quot;)</span>
        <span class="n">ext_dim</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">_b&quot;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nat_dim</span><span class="p">)</span>    <span class="c1"># e.g. (&quot;nj_b&quot;,&quot;ni_b&quot;)</span>
        <span class="k">with</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="p">[</span><span class="s2">&quot;P_G&quot;</span><span class="p">])</span> <span class="k">as</span> <span class="n">G</span><span class="p">:</span>
            <span class="c1"># land masks</span>
            <span class="n">kmt_org</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P_KMT_org</span><span class="p">)</span><span class="o">.</span><span class="n">kmt</span><span class="o">.</span><span class="n">data</span>
            <span class="n">kmt_mod</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P_KMT_mod</span><span class="p">)</span><span class="o">.</span><span class="n">kmt</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gi</span> <span class="k">else</span> <span class="n">kmt_org</span>
            <span class="c1"># --- T grid (centres)</span>
            <span class="n">TLAT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="s2">&quot;tlat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">TLON</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="s2">&quot;tlon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;0-360&quot;</span><span class="p">)</span>
            <span class="n">TAREA</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="s2">&quot;tarea&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">T_ANGLE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="s2">&quot;angleT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># corners + faces from t-grid centres</span>
            <span class="n">ULON_b</span><span class="p">,</span> <span class="n">ULAT_b</span><span class="p">,</span> <span class="n">lon_e</span><span class="p">,</span> <span class="n">lat_e</span><span class="p">,</span> <span class="n">lon_n</span><span class="p">,</span> <span class="n">lat_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_grid_faces</span><span class="p">(</span><span class="n">TLON</span><span class="p">,</span> <span class="n">TLAT</span><span class="p">,</span> <span class="n">source_in_radians</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># --- U grid (legacy / B-grid velocity points)</span>
            <span class="n">ULAT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="s2">&quot;ulat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">ULON</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="s2">&quot;ulon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;0-360&quot;</span><span class="p">)</span>
            <span class="n">UAREA</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="s2">&quot;uarea&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">U_ANGLE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radians_to_degrees</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="s2">&quot;angle&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># dims</span>
        <span class="n">nj</span><span class="p">,</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">TLAT</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">coords_nat</span> <span class="o">=</span> <span class="p">{</span><span class="n">nat_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nj</span><span class="p">),</span>
                      <span class="n">nat_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ni</span><span class="p">)}</span>
        <span class="n">coords_ext</span> <span class="o">=</span> <span class="p">{</span><span class="n">nat_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nj</span><span class="p">),</span>
                      <span class="n">nat_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ni</span><span class="p">),</span>
                      <span class="n">ext_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                      <span class="n">ext_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="c1"># landmasks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kmt_org</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;kmt_org&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">kmt_org</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span>    <span class="p">:</span> <span class="s2">&quot;binary&quot;</span><span class="p">,</span> 
                                                                              <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;original landmask on t-grid&quot;</span><span class="p">})},</span>
                                  <span class="n">coords</span>    <span class="o">=</span> <span class="n">coords_nat</span><span class="p">)</span>
        <span class="c1"># Grounded icebergs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gi</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kmt_mod</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;kmt_mod&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">kmt_mod</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span>    <span class="p">:</span> <span class="s2">&quot;binary&quot;</span><span class="p">,</span> 
                                                                                <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;modified landmask on t-grid (grounded icebergs)&quot;</span><span class="p">})},</span>
                                    <span class="n">coords</span>    <span class="o">=</span> <span class="n">coords_nat</span><span class="p">)</span>
            <span class="c1"># Difference: grounded icebergs are cells that changed from ocean (1) to land (0)</span>
            <span class="n">GI_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">kmt_org</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">kmt_mod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># 2-D fields with same shape as GI_mask (NaN outside GI)</span>
            <span class="n">GI_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">GI_mask</span><span class="p">,</span> <span class="n">TAREA</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">GI_lat</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">GI_mask</span><span class="p">,</span> <span class="n">TLAT</span><span class="p">,</span>  <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">GI_lon</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">GI_mask</span><span class="p">,</span> <span class="n">TLON</span><span class="p">,</span>  <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;mask&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">GI_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;binary&quot;</span><span class="p">,</span>
                                                                                          <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;grounded iceberg mask on t-grid&quot;</span><span class="p">}),</span>
                                              <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">GI_area</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;m2&quot;</span><span class="p">,</span>
                                                                          <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;t-cell area at grounded iceberg locations (NaN elsewhere)&quot;</span><span class="p">}),</span>
                                              <span class="s2">&quot;lat&quot;</span><span class="p">:</span>  <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">GI_lat</span><span class="p">,</span>  <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees_north&quot;</span><span class="p">,</span>
                                                                          <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;latitude at grounded iceberg locations (NaN elsewhere)&quot;</span><span class="p">}),</span>
                                              <span class="s2">&quot;lon&quot;</span><span class="p">:</span>  <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">GI_lon</span><span class="p">,</span>  <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees_east&quot;</span><span class="p">,</span>
                                                                          <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;longitude at grounded iceberg locations (NaN elsewhere)&quot;</span><span class="p">})},</span>
                                   <span class="n">coords</span> <span class="o">=</span> <span class="n">coords_nat</span><span class="p">)</span>
            <span class="c1"># Get coordinates of affected cells (shifted west by one ni index to match B-grid layout)</span>
            <span class="n">nj_idx</span><span class="p">,</span> <span class="n">ni_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">GI_mask</span><span class="p">)</span>
            <span class="n">ni_idx_shifted</span> <span class="o">=</span> <span class="n">ni_idx</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">valid</span>          <span class="o">=</span> <span class="n">ni_idx_shifted</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">nj_idx</span>         <span class="o">=</span> <span class="n">nj_idx</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
            <span class="n">ni_idx</span>         <span class="o">=</span> <span class="n">ni_idx_shifted</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
            <span class="c1"># Save 1D arrays with iceberg IDs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">nGI</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nj_idx</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span><span class="p">[</span><span class="s2">&quot;area_nGI&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;nGI&quot;</span><span class="p">,),</span> <span class="n">TAREA</span><span class="p">[</span><span class="n">nj_idx</span><span class="p">,</span> <span class="n">ni_idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span><span class="p">[</span><span class="s2">&quot;lat_nGI&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;nGI&quot;</span><span class="p">,),</span> <span class="n">TLAT</span><span class="p">[</span><span class="n">nj_idx</span><span class="p">,</span> <span class="n">ni_idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span><span class="p">[</span><span class="s2">&quot;lon_nGI&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;nGI&quot;</span><span class="p">,),</span> <span class="n">TLON</span><span class="p">[</span><span class="n">nj_idx</span><span class="p">,</span> <span class="n">ni_idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span><span class="p">[</span><span class="s2">&quot;area_nGI&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;m2&quot;</span><span class="p">,</span> <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;t-cell area (1D list) at GI cells&quot;</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span><span class="p">[</span><span class="s2">&quot;lat_nGI&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees_north&quot;</span><span class="p">,</span> <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;GI latitude (1D list)&quot;</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span><span class="p">[</span><span class="s2">&quot;lon_nGI&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees_east&quot;</span><span class="p">,</span>  <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;GI longitude (1D list)&quot;</span><span class="p">})</span>
        <span class="c1"># --- build datasets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lat&quot;</span>    <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">TLAT</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                           <span class="s2">&quot;lon&quot;</span>    <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">TLON</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                           <span class="s2">&quot;angle&quot;</span>  <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">T_ANGLE</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                           <span class="s2">&quot;area&quot;</span>   <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">TAREA</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;m^2&quot;</span><span class="p">})},</span>
                            <span class="n">coords</span>    <span class="o">=</span> <span class="n">coords_nat</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G_u</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lat&quot;</span>    <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">ULAT</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                           <span class="s2">&quot;lon&quot;</span>    <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">ULON</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                           <span class="s2">&quot;lat_b&quot;</span>  <span class="p">:</span> <span class="p">(</span><span class="n">ext_dim</span><span class="p">,</span> <span class="n">ULAT_b</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                           <span class="s2">&quot;lon_b&quot;</span>  <span class="p">:</span> <span class="p">(</span><span class="n">ext_dim</span><span class="p">,</span> <span class="n">ULON_b</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                           <span class="s2">&quot;angle&quot;</span>  <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">U_ANGLE</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                           <span class="s2">&quot;area&quot;</span>   <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">UAREA</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;m^2&quot;</span><span class="p">})},</span>
                            <span class="n">coords</span>    <span class="o">=</span> <span class="n">coords_ext</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">build_faces</span><span class="p">:</span>
            <span class="c1"># Use ext_dim/nat_dim naming so shapes are explicit:</span>
            <span class="c1"># lon_e/lat_e: (nj, ni_b) == (nat_dim[0], ext_dim[1])</span>
            <span class="c1"># lon_n/lat_n: (nj_b, ni) == (ext_dim[0], nat_dim[1])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_e</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">nat_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ext_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">lat_e</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                               <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">nat_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ext_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">lon_e</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">})},</span>
                                  <span class="n">coords</span>    <span class="o">=</span> <span class="n">coords_ext</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_n</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">ext_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nat_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">lat_n</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">}),</span>
                                               <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">ext_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nat_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">lon_n</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;degrees&quot;</span><span class="p">})},</span>
                                  <span class="n">coords</span>    <span class="o">=</span> <span class="n">coords_ext</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_e</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">slice_hem</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_u</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_e</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_n</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gi</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_GI&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_GI</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kmt_org&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kmt_org</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kmt_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kmt_org</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gi</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kmt_mod&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kmt_mod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kmt_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_hemisphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kmt_mod</span><span class="p">)</span>
        <span class="c1"># flags for downstream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bgrid_loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cgrid_loaded</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">build_faces</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_loaded</span>  <span class="o">=</span> <span class="kc">True</span></div>

        
<div class="viewcode-block" id="SeaIceGridWork.compute_regular_grid_area">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.compute_regular_grid_area">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_regular_grid_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute cell areas (km^2) for a regular lat/lon grid (1D coords).</span>

<span class="sd">        Assumes 1D, monotonically increasing latitude and longitude coordinates with</span>
<span class="sd">        uniform longitudinal spacing. Uses spherical geometry to integrate the area</span>
<span class="sd">        between latitude edges for each latitude band, broadcasting across longitudes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        da : xr.DataArray</span>
<span class="sd">            Any DataArray that carries 1D coordinates named ``&#39;lat&#39;`` and ``&#39;lon&#39;``.</span>
<span class="sd">            Values are not used; only the coordinates are read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.DataArray</span>
<span class="sd">            2D area array with dims (``lat``, ``lon``) in **km**, aligned to the</span>
<span class="sd">            provided coordinate vectors.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Earth radius is fixed at 6,371,000 m.</span>
<span class="sd">        - For non-uniform lon spacing or curvilinear grids, use model grid areas</span>
<span class="sd">        (e.g., CICE `tarea`) rather than this helper.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span>   <span class="o">=</span> <span class="mf">6371000.0</span>  <span class="c1"># Earth radius in meters</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># Latitude edges</span>
        <span class="n">lat_edges</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lat_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">lat_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">lat_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1"># Longitude spacing</span>
        <span class="n">dlon</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 1D cell area per latitude</span>
        <span class="n">dA_lat</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">dlon</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># Broadcast to 2D</span>
        <span class="n">area_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">dA_lat</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)))</span>
        <span class="c1"># Convert to km^2</span>
        <span class="n">area_2d</span> <span class="o">/=</span> <span class="mf">1e6</span>
        <span class="n">area_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">area_2d</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span><span class="s2">&quot;lon&quot;</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;lat&quot;</span><span class="p">:</span><span class="n">da</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">],</span> <span class="s2">&quot;lon&quot;</span><span class="p">:</span><span class="n">da</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]})</span>
        <span class="k">return</span> <span class="n">area_da</span></div>

    
    <span class="c1">######################################################################</span>
    <span class="c1">#                           FORM FACTORS                             #</span>
    <span class="c1">######################################################################</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_infer_deg_from_grid_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;var&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer whether an angular array is in radians and convert to degrees if so.</span>

<span class="sd">        This helper applies a simple magnitude heuristic to distinguish radians from</span>
<span class="sd">        degrees for grid longitude/latitude/angle fields. If the maximum absolute</span>
<span class="sd">        finite value is approximately within 2, the input is treated as radians and</span>
<span class="sd">        converted to degrees; otherwise it is returned unchanged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arr : array-like</span>
<span class="sd">            Input values representing an angular quantity (e.g., lon, lat).</span>
<span class="sd">        name : str, default=&quot;var&quot;</span>
<span class="sd">            Variable name used for logging/debug context (no logging performed here,</span>
<span class="sd">            but retained for consistency and future use).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : numpy.ndarray</span>
<span class="sd">            Array of dtype float64. If inferred radians, returned in degrees; else</span>
<span class="sd">            returned in original units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">finite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">finite</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">finite</span><span class="p">]))</span>
        <span class="c1"># Heuristic: radians for lon/lat/angle typically within ~2*pi</span>
        <span class="k">if</span> <span class="n">amax</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_to_meters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">units_attr</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a length-like array to meters using units metadata when available.</span>

<span class="sd">        Supported explicit units are centimeters (&quot;cm&quot;) and meters (&quot;m&quot;). If units are</span>
<span class="sd">        missing/unknown, a magnitude heuristic is used:</span>
<span class="sd">        - median &gt; 1e3  : assume meters</span>
<span class="sd">        - median &gt; 10   : ambiguous; assume meters and emit a warning</span>
<span class="sd">        - otherwise     : suspicious; assume meters and emit a warning</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arr : array-like</span>
<span class="sd">            Input length values.</span>
<span class="sd">        units_attr : str or None</span>
<span class="sd">            Units attribute string (e.g., from `DataArray.attrs.get(&quot;units&quot;)`).</span>
<span class="sd">        name : str, default=&quot;&quot;</span>
<span class="sd">            Variable name for warning messages.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : numpy.ndarray</span>
<span class="sd">            Values converted to meters (float64).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The heuristic is intentionally conservative (defaults to meters) because grid</span>
<span class="sd">        metrics for Antarctic climate configurations are typically O(1e4) meters.</span>
<span class="sd">        If your grid uses kilometers or other conventions, supply a correct units</span>
<span class="sd">        attribute to avoid ambiguity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">units_attr</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;centimeter&quot;</span><span class="p">,</span> <span class="s2">&quot;centimeters&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mf">0.01</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;meter&quot;</span><span class="p">,</span> <span class="s2">&quot;meters&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="c1"># fallback heuristic by magnitude (typical dx ~ O(1e4) m for 0.25 near Antarctica)</span>
        <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">med</span> <span class="o">&gt;</span> <span class="mf">1e3</span><span class="p">:</span>   <span class="c1"># likely meters already</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">med</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>    <span class="c1"># ambiguous; could be km or something odd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> units ambiguous (median=</span><span class="si">{</span><span class="n">med</span><span class="si">}</span><span class="s2">); assuming meters.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="c1"># if it&#39;s ~250 (and you expect 25 km), could be km*10? etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> units suspicious (median=</span><span class="si">{</span><span class="n">med</span><span class="si">}</span><span class="s2">); please verify units.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_open_cice_cgrid_for_F2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open a CICE C-grid file and extract geometry required for F2 computations.</span>

<span class="sd">        This routine loads a CICE grid NetCDF and returns:</span>
<span class="sd">        - T-cell center longitude/latitude in degrees</span>
<span class="sd">        - T-cell local grid rotation angle (anglet) in radians</span>
<span class="sd">        - T-cell metric lengths dx, dy in meters</span>

<span class="sd">        Variable names are detected robustly across common naming conventions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        P_grid : str or pathlib.Path, optional</span>
<span class="sd">            Path to the CICE grid file. If None, uses `self.CICE_dict[&quot;P_G&quot;]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tlon_deg : numpy.ndarray</span>
<span class="sd">            T-cell longitude in degrees east, shape (nj, ni).</span>
<span class="sd">        tlat_deg : numpy.ndarray</span>
<span class="sd">            T-cell latitude in degrees north, shape (nj, ni).</span>
<span class="sd">        anglet_rad : numpy.ndarray</span>
<span class="sd">            Local rotation angle of the T-grid in radians, shape (nj, ni). If the</span>
<span class="sd">            source variable appears to be in degrees (max &gt; 2 and &lt;= 360), it is</span>
<span class="sd">            converted to radians.</span>
<span class="sd">        dx_m : numpy.ndarray</span>
<span class="sd">            Grid metric dx in meters, shape (nj, ni).</span>
<span class="sd">        dy_m : numpy.ndarray</span>
<span class="sd">            Grid metric dy in meters, shape (nj, ni).</span>
<span class="sd">        ds : xarray.Dataset</span>
<span class="sd">            Opened dataset handle (caller may close if desired).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `P_grid` is not provided and `self.CICE_dict[&quot;P_G&quot;]` is unset.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If required variables cannot be found in the dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Expected for ACCESS-OM3 C-grid (common case):</span>
<span class="sd">        - tlon, tlat in radians</span>
<span class="sd">        - anglet in radians</span>
<span class="sd">        - hte, htn in centimeters</span>

<span class="sd">        Longitudes are normalised to [-180, 180] to support Antarctic projection</span>
<span class="sd">        transforms and to reduce antimeridian issues.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">P_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">P_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;P_G&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">P_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;P_grid is None and self.CICE_dict[&#39;P_G&#39;] is not set.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Opening CICE grid: </span><span class="si">{</span><span class="n">P_grid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">P_grid</span><span class="p">,</span> <span class="n">decode_times</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># ---- locate vars robustly</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">pick</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">n</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">v_tlon</span> <span class="o">=</span> <span class="n">pick</span><span class="p">(</span><span class="s2">&quot;tlon&quot;</span><span class="p">,</span> <span class="s2">&quot;TLON&quot;</span><span class="p">,</span> <span class="s2">&quot;t_lon&quot;</span><span class="p">,</span> <span class="s2">&quot;lon_t&quot;</span><span class="p">)</span>
        <span class="n">v_tlat</span> <span class="o">=</span> <span class="n">pick</span><span class="p">(</span><span class="s2">&quot;tlat&quot;</span><span class="p">,</span> <span class="s2">&quot;TLAT&quot;</span><span class="p">,</span> <span class="s2">&quot;t_lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lat_t&quot;</span><span class="p">)</span>
        <span class="n">v_angt</span> <span class="o">=</span> <span class="n">pick</span><span class="p">(</span><span class="s2">&quot;anglet&quot;</span><span class="p">,</span> <span class="s2">&quot;angleT&quot;</span><span class="p">,</span> <span class="s2">&quot;ANGLET&quot;</span><span class="p">,</span> <span class="s2">&quot;angle_t&quot;</span><span class="p">)</span>
        <span class="n">v_hte</span>  <span class="o">=</span> <span class="n">pick</span><span class="p">(</span><span class="s2">&quot;hte&quot;</span><span class="p">,</span> <span class="s2">&quot;HTE&quot;</span><span class="p">,</span> <span class="s2">&quot;dxT&quot;</span><span class="p">,</span> <span class="s2">&quot;dxt&quot;</span><span class="p">)</span>
        <span class="n">v_htn</span>  <span class="o">=</span> <span class="n">pick</span><span class="p">(</span><span class="s2">&quot;htn&quot;</span><span class="p">,</span> <span class="s2">&quot;HTN&quot;</span><span class="p">,</span> <span class="s2">&quot;dyT&quot;</span><span class="p">,</span> <span class="s2">&quot;dyt&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">nm</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">v_tlon</span><span class="p">,</span> <span class="s2">&quot;tlon&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">v_tlat</span><span class="p">,</span> <span class="s2">&quot;tlat&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">v_angt</span><span class="p">,</span> <span class="s2">&quot;anglet&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">v_hte</span><span class="p">,</span> <span class="s2">&quot;hte&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">v_htn</span><span class="p">,</span> <span class="s2">&quot;htn&quot;</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find required grid variable &#39;</span><span class="si">{</span><span class="n">nm</span><span class="si">}</span><span class="s2">&#39; in </span><span class="si">{</span><span class="n">P_grid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">tlon</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">v_tlon</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">tlat</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">v_tlat</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">angt</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">v_angt</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">hte</span>  <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">v_hte</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">htn</span>  <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">v_htn</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># lon/lat -&gt; degrees, anglet stays radians</span>
        <span class="n">tlon_deg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_deg_from_grid_units</span><span class="p">(</span><span class="n">tlon</span><span class="p">,</span> <span class="s2">&quot;tlon&quot;</span><span class="p">)</span>
        <span class="n">tlat_deg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_deg_from_grid_units</span><span class="p">(</span><span class="n">tlat</span><span class="p">,</span> <span class="s2">&quot;tlat&quot;</span><span class="p">)</span>
        <span class="c1"># ensure lon is suitable for Antarctic projection transforms</span>
        <span class="n">tlon_deg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">tlon_deg</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;-180-180&quot;</span><span class="p">)</span>
        <span class="c1"># anglet: if it looks like degrees, convert to rad</span>
        <span class="n">angt_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">angt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">finite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">angt_arr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finite</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">angt_arr</span><span class="p">[</span><span class="n">finite</span><span class="p">]))</span>
            <span class="c1"># if looks like degrees (e.g. up to ~180), assume degrees</span>
            <span class="k">if</span> <span class="n">amax</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="ow">and</span> <span class="n">amax</span> <span class="o">&lt;=</span> <span class="mf">360.0</span><span class="p">:</span>
                <span class="n">anglet_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angt_arr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">anglet_rad</span> <span class="o">=</span> <span class="n">angt_arr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">anglet_rad</span> <span class="o">=</span> <span class="n">angt_arr</span>
        <span class="c1"># hte/htn expected in cm -&gt; m</span>
        <span class="n">dx_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_meters</span><span class="p">(</span><span class="n">hte</span><span class="p">,</span> <span class="n">ds</span><span class="p">[</span><span class="n">v_hte</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;units&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">v_hte</span><span class="p">)</span>
        <span class="n">dy_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_meters</span><span class="p">(</span><span class="n">htn</span><span class="p">,</span> <span class="n">ds</span><span class="p">[</span><span class="n">v_htn</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;units&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">v_htn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tlon_deg</span><span class="p">,</span> <span class="n">tlat_deg</span><span class="p">,</span> <span class="n">anglet_rad</span><span class="p">,</span> <span class="n">dx_m</span><span class="p">,</span> <span class="n">dy_m</span><span class="p">,</span> <span class="n">ds</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_iter_exterior_rings_lonlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P_shp</span><span class="p">,</span>
                                    <span class="n">target_crs</span>    <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
                                    <span class="n">keep_surfaces</span> <span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;land&quot;</span><span class="p">,</span> <span class="s2">&quot;ice shelf&quot;</span><span class="p">,</span> <span class="s2">&quot;ice tongue&quot;</span><span class="p">,</span> <span class="s2">&quot;rumple&quot;</span><span class="p">),</span>
                                    <span class="n">dissolve</span>      <span class="p">:</span> <span class="nb">bool</span>  <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="c1"># robustness knobs</span>
                                    <span class="n">fix_invalid</span>   <span class="p">:</span> <span class="nb">bool</span>  <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">union_batch</span>   <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                                    <span class="n">precision_m</span>   <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   <span class="c1"># e.g. 1.0 or 5.0 meters; None disables snapping</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stream exterior polygon rings from a coastline/landmask file as lon/lat arrays.</span>

<span class="sd">        The shapefile (or any vector dataset readable by GeoPandas) is read, filtered</span>
<span class="sd">        to polygonal geometries, optionally filtered by a `surface` attribute, and</span>
<span class="sd">        optionally dissolved (unioned) in the native CRS to remove internal boundaries</span>
<span class="sd">        (e.g., grounding-line edges between land and ice shelf polygons). Each returned</span>
<span class="sd">        ring is the exterior boundary of a Polygon in the requested CRS.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        P_shp : str or pathlib.Path</span>
<span class="sd">            Input polygon dataset (e.g., Antarctic coastline/landmask) typically in</span>
<span class="sd">            EPSG:3031.</span>
<span class="sd">        target_crs : str, default=&quot;EPSG:4326&quot;</span>
<span class="sd">            CRS for returned coordinates. EPSG:4326 returns lon/lat degrees.</span>
<span class="sd">        keep_surfaces : tuple of str, default=(&quot;land&quot;,&quot;ice shelf&quot;,&quot;ice tongue&quot;,&quot;rumple&quot;)</span>
<span class="sd">            If a `surface` column exists, only these classes are retained. If None,</span>
<span class="sd">            no filtering is applied.</span>
<span class="sd">        dissolve : bool, default=True</span>
<span class="sd">            If True, union all retained polygons in the native CRS before reprojecting,</span>
<span class="sd">            which removes interior boundaries and yields a cleaner coastline.</span>
<span class="sd">        fix_invalid : bool, default=True</span>
<span class="sd">            Attempt to repair invalid geometries before unioning (via `make_valid` if</span>
<span class="sd">            available, else `buffer(0)`).</span>
<span class="sd">        union_batch : float, default=2000</span>
<span class="sd">            Batch size for union operations. Large datasets can be unioned in chunks</span>
<span class="sd">            to limit memory and improve robustness.</span>
<span class="sd">        precision_m : float, optional</span>
<span class="sd">            If provided and supported by Shapely, snap coordinates to this precision</span>
<span class="sd">            (in meters) before unioning to reduce slivers/spikes. `None` disables</span>
<span class="sd">            snapping.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        lon_deg : numpy.ndarray</span>
<span class="sd">            Exterior ring longitudes in degrees (float64), normalised to [-180, 180].</span>
<span class="sd">        lat_deg : numpy.ndarray</span>
<span class="sd">            Exterior ring latitudes in degrees (float64).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Non-polygonal geometries (lines/points/empties) are ignored.</span>
<span class="sd">        - Dissolving is performed before reprojection to avoid antimeridian and wrap</span>
<span class="sd">        artefacts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span>
        <span class="c1"># shapely 2.x: make_valid + set_precision are available; fall back where needed</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.validation</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_valid</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">make_valid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_precision</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">set_precision</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.ops</span><span class="w"> </span><span class="kn">import</span> <span class="n">unary_union</span>
        <span class="c1"># internal functions</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_polygonal_only</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Keep polygonal parts only; drop empties/lines/points.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># Repair if invalid</span>
            <span class="k">if</span> <span class="n">fix_invalid</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s2">&quot;is_valid&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_valid</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">make_valid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">make_valid</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># classic fallback; fixes many self-intersections</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># make_valid can return GeometryCollection; keep only polygonal components</span>
            <span class="n">gt</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s2">&quot;geom_type&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gt</span> <span class="o">==</span> <span class="s2">&quot;Polygon&quot;</span> <span class="ow">or</span> <span class="n">gt</span> <span class="o">==</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">g</span>
            <span class="k">if</span> <span class="n">gt</span> <span class="o">==</span> <span class="s2">&quot;GeometryCollection&quot;</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s2">&quot;geoms&quot;</span><span class="p">):</span>
                <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">gg</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">gg</span><span class="o">.</span><span class="n">geom_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">):</span>
                        <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">polys</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_apply_precision</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">precision_m</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">set_precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">g</span>
            <span class="c1"># keep_collapsed avoids creating invalid spikes; drop tiny remnants</span>
            <span class="k">return</span> <span class="n">set_precision</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">precision_m</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;keep_collapsed&quot;</span><span class="p">)</span>
        <span class="c1"># ---- read (pyogrio avoids Fiona; you said geopandas works)</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">P_shp</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;pyogrio&quot;</span><span class="p">)</span>
        <span class="c1"># ensure CRS (your file is EPSG:3031)</span>
        <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:3031&quot;</span><span class="p">)</span>
        <span class="c1"># filter by surface classes if present</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;surface&quot;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">keep_surfaces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;surface&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">keep_surfaces</span><span class="p">))]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">geoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">_polygonal_only</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
        <span class="n">geoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">geoms</span> <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_empty</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">geoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># optional snapping (do before union)</span>
        <span class="k">if</span> <span class="n">precision_m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">set_precision</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">_apply_precision</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">geoms</span><span class="p">]</span>
            <span class="n">geoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">geoms</span> <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_empty</span><span class="p">)]</span>
        <span class="c1"># ---- dissolve in native CRS (EPSG:3031) to remove grounding-line internal edges</span>
        <span class="k">if</span> <span class="n">dissolve</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">geoms</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">union_batch</span><span class="p">)):</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">geoms</span><span class="p">[</span><span class="n">k</span> <span class="p">:</span> <span class="n">k</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">union_batch</span><span class="p">)]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">chunk</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unary_union</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># last-chance: buffer(0) on the chunk then union</span>
                    <span class="n">chunk2</span> <span class="o">=</span> <span class="p">[</span><span class="n">gg</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">gg</span> <span class="ow">in</span> <span class="n">chunk</span><span class="p">]</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unary_union</span><span class="p">(</span><span class="n">chunk2</span><span class="p">))</span>
            <span class="c1"># union the already-unioned parts</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">geom_u</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># last-chance: buffer(0) on parts</span>
                <span class="n">geom_u</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">])</span>

            <span class="n">geom_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">geom_u</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geom_list</span> <span class="o">=</span> <span class="n">geoms</span>
        <span class="c1"># reproject AFTER dissolve (safer + avoids antimeridian / lon wrap weirdness)</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">geom_list</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">target_crs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">gs</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
                <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">geom</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="n">polys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># ignore other types</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span>
                <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
                <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
                <span class="n">lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;-180-180&quot;</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span>
     
    <span class="k">def</span><span class="w"> </span><span class="nf">_infer_ocean_mask_from_grid_ds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer a T-grid wet/ocean mask from a grid dataset using common conventions.</span>

<span class="sd">        The method searches for typical mask variables (e.g., tmask, wet, kmt, tarea)</span>
<span class="sd">        and applies a simple interpretation:</span>
<span class="sd">        - kmt-like variables: ocean where kmt &gt; 0</span>
<span class="sd">        - mask/wet/tarea-like variables: ocean where finite and &gt; 0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ds : xarray.Dataset</span>
<span class="sd">            Grid dataset containing potential mask variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ocean_mask : numpy.ndarray or None</span>
<span class="sd">            Boolean array of shape (nj, ni) where True indicates ocean/wet cells.</span>
<span class="sd">            Returns None if no suitable variable is found.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is heuristic and intended for restricting search domains (e.g., building</span>
<span class="sd">        a KDTree over coastal-ocean cells). If your grid uses a different mask</span>
<span class="sd">        convention, provide an explicit mask or extend the candidate list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># common names across CICE/MOM grids</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tmask&quot;</span><span class="p">,</span> <span class="s2">&quot;TMASK&quot;</span><span class="p">,</span> <span class="s2">&quot;maskT&quot;</span><span class="p">,</span> <span class="s2">&quot;MASKT&quot;</span><span class="p">,</span> <span class="s2">&quot;wet&quot;</span><span class="p">,</span> <span class="s2">&quot;WET&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;kmt&quot;</span><span class="p">,</span> <span class="s2">&quot;KMT&quot;</span><span class="p">,</span> <span class="s2">&quot;kmt_t&quot;</span><span class="p">,</span> <span class="s2">&quot;KMT_T&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;tarea&quot;</span><span class="p">,</span> <span class="s2">&quot;TAREA&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="c1"># heuristic:</span>
                <span class="c1"># - kmt: 0 land, &gt;0 ocean</span>
                <span class="c1"># - masks: 0 land, 1 ocean</span>
                <span class="c1"># - tarea: 0 or NaN on land (not always)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;kmt&quot;</span><span class="p">):</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># treat finite positive as ocean</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="SeaIceGridWork.build_F2_form_factors_from_high_res_coast">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.build_F2_form_factors_from_high_res_coast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_F2_form_factors_from_high_res_coast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                  <span class="n">P_shp</span>                     <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                  <span class="n">P_grid</span>                    <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                  <span class="n">P_out</span>                     <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                  <span class="n">proj_crs</span>                  <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;EPSG:3031&quot;</span><span class="p">,</span>
                                                  <span class="n">chunk_segments</span>            <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2_000_000</span><span class="p">,</span>
                                                  <span class="n">coast_write_stride</span>        <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
                                                  <span class="n">lat_subset_max</span>            <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">30.0</span><span class="p">,</span>
                                                  <span class="n">netcdf_compression</span>        <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
                                                  <span class="n">use_coastal_ocean_kdtree</span>  <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">coast_buffer_cells</span>        <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                                  <span class="n">max_assign_km</span>             <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Liu et al. (2022) coastal form factors (F2x, F2y) on the CICE T-grid</span>
<span class="sd">        from a high-resolution polygon coastline.</span>

<span class="sd">        The cell-based form factors (Liu et al. 2022, Eqs. 910) are computed as:</span>
<span class="sd">            F2x(i,j) = _n | l_n cos(_n) | / dx(i,j)</span>
<span class="sd">            F2y(i,j) = _n | l_n sin(_n) | / dy(i,j)</span>

<span class="sd">        where each coastline segment n has geodesic length l_n (WGS84) and bearing</span>
<span class="sd">        projected into the local model axes using:</span>
<span class="sd">            _n = _n - anglet(i,j),</span>
<span class="sd">        with _n the segment angle in Earth-referenced east-north coordinates and</span>
<span class="sd">        anglet the local model grid rotation (radians).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        P_shp : str, optional</span>
<span class="sd">            Path to the high-resolution coastline/land polygons. If None, uses</span>
<span class="sd">            `self.CICE_dict[&quot;P_high_res_coast&quot;]`.</span>
<span class="sd">        P_grid : str, optional</span>
<span class="sd">            Path to the CICE grid file. If None, uses `self.CICE_dict[&quot;P_G&quot;]`.</span>
<span class="sd">        P_out : str, optional</span>
<span class="sd">            Output NetCDF path. If None, uses `self.CICE_dict[&quot;P_F2_coast&quot;]`.</span>
<span class="sd">        proj_crs : str, default=&quot;EPSG:3031&quot;</span>
<span class="sd">            Projected CRS used to assign each coastline segment midpoint to the</span>
<span class="sd">            nearest T-cell via KDTree (meters).</span>
<span class="sd">        chunk_segments : int, default=2_000_000</span>
<span class="sd">            Process coastline segments in chunks to limit memory use.</span>
<span class="sd">        coast_write_stride : int, default=25</span>
<span class="sd">            Subsampling stride for storing coastline vertices in the output dataset</span>
<span class="sd">            for provenance/plotting. Set &lt;=0 or None to disable.</span>
<span class="sd">        lat_subset_max : float, default=-30.0</span>
<span class="sd">            Only T-cells with latitude &lt;= this threshold are included in the KDTree</span>
<span class="sd">            (a performance and relevance filter for Antarctic use).</span>
<span class="sd">        netcdf_compression : int, default=4</span>
<span class="sd">            NetCDF zlib compression level for output variables.</span>
<span class="sd">        use_coastal_ocean_kdtree : bool, default=True</span>
<span class="sd">            If True and an ocean mask can be inferred from the grid file, restrict the</span>
<span class="sd">            KDTree to ocean cells within `coast_buffer_cells` of land (to avoid</span>
<span class="sd">            mapping segments to interior ice-shelf/grounding-line regions).</span>
<span class="sd">        coast_buffer_cells : int, default=1</span>
<span class="sd">            Buffer (in grid cells) used to define the coastal-ocean band via binary</span>
<span class="sd">            dilation of the land mask.</span>
<span class="sd">        max_assign_km : float, default=50.0</span>
<span class="sd">            Reject segment-to-cell assignments whose KDTree distance exceeds this</span>
<span class="sd">            threshold (in km). Use None to disable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds_out : xarray.Dataset</span>
<span class="sd">            Dataset containing:</span>
<span class="sd">            - F2x(nj,ni), F2y(nj,ni) : float32, unitless</span>
<span class="sd">            - lon(ncoast), lat(ncoast) : thinned coastline vertices (float32)</span>
<span class="sd">            with provenance attributes describing inputs and settings.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If required paths are not provided via arguments or configuration.</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If no grid cells satisfy the latitude subset filter (likely units issue).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This computes the *cell-based* integrals (Liu f2^u and f2^v). Conversion to</span>
<span class="sd">        C-grid u/v points (Liu Eqs. 1112) is intentionally deferred (e.g., Fortran).</span>
<span class="sd">        - Segment lengths and azimuths are computed geodesically on WGS84 (pyproj.Geod).</span>
<span class="sd">        - Nearest-cell assignment uses segment midpoints in the projected CRS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">P_shp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">P_shp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;P_high_res_coast&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">P_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">P_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;P_F2_coast&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">P_shp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;P_shp is None and self.CICE_dict[&#39;P_high_res_coast&#39;] is not set.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">P_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;P_out is None and self.CICE_dict[&#39;P_F2_coast&#39;] is not set.&quot;</span><span class="p">)</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyproj</span><span class="w"> </span><span class="kn">import</span> <span class="n">CRS</span><span class="p">,</span> <span class="n">Transformer</span><span class="p">,</span> <span class="n">Geod</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">cKDTree</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_dilation</span>
        <span class="n">tlon_deg</span><span class="p">,</span> <span class="n">tlat_deg</span><span class="p">,</span> <span class="n">anglet_rad</span><span class="p">,</span> <span class="n">dx_m</span><span class="p">,</span> <span class="n">dy_m</span><span class="p">,</span> <span class="n">ds_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open_cice_cgrid_for_F2</span><span class="p">(</span><span class="n">P_grid</span><span class="o">=</span><span class="n">P_grid</span><span class="p">)</span>
        <span class="n">nj</span><span class="p">,</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">tlon_deg</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">ncell</span> <span class="o">=</span> <span class="n">nj</span> <span class="o">*</span> <span class="n">ni</span>
        <span class="c1"># Base lat subset</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">tlat_deg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tlat_deg</span> <span class="o">&lt;=</span> <span class="n">lat_subset_max</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No grid cells found with tlat &lt;= </span><span class="si">{</span><span class="n">lat_subset_max</span><span class="si">}</span><span class="s2">. Check grid/units.&quot;</span><span class="p">)</span>
        <span class="c1"># Optional: restrict KDTree to *coastal-ocean* cells to exclude grounding line</span>
        <span class="k">if</span> <span class="n">use_coastal_ocean_kdtree</span><span class="p">:</span>
            <span class="n">ocean_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_ocean_mask_from_grid_ds</span><span class="p">(</span><span class="n">ds_grid</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ocean_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Could not infer ocean mask from grid dataset; falling back to lat-only KDTree.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">land_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">ocean_mask</span>
                <span class="n">coast_ocean</span> <span class="o">=</span> <span class="n">ocean_mask</span> <span class="o">&amp;</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">land_mask</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">coast_buffer_cells</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">coast_ocean</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">coast_ocean</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;KDTree restricted to coastal-ocean cells: buffer_cells=</span><span class="si">{</span><span class="n">coast_buffer_cells</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;kept=</span><span class="si">{</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> cells&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Coastal-ocean mask is empty; falling back to lat-only KDTree.&quot;</span><span class="p">)</span>
        <span class="n">flat_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="n">sub_flat</span> <span class="o">=</span> <span class="n">flat_idx</span><span class="p">[</span><span class="n">mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
        <span class="c1"># Project T-cell centers for KDTree</span>
        <span class="n">tfm_to_proj</span> <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span><span class="n">CRS</span><span class="o">.</span><span class="n">from_epsg</span><span class="p">(</span><span class="mi">4326</span><span class="p">),</span> <span class="n">CRS</span><span class="o">.</span><span class="n">from_user_input</span><span class="p">(</span><span class="n">proj_crs</span><span class="p">),</span> <span class="n">always_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x_sub</span><span class="p">,</span> <span class="n">y_sub</span> <span class="o">=</span> <span class="n">tfm_to_proj</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">tlon_deg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">sub_flat</span><span class="p">],</span> <span class="n">tlat_deg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">sub_flat</span><span class="p">])</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x_sub</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y_sub</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Building KDTree on </span><span class="si">{</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> T-cells (masked).&quot;</span><span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
        <span class="c1"># Accumulators</span>
        <span class="n">Sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">Sy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="c1"># Geodesic for segment length/azimuth</span>
        <span class="n">geod</span> <span class="o">=</span> <span class="n">Geod</span><span class="p">(</span><span class="n">ellps</span><span class="o">=</span><span class="s2">&quot;WGS84&quot;</span><span class="p">)</span>
        <span class="c1"># For output coastline provenance (thin vertices)</span>
        <span class="n">coast_lon_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coast_lat_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Streaming coastline rings from: </span><span class="si">{</span><span class="n">P_shp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ring_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">seg_total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">lon_ring</span><span class="p">,</span> <span class="n">lat_ring</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_exterior_rings_lonlat</span><span class="p">(</span><span class="n">P_shp</span><span class="p">):</span>
            <span class="n">ring_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># store thinned vertices for output</span>
            <span class="k">if</span> <span class="n">coast_write_stride</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coast_write_stride</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">coast_lon_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lon_ring</span><span class="p">[::</span><span class="n">coast_write_stride</span><span class="p">])</span>
                <span class="n">coast_lat_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lat_ring</span><span class="p">[::</span><span class="n">coast_write_stride</span><span class="p">])</span>
                <span class="c1"># separator</span>
                <span class="n">coast_lon_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">))</span>
                <span class="n">coast_lat_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">))</span>
            <span class="c1"># segments from consecutive vertices</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon_ring</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">lon0_all</span> <span class="o">=</span> <span class="n">lon_ring</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lat0_all</span> <span class="o">=</span> <span class="n">lat_ring</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lon1_all</span> <span class="o">=</span> <span class="n">lon_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">lat1_all</span> <span class="o">=</span> <span class="n">lat_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">nseg</span>     <span class="o">=</span> <span class="n">lon0_all</span><span class="o">.</span><span class="n">size</span>
            <span class="k">if</span> <span class="n">nseg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># chunk over segments for memory safety</span>
            <span class="k">for</span> <span class="n">s0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nseg</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">chunk_segments</span><span class="p">)):</span>
                <span class="n">s1</span>   <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nseg</span><span class="p">,</span> <span class="n">s0</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">chunk_segments</span><span class="p">))</span>
                <span class="n">lon0</span> <span class="o">=</span> <span class="n">lon0_all</span><span class="p">[</span><span class="n">s0</span><span class="p">:</span><span class="n">s1</span><span class="p">]</span>
                <span class="n">lat0</span> <span class="o">=</span> <span class="n">lat0_all</span><span class="p">[</span><span class="n">s0</span><span class="p">:</span><span class="n">s1</span><span class="p">]</span>
                <span class="n">lon1</span> <span class="o">=</span> <span class="n">lon1_all</span><span class="p">[</span><span class="n">s0</span><span class="p">:</span><span class="n">s1</span><span class="p">]</span>
                <span class="n">lat1</span> <span class="o">=</span> <span class="n">lat1_all</span><span class="p">[</span><span class="n">s0</span><span class="p">:</span><span class="n">s1</span><span class="p">]</span>
                <span class="c1"># geodesic azimuth (deg from north) and length (m)</span>
                <span class="n">az12</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dist_m</span> <span class="o">=</span> <span class="n">geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lon0</span><span class="p">,</span> <span class="n">lat0</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">)</span>
                <span class="n">dist_m</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dist_m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
                <span class="c1"># drop zero/NaN segments</span>
                <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist_m</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist_m</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">az12</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">good</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">continue</span>
                <span class="n">lon0</span>   <span class="o">=</span> <span class="n">lon0</span><span class="p">[</span><span class="n">good</span><span class="p">];</span> <span class="n">lat0</span> <span class="o">=</span> <span class="n">lat0</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
                <span class="n">lon1</span>   <span class="o">=</span> <span class="n">lon1</span><span class="p">[</span><span class="n">good</span><span class="p">];</span> <span class="n">lat1</span> <span class="o">=</span> <span class="n">lat1</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
                <span class="n">az12</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">az12</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)[</span><span class="n">good</span><span class="p">]</span>
                <span class="n">dist_m</span> <span class="o">=</span> <span class="n">dist_m</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
                <span class="c1"># midpoint in projected CRS for nearest-cell assignment</span>
                <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span>    <span class="o">=</span> <span class="n">tfm_to_proj</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lon0</span><span class="p">,</span> <span class="n">lat0</span><span class="p">)</span>
                <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span>    <span class="o">=</span> <span class="n">tfm_to_proj</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">)</span>
                <span class="n">xm</span>        <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">))</span>
                <span class="n">ym</span>        <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">))</span>
                <span class="n">dist_nn</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xm</span><span class="p">,</span> <span class="n">ym</span><span class="p">]),</span> <span class="n">workers</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ring_count</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">s0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;KDTree mapping distances (m): min=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">dist_nn</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">, &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;p50=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">dist_nn</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">, max=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">dist_nn</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">good_nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist_nn</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">max_assign_km</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">max_assign_km</span><span class="p">):</span>
                    <span class="n">good_nn</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">dist_nn</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_assign_km</span><span class="p">)))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">good_nn</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">continue</span>
                <span class="c1"># apply good_nn to everything</span>
                <span class="n">dist_m</span>    <span class="o">=</span> <span class="n">dist_m</span><span class="p">[</span><span class="n">good_nn</span><span class="p">]</span>
                <span class="n">az12</span>      <span class="o">=</span> <span class="n">az12</span><span class="p">[</span><span class="n">good_nn</span><span class="p">]</span>
                <span class="n">cell_flat</span> <span class="o">=</span> <span class="n">sub_flat</span><span class="p">[</span><span class="n">nn</span><span class="p">[</span><span class="n">good_nn</span><span class="p">]]</span>
                <span class="n">seg_ang_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">az12</span><span class="p">)</span>
                <span class="n">ang_local</span> <span class="o">=</span> <span class="n">anglet_rad</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">cell_flat</span><span class="p">]</span>
                <span class="n">ang_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ang_local</span><span class="p">),</span> <span class="n">ang_local</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">seg_ang_e</span> <span class="o">-</span> <span class="n">ang_local</span>
                <span class="n">sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist_m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
                <span class="n">sy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist_m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">Sx</span><span class="p">,</span> <span class="n">cell_flat</span><span class="p">,</span> <span class="n">sx</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">Sy</span><span class="p">,</span> <span class="n">cell_flat</span><span class="p">,</span> <span class="n">sy</span><span class="p">)</span>
                <span class="n">seg_total</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_m</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ring_count</span> <span class="o">%</span> <span class="mi">50</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed </span><span class="si">{</span><span class="n">ring_count</span><span class="si">}</span><span class="s2"> rings; ~</span><span class="si">{</span><span class="n">seg_total</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> segments accumulated so far.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished coastline pass: rings=</span><span class="si">{</span><span class="n">ring_count</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">, segments=</span><span class="si">{</span><span class="n">seg_total</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># create F2x/y arrays </span>
        <span class="n">dx</span>           <span class="o">=</span> <span class="n">dx_m</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">dy</span>           <span class="o">=</span> <span class="n">dy_m</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">good_dx</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">good_dy</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">F2x</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">F2y</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">F2x</span><span class="p">[</span><span class="n">good_dx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sx</span><span class="p">[</span><span class="n">good_dx</span><span class="p">]</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="n">good_dx</span><span class="p">]</span>
        <span class="n">F2y</span><span class="p">[</span><span class="n">good_dy</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sy</span><span class="p">[</span><span class="n">good_dy</span><span class="p">]</span> <span class="o">/</span> <span class="n">dy</span><span class="p">[</span><span class="n">good_dy</span><span class="p">]</span>
        <span class="n">F2x</span>          <span class="o">=</span> <span class="n">F2x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nj</span><span class="p">,</span> <span class="n">ni</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">F2y</span>          <span class="o">=</span> <span class="n">F2y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nj</span><span class="p">,</span> <span class="n">ni</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="c1"># diagnostic</span>
        <span class="c1"># j,i  = np.unravel_index(np.nanargmax(F2x.values), F2x.shape)</span>
        <span class="c1"># Lx_m = float(F2x.values[j,i] * dx_m[j,i])</span>
        <span class="c1"># Ly_m = float(F2y.values[j,i] * dy_m[j,i])</span>
        <span class="c1"># print(j,i, F2x.values[j,i], dx_m[j,i], Lx_m/1000)</span>
        <span class="c1"># coastline output arrays</span>
        <span class="k">if</span> <span class="n">coast_lon_out</span><span class="p">:</span>
            <span class="n">coast_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">coast_lon_out</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">coast_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">coast_lat_out</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coast_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">coast_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">F2x</span> <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;nj&quot;</span><span class="p">,</span> <span class="s2">&quot;ni&quot;</span><span class="p">),</span> <span class="n">F2x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">long_name</span>   <span class="o">=</span> <span class="s2">&quot;Liu et al. (2022) F2 form factor, x-projection (cell-based)&quot;</span><span class="p">,</span>
                                                                          <span class="n">units</span>       <span class="o">=</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                                                                          <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;sum_n |l_n cos(theta_n)| / dx; theta measured relative to local model x-axis&quot;</span><span class="p">)),</span>
                                           <span class="n">F2y</span> <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;nj&quot;</span><span class="p">,</span> <span class="s2">&quot;ni&quot;</span><span class="p">),</span> <span class="n">F2y</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">long_name</span>   <span class="o">=</span> <span class="s2">&quot;Liu et al. (2022) F2 form factor, y-projection (cell-based)&quot;</span><span class="p">,</span>
                                                                          <span class="n">units</span>       <span class="o">=</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                                                                          <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;sum_n |l_n sin(theta_n)| / dy; theta measured relative to local model x-axis&quot;</span><span class="p">)),</span>
                                           <span class="n">lon</span> <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;ncoast&quot;</span><span class="p">,),</span> <span class="n">coast_lon</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">long_name</span> <span class="o">=</span> <span class="s2">&quot;coast longitude&quot;</span><span class="p">,</span>
                                                                               <span class="n">units</span>     <span class="o">=</span> <span class="s2">&quot;degrees_east&quot;</span><span class="p">)),</span>
                                           <span class="n">lat</span> <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;ncoast&quot;</span><span class="p">,),</span> <span class="n">coast_lat</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">long_name</span> <span class="o">=</span> <span class="s2">&quot;coast latitude&quot;</span><span class="p">,</span>
                                                                               <span class="n">units</span>     <span class="o">=</span> <span class="s2">&quot;degrees_north&quot;</span><span class="p">))),</span>
                            <span class="n">coords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ni</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span>
                                          <span class="n">nj</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span>
                                          <span class="n">ncoast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">coast_lon</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)),</span>
                            <span class="n">attrs</span>  <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">title</span>              <span class="o">=</span> <span class="s2">&quot;High-resolution coastline-derived F2 form factors for CICE&quot;</span><span class="p">,</span>
                                          <span class="n">references</span>         <span class="o">=</span> <span class="s2">&quot;Liu et al. (2022) JGR Oceans, doi:10.1029/2022JC018413 (Eqs 9-10)&quot;</span><span class="p">,</span>
                                          <span class="n">coastline_source</span>   <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">P_shp</span><span class="p">),</span>
                                          <span class="n">grid_source</span>        <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">P_grid</span> <span class="k">if</span> <span class="n">P_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;P_G&quot;</span><span class="p">)),</span>
                                          <span class="n">proj_crs</span>           <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">proj_crs</span><span class="p">),</span>
                                          <span class="n">coast_write_stride</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">coast_write_stride</span><span class="p">),</span>
                                          <span class="n">lat_subset_max</span>     <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lat_subset_max</span><span class="p">),</span>
                                          <span class="n">created_by</span>         <span class="o">=</span> <span class="s2">&quot;SeaIceToolbox.SeaIceGridWork.build_F2_form_factors_from_high_res_coast&quot;</span><span class="p">))</span>
        <span class="c1"># write netcdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Writing F2 NetCDF: </span><span class="si">{</span><span class="n">P_out</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">enc</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;F2x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zlib&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;complevel&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">netcdf_compression</span><span class="p">),</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;float32&quot;</span><span class="p">},</span>
               <span class="s2">&quot;F2y&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zlib&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;complevel&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">netcdf_compression</span><span class="p">),</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;float32&quot;</span><span class="p">},</span>
               <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zlib&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;complevel&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">netcdf_compression</span><span class="p">),</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;float32&quot;</span><span class="p">},</span>
               <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zlib&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;complevel&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">netcdf_compression</span><span class="p">),</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;float32&quot;</span><span class="p">}}</span>
        <span class="n">ds_out</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">P_out</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">enc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds_out</span></div>


<div class="viewcode-block" id="SeaIceGridWork.read_grounded_iceberg_csv">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.read_grounded_iceberg_csv">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_grounded_iceberg_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P_csv</span><span class="p">,</span>
                                  <span class="n">lon_col</span>          <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span>
                                  <span class="n">lat_col</span>          <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lat&quot;</span><span class="p">,</span>
                                  <span class="n">normalise_lon_to</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;0-360&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a grounded-iceberg (GI) point CSV and standardise columns.</span>

<span class="sd">        The CSV must contain longitude and latitude columns (degrees). Optional</span>
<span class="sd">        columns are preserved when present (e.g., area_m2, C_gi, orient_deg, t_start,</span>
<span class="sd">        t_end). Longitudes are normalised to the chosen convention.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        P_csv : str or pathlib.Path</span>
<span class="sd">            Path to the CSV file.</span>
<span class="sd">        lon_col : str, default=&quot;lon&quot;</span>
<span class="sd">            Name of the longitude column in the CSV.</span>
<span class="sd">        lat_col : str, default=&quot;lat&quot;</span>
<span class="sd">            Name of the latitude column in the CSV.</span>
<span class="sd">        normalise_lon_to : {&quot;0-360&quot;,&quot;-180-180&quot;}, default=&quot;0-360&quot;</span>
<span class="sd">            Longitude convention applied after reading.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">            DataFrame with at least columns:</span>
<span class="sd">            - lon : float (degrees)</span>
<span class="sd">            - lat : float (degrees)</span>
<span class="sd">            and any recognised optional columns preserved.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If required columns are missing.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Rows with missing or non-numeric lon/lat are dropped. Latitudes are bounded</span>
<span class="sd">        to [-90, 90] as a basic sanity check.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">P_csv</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lon_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">lat_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CSV must contain columns &#39;</span><span class="si">{</span><span class="n">lon_col</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">lat_col</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Found: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">lon_col</span><span class="p">:</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="n">lat_col</span><span class="p">:</span> <span class="s2">&quot;lat&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># normalise lon to match CICE grid convention</span>
        <span class="k">if</span> <span class="n">normalise_lon_to</span> <span class="o">==</span> <span class="s2">&quot;0-360&quot;</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="mf">360.0</span> <span class="o">+</span> <span class="mf">360.0</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span>
        <span class="k">elif</span> <span class="n">normalise_lon_to</span> <span class="o">==</span> <span class="s2">&quot;-180-180&quot;</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.0</span>
        <span class="c1"># optional columns (not *yet* required)</span>
        <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;area_m2&quot;</span><span class="p">,</span> <span class="s2">&quot;C_gi&quot;</span><span class="p">,</span> <span class="s2">&quot;orient_deg&quot;</span><span class="p">,</span> <span class="s2">&quot;t_start&quot;</span><span class="p">,</span> <span class="s2">&quot;t_end&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># keep as-is; coerce numeric where appropriate</span>
                <span class="k">if</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;area_m2&quot;</span><span class="p">,</span> <span class="s2">&quot;C_gi&quot;</span><span class="p">,</span> <span class="s2">&quot;orient_deg&quot;</span><span class="p">]:</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">opt</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>
        <span class="c1"># sanity check ...</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">90.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">90.0</span><span class="p">)]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;logger&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded GI CSV: </span><span class="si">{</span><span class="n">P_csv</span><span class="si">}</span><span class="s2"> (n=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

    
<div class="viewcode-block" id="SeaIceGridWork.read_grounded_iceberg_gpkg">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.read_grounded_iceberg_gpkg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_grounded_iceberg_gpkg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">P_gpkg</span>           <span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                    <span class="n">layer</span>            <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;grounded_icebergs&quot;</span><span class="p">,</span>
                                    <span class="n">dedup_uid</span>        <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">uid_col</span>          <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Global_UID&quot;</span><span class="p">,</span>
                                    <span class="n">x_col</span>            <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Easting_3031&quot;</span><span class="p">,</span>
                                    <span class="n">y_col</span>            <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Northing_3031&quot;</span><span class="p">,</span>
                                    <span class="n">lon_col</span>          <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Longitude&quot;</span><span class="p">,</span>
                                    <span class="n">lat_col</span>          <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Latitude&quot;</span><span class="p">,</span>
                                    <span class="n">area_km2_col</span>     <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Area_Mean_km2&quot;</span><span class="p">,</span>
                                    <span class="n">use_attr_area</span>    <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">normalise_lon_to</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;0-360&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a grounded-iceberg polygon GeoPackage and derive mapping-ready attributes.</span>

<span class="sd">        The GeoPackage is expected to contain grounded iceberg polygons (typically in</span>
<span class="sd">        EPSG:3031). This method computes perimeter and area from geometry, optionally</span>
<span class="sd">        prefers an attribute-provided mean area (e.g., Area_Mean_km2), and returns a</span>
<span class="sd">        tabular representation suitable for mapping to the model grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        P_gpkg : str or pathlib.Path</span>
<span class="sd">            Path to the GeoPackage.</span>
<span class="sd">        layer : str, default=&quot;grounded_icebergs&quot;</span>
<span class="sd">            Layer name to read.</span>
<span class="sd">        dedup_uid : bool, default=True</span>
<span class="sd">            If True, aggregate multiple detections sharing `uid_col` into one record</span>
<span class="sd">            (mean position; median size metrics).</span>
<span class="sd">        uid_col : str, default=&quot;Global_UID&quot;</span>
<span class="sd">            Unique identifier column for deduplication.</span>
<span class="sd">        x_col, y_col : str</span>
<span class="sd">            Column names containing projected coordinates in EPSG:3031 meters.</span>
<span class="sd">        lon_col, lat_col : str</span>
<span class="sd">            Optional geographic lon/lat columns (degrees) for metadata/debug.</span>
<span class="sd">        area_km2_col : str, default=&quot;Area_Mean_km2&quot;</span>
<span class="sd">            Attribute column containing mean iceberg area in km^2.</span>
<span class="sd">        use_attr_area : bool, default=True</span>
<span class="sd">            If True and `area_km2_col` exists, use it (falling back to geometry area</span>
<span class="sd">            when missing/invalid). If False, use geometry area only.</span>
<span class="sd">        normalise_lon_to : {&quot;0-360&quot;,&quot;-180-180&quot;}, default=&quot;0-360&quot;</span>
<span class="sd">            Longitude convention applied to the lon column (if present).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">            Table with columns:</span>
<span class="sd">            - uid, x_m, y_m, lon, lat</span>
<span class="sd">            - area_m2, perim_m</span>
<span class="sd">            - bed_depth (if present), plus additional metadata columns when available</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Rows without finite x/y coordinates are dropped. Perimeter and geometry area</span>
<span class="sd">        are computed in the native CRS units (meters for EPSG:3031).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">P_gpkg</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;pyogrio&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:3031&quot;</span><span class="p">)</span>
        <span class="c1"># metric perimeter/area from geometry in EPSG:3031</span>
        <span class="n">perim_m</span>      <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">geom_area_m2</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># preferred area from attribute (mean across detections), fallback to geometry</span>
        <span class="k">if</span> <span class="n">use_attr_area</span> <span class="ow">and</span> <span class="p">(</span><span class="n">area_km2_col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">area_m2</span>      <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">gdf</span><span class="p">[</span><span class="n">area_km2_col</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e6</span>
            <span class="n">bad</span>          <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">area_m2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">area_m2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">area_m2</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span> <span class="o">=</span> <span class="n">geom_area_m2</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">area_m2</span> <span class="o">=</span> <span class="n">geom_area_m2</span>
        <span class="c1"># coordinates for mapping (x/y in metres)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x_col</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">y_col</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="c1"># lon/lat for metadata (optional)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lon_col</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lat_col</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">to</span> <span class="o">=</span> <span class="n">normalise_lon_to</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;uid&quot;</span>         <span class="p">:</span> <span class="n">gdf</span><span class="p">[</span><span class="n">uid_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">uid_col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)),</span>
                            <span class="s2">&quot;x_m&quot;</span>        <span class="p">:</span> <span class="n">x</span><span class="p">,</span>
                            <span class="s2">&quot;y_m&quot;</span>        <span class="p">:</span> <span class="n">y</span><span class="p">,</span>
                            <span class="s2">&quot;lon&quot;</span>        <span class="p">:</span> <span class="n">lon</span><span class="p">,</span>
                            <span class="s2">&quot;lat&quot;</span>        <span class="p">:</span> <span class="n">lat</span><span class="p">,</span>
                            <span class="s2">&quot;area_m2&quot;</span>    <span class="p">:</span> <span class="n">area_m2</span><span class="p">,</span>
                            <span class="s2">&quot;perim_m&quot;</span>    <span class="p">:</span> <span class="n">perim_m</span><span class="p">,</span>
                            <span class="s2">&quot;bed_depth&quot;</span>  <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Bed_Depth&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">),</span>
                            <span class="s2">&quot;timestamp&quot;</span>  <span class="p">:</span> <span class="n">gdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Timestamp&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                            <span class="s2">&quot;date_range&quot;</span> <span class="p">:</span> <span class="n">gdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Date_Range&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                            <span class="s2">&quot;orbit&quot;</span>      <span class="p">:</span> <span class="n">gdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Orbit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                            <span class="s2">&quot;swath_mode&quot;</span> <span class="p">:</span> <span class="n">gdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Swath_Mode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)})</span>
        <span class="c1"># drop unusable rows</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;x_m&quot;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;y_m&quot;</span><span class="p">])]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># deduplicate by uid (recommended)</span>
        <span class="k">if</span> <span class="n">dedup_uid</span> <span class="ow">and</span> <span class="s2">&quot;uid&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># keep one row per uid; use median for sizes, mean for position</span>
            <span class="n">agg</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x_m&quot;</span>      <span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>   <span class="s2">&quot;y_m&quot;</span>    <span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;lon&quot;</span>      <span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>   <span class="s2">&quot;lat&quot;</span>    <span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;area_m2&quot;</span>  <span class="p">:</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;perim_m&quot;</span><span class="p">:</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;bed_depth&quot;</span><span class="p">:</span> <span class="s2">&quot;median&quot;</span><span class="p">}</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;uid&quot;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded GI GPKG: </span><span class="si">{</span><span class="n">P_gpkg</span><span class="si">}</span><span class="s2"> layer=</span><span class="si">{</span><span class="n">layer</span><span class="si">}</span><span class="s2"> n=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s2"> (dedup_uid=</span><span class="si">{</span><span class="n">dedup_uid</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

    
<div class="viewcode-block" id="SeaIceGridWork.map_xy_to_tgrid">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.map_xy_to_tgrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_xy_to_tgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_m</span><span class="p">,</span> <span class="n">y_m</span><span class="p">,</span>
                        <span class="n">proj_crs</span>    <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="s2">&quot;EPSG:3031&quot;</span><span class="p">,</span> 
                        <span class="n">max_dist_km</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map projected x/y points to the nearest CICE T-cell using a cached KDTree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_m, y_m : array-like</span>
<span class="sd">            Point coordinates in meters in the CRS specified by `proj_crs`.</span>
<span class="sd">        proj_crs : str, default=&quot;EPSG:3031&quot;</span>
<span class="sd">            CRS of input x/y coordinates. Must match the CRS used to build the KDTree.</span>
<span class="sd">        max_dist_km : float, optional</span>
<span class="sd">            If provided, points farther than this distance (km) from the nearest</span>
<span class="sd">            T-cell center are flagged invalid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ii : numpy.ndarray</span>
<span class="sd">            Nearest-cell i indices (int64).</span>
<span class="sd">        jj : numpy.ndarray</span>
<span class="sd">            Nearest-cell j indices (int64).</span>
<span class="sd">        dist_m : numpy.ndarray</span>
<span class="sd">            Distance (meters) from each point to the nearest T-cell center.</span>
<span class="sd">        valid : numpy.ndarray</span>
<span class="sd">            Boolean mask indicating finite distances and (if provided) max_dist_km</span>
<span class="sd">            compliance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Requires `self.G_t` to be loaded; if not present, `load_cice_grid` is called</span>
<span class="sd">        with `build_faces=True` to ensure consistent grid metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_t&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_grid</span><span class="p">(</span><span class="n">slice_hem</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_faces</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tree</span><span class="p">,</span> <span class="n">ij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tgrid_kdtree</span><span class="p">(</span><span class="n">proj_crs</span><span class="o">=</span><span class="n">proj_crs</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">q</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y_m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)])</span>
        <span class="n">dist_m</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ii</span>          <span class="o">=</span> <span class="n">ij</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="n">jj</span>          <span class="o">=</span> <span class="n">ij</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="n">valid</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist_m</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_dist_km</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">dist_m</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_dist_km</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">dist_m</span><span class="p">,</span> <span class="n">valid</span></div>


<div class="viewcode-block" id="SeaIceGridWork.compute_tcell_dxdy_m">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.compute_tcell_dxdy_m">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_tcell_dxdy_m</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                             <span class="n">force</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">cache</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute approximate T-cell metric lengths dx and dy (meters).</span>

<span class="sd">        The method estimates T-cell sizes using distances between adjacent face-center</span>
<span class="sd">        coordinates derived from grid corner/face metadata (self.G_e, self.G_n). Great-</span>
<span class="sd">        circle (ellipsoidal) distances are computed on the WGS84 ellipsoid using</span>
<span class="sd">        `pyproj.Geod.inv`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        force : bool, default=False</span>
<span class="sd">            If True, recompute dx/dy even if cached values exist.</span>
<span class="sd">        cache : bool, default=True</span>
<span class="sd">            If True, store results in `self._dxdy_cache` and reuse on subsequent calls.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dx_m : numpy.ndarray</span>
<span class="sd">            Zonal metric length between adjacent vertical-face centers, shape (nj, ni),</span>
<span class="sd">            in meters (float64).</span>
<span class="sd">        dy_m : numpy.ndarray</span>
<span class="sd">            Meridional metric length between adjacent horizontal-face centers, shape</span>
<span class="sd">            (nj, ni), in meters (float64).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If `pyproj` is not available.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Distances are returned as absolute values; non-finite or non-positive values</span>
<span class="sd">        are set to NaN.</span>
<span class="sd">        - This is an approximate metric consistent with face-center spacing; it is</span>
<span class="sd">        appropriate for normalising form-factor sums and related diagnostics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">pyproj</span><span class="w"> </span><span class="kn">import</span> <span class="n">Geod</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;pyproj.Geod is required to compute dx/dy. Install pyproj.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">force</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_dxdy_cache&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dxdy_cache</span><span class="p">[</span><span class="s2">&quot;dx_m&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dxdy_cache</span><span class="p">[</span><span class="s2">&quot;dy_m&quot;</span><span class="p">]</span>
        <span class="c1"># ensure grid is loaded with faces</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_t&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_e&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_grid</span><span class="p">(</span><span class="n">slice_hem</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_faces</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">lon_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_e</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># shape (nj, ni+1)</span>
        <span class="n">lat_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_e</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">lon_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_n</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># shape (nj+1, ni)</span>
        <span class="n">lat_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_n</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">geod</span> <span class="o">=</span> <span class="n">Geod</span><span class="p">(</span><span class="n">ellps</span><span class="o">=</span><span class="s2">&quot;WGS84&quot;</span><span class="p">)</span>
        <span class="c1"># dx: distance between adjacent vertical-face centers: (j,i) edge -&gt; (j,i+1) edge</span>
        <span class="n">lon1</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon_e</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;-180-180&quot;</span><span class="p">)</span>
        <span class="n">lat1</span>       <span class="o">=</span> <span class="n">lat_e</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lon2</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon_e</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;-180-180&quot;</span><span class="p">)</span>
        <span class="n">lat2</span>       <span class="o">=</span> <span class="n">lat_e</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dx_m</span> <span class="o">=</span> <span class="n">geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">)</span>  <span class="c1"># returns meters, shape (nj, ni)</span>
        <span class="c1"># dy: distance between adjacent horizontal-face centers: (j,i) edge -&gt; (j+1,i) edge</span>
        <span class="n">lon1</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon_n</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;-180-180&quot;</span><span class="p">)</span>
        <span class="n">lat1</span>       <span class="o">=</span> <span class="n">lat_n</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">lon2</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalise_longitudes</span><span class="p">(</span><span class="n">lon_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:],</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;-180-180&quot;</span><span class="p">)</span>
        <span class="n">lat2</span>       <span class="o">=</span> <span class="n">lat_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dy_m</span> <span class="o">=</span> <span class="n">geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">)</span>  <span class="c1"># shape (nj, ni)</span>
        <span class="c1"># |dx| &amp; |dy|, and convert to float64 </span>
        <span class="n">dx_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dx_m</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">dy_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy_m</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="c1"># avoid zeros ... statistically unsafe</span>
        <span class="n">dx_m</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dx_m</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">dy_m</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dy_m</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">dx_m</span><span class="p">[</span><span class="n">dx_m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">dy_m</span><span class="p">[</span><span class="n">dy_m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dxdy_cache</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dx_m&quot;</span><span class="p">:</span> <span class="n">dx_m</span><span class="p">,</span> <span class="s2">&quot;dy_m&quot;</span><span class="p">:</span> <span class="n">dy_m</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">dx_m</span><span class="p">,</span> <span class="n">dy_m</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_tgrid_kdtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                          <span class="n">proj_crs</span> <span class="o">=</span> <span class="s2">&quot;EPSG:3031&quot;</span><span class="p">,</span>
                          <span class="n">force</span>     <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build (or retrieve) a cached KDTree of projected T-cell centers.</span>

<span class="sd">        The KDTree enables fast nearest-neighbor mapping from projected coordinates</span>
<span class="sd">        (x,y) to model T-grid indices. Lon/lat are projected from EPSG:4326 into</span>
<span class="sd">        `proj_crs` using pyproj.Transformer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        proj_crs : str, default=&quot;EPSG:3031&quot;</span>
<span class="sd">            Projected CRS used to represent T-cell centers in meters.</span>
<span class="sd">        force : bool, default=False</span>
<span class="sd">            If True, rebuild the KDTree even if a cached tree exists.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tree : scipy.spatial.cKDTree</span>
<span class="sd">            KDTree built over projected (x,y) coordinates for all T-cells.</span>
<span class="sd">        ij : numpy.ndarray</span>
<span class="sd">            Integer index array of shape (N, 2) mapping KDTree point order to</span>
<span class="sd">            (i, j) indices: ij[:,0] = i, ij[:,1] = j.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cache key includes the CRS and the grid shape. If the grid changes or a</span>
<span class="sd">        different CRS is requested, the tree is rebuilt.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">cKDTree</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyproj</span><span class="w"> </span><span class="kn">import</span> <span class="n">Transformer</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">force</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_tgrid_tree_cache&quot;</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tgrid_tree_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="p">(</span><span class="n">proj_crs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tgrid_tree_cache</span><span class="p">[</span><span class="s2">&quot;tree&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tgrid_tree_cache</span><span class="p">[</span><span class="s2">&quot;ij&quot;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># Project lon/lat -&gt; x/y (meters)</span>
        <span class="n">tr</span>     <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">proj_crs</span><span class="p">,</span> <span class="n">always_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span>   <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lon</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">),</span> <span class="n">lat</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">))</span>
        <span class="n">nj</span><span class="p">,</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">lon</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">ij</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ni</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nj</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># (N,2): [i,j]</span>
        <span class="n">pts</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>  <span class="c1"># (N,2)</span>
        <span class="n">tree</span>   <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
        <span class="c1"># strore in an underscore ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tgrid_tree_cache</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">proj_crs</span><span class="p">,</span> <span class="p">(</span><span class="n">nj</span><span class="p">,</span> <span class="n">ni</span><span class="p">)),</span> <span class="s2">&quot;tree&quot;</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="s2">&quot;ij&quot;</span><span class="p">:</span> <span class="n">ij</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">tree</span><span class="p">,</span> <span class="n">ij</span>

<div class="viewcode-block" id="SeaIceGridWork.map_points_to_tgrid">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.map_points_to_tgrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_points_to_tgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon_deg</span><span class="p">,</span> <span class="n">lat_deg</span><span class="p">,</span>
                            <span class="n">proj_crs</span>    <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span><span class="s2">&quot;EPSG:3031&quot;</span><span class="p">,</span>
                            <span class="n">max_dist_km</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map geographic lon/lat points to the nearest CICE T-cell.</span>

<span class="sd">        Points are projected into `proj_crs` and mapped to the nearest projected</span>
<span class="sd">        T-cell center using a cached KDTree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon_deg, lat_deg : array-like</span>
<span class="sd">            Longitudes and latitudes in degrees (EPSG:4326).</span>
<span class="sd">        proj_crs : str, default=&quot;EPSG:3031&quot;</span>
<span class="sd">            Projected CRS used for KDTree search (meters).</span>
<span class="sd">        max_dist_km : float, optional</span>
<span class="sd">            If provided, points farther than this distance (km) from the nearest</span>
<span class="sd">            T-cell center are flagged invalid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ii : numpy.ndarray</span>
<span class="sd">            Nearest-cell i indices (int64).</span>
<span class="sd">        jj : numpy.ndarray</span>
<span class="sd">            Nearest-cell j indices (int64).</span>
<span class="sd">        dist_m : numpy.ndarray</span>
<span class="sd">            Distance (meters) from each point to the nearest T-cell center.</span>
<span class="sd">        valid : numpy.ndarray</span>
<span class="sd">            Boolean mask indicating finite distances and (if provided) max_dist_km</span>
<span class="sd">            compliance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Requires `self.G_t` to be loaded; if absent, `load_cice_grid` is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyproj</span><span class="w"> </span><span class="kn">import</span> <span class="n">Transformer</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_t&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_grid</span><span class="p">(</span><span class="n">slice_hem</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_faces</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tree</span><span class="p">,</span> <span class="n">ij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tgrid_kdtree</span><span class="p">(</span><span class="n">proj_crs</span><span class="o">=</span><span class="n">proj_crs</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tr</span>       <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">proj_crs</span><span class="p">,</span> <span class="n">always_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span>     <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lon_deg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lat_deg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">))</span>
        <span class="n">q</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
        <span class="c1"># compute distances to each t-cell</span>
        <span class="n">dist_m</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ii</span>          <span class="o">=</span> <span class="n">ij</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="n">jj</span>          <span class="o">=</span> <span class="n">ij</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="c1"># only use valid points</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist_m</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_dist_km</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist_m</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_dist_km</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">dist_m</span><span class="p">,</span> <span class="n">valid</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_dbscan_like_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                              <span class="n">eps_m</span>       <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span><span class="mf">15000.0</span><span class="p">,</span>
                              <span class="n">min_samples</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span><span class="mi">2</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cluster points using a minimal DBSCAN-like algorithm (no sklearn dependency).</span>

<span class="sd">        Connectivity is defined by an epsilon-neighborhood in Euclidean projected</span>
<span class="sd">        space. Points with at least `min_samples` neighbors (including themselves)</span>
<span class="sd">        are treated as core points; clusters are grown by breadth-first search from</span>
<span class="sd">        core points, and border points are assigned to a cluster if reachable.</span>
<span class="sd">        Points not reachable from any core point are labeled as noise (-1).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like</span>
<span class="sd">            Point coordinates in meters (projected planar coordinates).</span>
<span class="sd">        eps_m : float, default=15000.0</span>
<span class="sd">            Neighborhood radius in meters.</span>
<span class="sd">        min_samples : int, default=2</span>
<span class="sd">            Minimum neighbor count required for a point to be considered a core point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels : numpy.ndarray</span>
<span class="sd">            Integer labels of shape (N,). Cluster IDs are 0..K-1; noise points are -1.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This implementation is intended for modest point counts and avoids external</span>
<span class="sd">        dependencies. For very large N, consider sklearn.cluster.DBSCAN for improved</span>
<span class="sd">        performance and additional options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">cKDTree</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
        <span class="n">x</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">y</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">n</span>    <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span>
        <span class="n">pts</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
        <span class="c1"># get neighbours from tree and count the number </span>
        <span class="n">neigh</span>        <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eps_m</span><span class="p">))</span>
        <span class="n">neigh_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="n">is_core</span>      <span class="o">=</span> <span class="n">neigh_counts</span> <span class="o">&gt;=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_samples</span><span class="p">)</span>
        <span class="n">labels</span>       <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="n">cid</span>          <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># loop over lons to create a label of good (&#39;1&#39;) and bad (&#39;-1&#39;) points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_core</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="c1"># Start a new cluster</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cid</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
            <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">[</span><span class="n">p</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cid</span>
                        <span class="k">if</span> <span class="n">is_core</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">cid</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">labels</span>
    
<div class="viewcode-block" id="SeaIceGridWork.build_F2_GI_from_df">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.build_F2_GI_from_df">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_F2_GI_from_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span>
                            <span class="n">method</span>                <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;simple-geometry&quot;</span><span class="p">,</span>
                            <span class="n">length_scale</span>          <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;perimeter&quot;</span><span class="p">,</span>        <span class="c1"># {&quot;perimeter&quot;,&quot;area&quot;}</span>
                            <span class="n">base_area_m2</span>          <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">C_gi</span>                  <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="n">proj_crs</span>              <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;EPSG:3031&quot;</span><span class="p">,</span>
                            <span class="n">max_map_dist_km</span>       <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">,</span>
                            <span class="n">eps_cluster_km</span>        <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">15.0</span><span class="p">,</span>
                            <span class="n">min_cluster_size</span>      <span class="p">:</span> <span class="nb">int</span>   <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                            <span class="n">cluster_buffer_m</span>      <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">cluster_amplification</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                            <span class="n">weight_by</span>             <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="s2">&quot;perim&quot;</span><span class="p">):</span>          <span class="c1"># for cluster-axis share: {&quot;equal&quot;,&quot;perim&quot;,&quot;area&quot;}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build grounded-iceberg (GI) contributions to F2 form factors on the CICE T-grid.</span>

<span class="sd">        This method maps grounded iceberg locations (and optional size metrics) onto</span>
<span class="sd">        the model T-grid and accumulates additional form-factor terms (F2x_gi, F2y_gi)</span>
<span class="sd">        intended to represent sub-grid-scale coastal/obstacle form drag associated</span>
<span class="sd">        with grounded icebergs.</span>

<span class="sd">        Two approaches are supported:</span>

<span class="sd">        1) method=&quot;simple-geometry&quot;</span>
<span class="sd">        Each GI contributes an isotropic projected length scale Lproj normalised by</span>
<span class="sd">        local grid metrics:</span>
<span class="sd">            F2x_gi += C_gi * (Lproj / dx)</span>
<span class="sd">            F2y_gi += C_gi * (Lproj / dy)</span>
<span class="sd">        where Lproj is derived from either perimeter (preferred) or area.</span>

<span class="sd">        2) method=&quot;cluster-axis&quot;</span>
<span class="sd">        Nearby GI points are clustered (DBSCAN-like). Each cluster is represented</span>
<span class="sd">        by an oriented ellipse/rectangle described by principal axes in projected</span>
<span class="sd">        space. Cluster-aligned projected lengths are rotated into the local model</span>
<span class="sd">        coordinate frame using the grid angle, and then distributed back to member</span>
<span class="sd">        points with optional weighting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">            Input table of GI features. Expected columns:</span>
<span class="sd">            - lon, lat (degrees) and/or x_m, y_m (meters in `proj_crs`)</span>
<span class="sd">            Optional columns:</span>
<span class="sd">            - area_m2 : feature area in m^2</span>
<span class="sd">            - perim_m : feature perimeter in m</span>
<span class="sd">            - C_gi    : per-feature scaling coefficient</span>
<span class="sd">        method : {&quot;simple-geometry&quot;,&quot;cluster-axis&quot;}, default=&quot;simple-geometry&quot;</span>
<span class="sd">            Parameterisation for converting GI features into form factors.</span>
<span class="sd">        length_scale : {&quot;perimeter&quot;,&quot;area&quot;}, default=&quot;perimeter&quot;</span>
<span class="sd">            Length-scale basis for &quot;simple-geometry&quot;. If perimeter is unavailable,</span>
<span class="sd">            falls back to area.</span>
<span class="sd">        base_area_m2 : float, optional</span>
<span class="sd">            Default area used when df lacks area_m2. If None, uses median T-cell area.</span>
<span class="sd">        C_gi : float, default=1.0</span>
<span class="sd">            Default scaling coefficient applied when df lacks per-feature C_gi.</span>
<span class="sd">        proj_crs : str, default=&quot;EPSG:3031&quot;</span>
<span class="sd">            CRS for x/y mapping and clustering operations (meters).</span>
<span class="sd">        max_map_dist_km : float, default=50.0</span>
<span class="sd">            Maximum allowed distance between a GI point and its nearest T-cell center.</span>
<span class="sd">            Features beyond this are dropped.</span>
<span class="sd">        eps_cluster_km : float, default=15.0</span>
<span class="sd">            Clustering neighborhood radius (km) for &quot;cluster-axis&quot;.</span>
<span class="sd">        min_cluster_size : int, default=3</span>
<span class="sd">            Minimum number of points required to form a cluster in &quot;cluster-axis&quot;.</span>
<span class="sd">        cluster_buffer_m : float, optional</span>
<span class="sd">            Buffer added to cluster axis lengths (meters). If None, defaults to an</span>
<span class="sd">            equivalent-radius buffer derived from `base_area_m2`.</span>
<span class="sd">        cluster_amplification : float, default=0.0</span>
<span class="sd">            Optional amplification factor for cluster lengths:</span>
<span class="sd">                amp = 1 + cluster_amplification * log1p(n_cluster)</span>
<span class="sd">            (applied to both principal axes).</span>
<span class="sd">        weight_by : {&quot;equal&quot;,&quot;perim&quot;,&quot;area&quot;}, default=&quot;perim&quot;</span>
<span class="sd">            Weighting used to distribute cluster-scale form factor back to member</span>
<span class="sd">            points/cells. Falls back to equal weights when required metrics are missing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds : xarray.Dataset</span>
<span class="sd">            Dataset containing:</span>
<span class="sd">            - F2x_gi(nj,ni), F2y_gi(nj,ni) : float32, unitless</span>
<span class="sd">            - gi_count(nj,ni) : int32 count of mapped GI features per cell</span>
<span class="sd">            plus diagnostic vectors indexed by &quot;ngi&quot; (mapped features):</span>
<span class="sd">            - gi_lon, gi_lat, gi_i, gi_j, gi_cluster_id, gi_map_dist_m,</span>
<span class="sd">                gi_area_m2, gi_perim_m</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `method` is unsupported.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Grid metrics dx/dy are computed (and cached) via `compute_tcell_dxdy_m`.</span>
<span class="sd">        - Mapping is performed by nearest-neighbor search in projected space using</span>
<span class="sd">        a cached KDTree of T-cell centers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyproj</span><span class="w"> </span><span class="kn">import</span> <span class="n">Transformer</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_t&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_cice_grid</span><span class="p">(</span><span class="n">slice_hem</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_faces</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nat_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;spatial_dims&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;nj&quot;</span><span class="p">,</span> <span class="s2">&quot;ni&quot;</span><span class="p">))</span>
        <span class="n">nj</span><span class="p">,</span> <span class="n">ni</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">base_area_m2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_area_m2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
        <span class="c1"># get coords for mapping -- allows for either lon/lat or x/y points</span>
        <span class="n">has_xy</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x_m&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;y_m&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;x_m&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">has_xy</span><span class="p">:</span>
            <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">dist_m</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_xy_to_tgrid</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;x_m&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;y_m&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                                        <span class="n">proj_crs</span><span class="o">=</span><span class="n">proj_crs</span><span class="p">,</span> <span class="n">max_dist_km</span><span class="o">=</span><span class="n">max_map_dist_km</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">dist_m</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_points_to_tgrid</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                                            <span class="n">proj_crs</span><span class="o">=</span><span class="n">proj_crs</span><span class="p">,</span> <span class="n">max_dist_km</span><span class="o">=</span><span class="n">max_map_dist_km</span><span class="p">)</span>
        <span class="c1"># update dataframe with valid-only points</span>
        <span class="n">df</span>     <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ii</span>     <span class="o">=</span> <span class="n">ii</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">jj</span>     <span class="o">=</span> <span class="n">jj</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">dist_m</span> <span class="o">=</span> <span class="n">dist_m</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="c1"># dx/dy on T-grid</span>
        <span class="n">dx_m</span><span class="p">,</span> <span class="n">dy_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_tcell_dxdy_m</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># flatten indexing for vectorised accumulation</span>
        <span class="n">flat</span> <span class="o">=</span> <span class="p">(</span><span class="n">jj</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span> <span class="o">+</span> <span class="n">ii</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">))</span>
        <span class="n">dx</span>   <span class="o">=</span> <span class="n">dx_m</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">flat</span><span class="p">]</span>
        <span class="n">dy</span>   <span class="o">=</span> <span class="n">dy_m</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">flat</span><span class="p">]</span>
        <span class="c1"># ensure dx/dy are finite and &gt;0</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># areas/perimeters</span>
        <span class="n">area_m2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;area_m2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;area_m2&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">base_area_m2</span><span class="p">)</span>
        <span class="n">perim_m</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;perim_m&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;perim_m&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1"># C_gi per point if present</span>
        <span class="k">if</span> <span class="s2">&quot;C_gi&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">Cvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;C_gi&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">C_gi</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Cvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">C_gi</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="c1"># &#39;isotropic&#39; (my local definition) projected length scale (for simple-geometry)</span>
        <span class="k">if</span> <span class="n">length_scale</span> <span class="o">==</span> <span class="s2">&quot;perimeter&quot;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">perim_m</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">Lproj</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">perim_m</span>
            <span class="c1"># fallback to area for any missing perimeters</span>
            <span class="n">bad</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Lproj</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">Lproj</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bad</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">Lproj</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">area_m2</span><span class="p">[</span><span class="n">bad</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Lproj</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">area_m2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="c1"># initialise x/y form factors</span>
        <span class="n">F2x_gi</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nj</span><span class="p">,</span> <span class="n">ni</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">F2y_gi</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nj</span><span class="p">,</span> <span class="n">ni</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">gi_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nj</span><span class="p">,</span> <span class="n">ni</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;simple-geometry&quot;</span><span class="p">:</span>
            <span class="c1"># vectorised add-at</span>
            <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dx</span><span class="p">);</span> <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>
            <span class="n">fx</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cvals</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Lproj</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="n">ok</span><span class="p">])</span>
            <span class="n">fy</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cvals</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Lproj</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">/</span> <span class="n">dy</span><span class="p">[</span><span class="n">ok</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">F2x_gi</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">flat</span><span class="p">[</span><span class="n">ok</span><span class="p">],</span> <span class="n">fx</span><span class="p">[</span><span class="n">ok</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">F2y_gi</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">flat</span><span class="p">[</span><span class="n">ok</span><span class="p">],</span> <span class="n">fy</span><span class="p">[</span><span class="n">ok</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">gi_count</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">flat</span><span class="p">[</span><span class="n">ok</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;cluster-axis&quot;</span><span class="p">:</span>
            <span class="c1"># need projected x/y for clustering; if not present, derive from lon/lat</span>
            <span class="k">if</span> <span class="n">has_xy</span><span class="p">:</span>
                <span class="n">x_gi</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;x_m&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
                <span class="n">y_gi</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;y_m&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tr</span>         <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">proj_crs</span><span class="p">,</span> <span class="n">always_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">x_gi</span><span class="p">,</span> <span class="n">y_gi</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">),</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">))</span>
                <span class="n">x_gi</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x_gi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
                <span class="n">y_gi</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y_gi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
            <span class="c1"># make sure inputs are inputs into this function</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dbscan_like_clusters</span><span class="p">(</span><span class="n">x_gi</span><span class="p">,</span> <span class="n">y_gi</span><span class="p">,</span>
                                                <span class="n">eps_m</span>       <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">eps_cluster_km</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">,</span>
                                                <span class="n">min_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_cluster_size</span><span class="p">))</span>
            <span class="c1"># local grid angle (rad)</span>
            <span class="n">ang_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_t</span><span class="p">[</span><span class="s2">&quot;angle&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">))</span>
            <span class="c1"># default buffer</span>
            <span class="k">if</span> <span class="n">cluster_buffer_m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cluster_buffer_m</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">base_area_m2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
            <span class="n">uniq</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">uniq</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">cid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">npt</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span>
                <span class="k">if</span> <span class="n">npt</span> <span class="o">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_cluster_size</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c1"># get eigenvecs and normalise for PCA part of computation</span>
                <span class="n">X</span>                <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x_gi</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">y_gi</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
                <span class="n">Xc</span>               <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">C</span>                <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">Xc</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
                <span class="n">v</span>                <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)]</span>
                <span class="n">v</span>                <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">u</span>                <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">s1</span>               <span class="o">=</span> <span class="n">Xc</span> <span class="o">@</span> <span class="n">v</span>
                <span class="n">s2</span>               <span class="o">=</span> <span class="n">Xc</span> <span class="o">@</span> <span class="n">u</span>
                <span class="n">L</span>                <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">cluster_buffer_m</span>
                <span class="n">W</span>                <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">cluster_buffer_m</span>
                <span class="c1"># cluster_amplication should never be 0, but ...</span>
                <span class="k">if</span> <span class="n">cluster_amplification</span> <span class="ow">and</span> <span class="n">cluster_amplification</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">amp</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">cluster_amplification</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">npt</span><span class="p">))</span>
                    <span class="n">L</span> <span class="o">*=</span> <span class="n">amp</span><span class="p">;</span> <span class="n">W</span> <span class="o">*=</span> <span class="n">amp</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># rad from +x (east) in projected plane</span>
                <span class="c1"># cluster share weights</span>
                <span class="k">if</span> <span class="n">weight_by</span> <span class="o">==</span> <span class="s2">&quot;perim&quot;</span> <span class="ow">and</span> <span class="s2">&quot;perim_m&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">perim_m</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">perim_m</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">weight_by</span> <span class="o">==</span> <span class="s2">&quot;area&quot;</span> <span class="ow">and</span> <span class="s2">&quot;area_m2&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">area_m2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
                <span class="n">w</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">wsum</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">wsum</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">);</span> <span class="n">wsum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">npt</span><span class="p">)</span>
                <span class="n">share</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">wsum</span>
                <span class="c1"># create form factors for every grid cell based on underlying grounded berg cluster-isation (!) and axis</span>
                <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ii</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">jj</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ni</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nj</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">dxk</span> <span class="o">=</span> <span class="n">dx_m</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span> <span class="n">dyk</span> <span class="o">=</span> <span class="n">dy_m</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dxk</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dyk</span><span class="p">))</span> <span class="ow">or</span> <span class="n">dxk</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dyk</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">theta</span>           <span class="o">=</span> <span class="n">phi</span> <span class="o">-</span> <span class="n">ang_rad</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">c</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">));</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
                    <span class="n">Lx_tot</span>          <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">L</span> <span class="o">*</span> <span class="n">c</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">W</span> <span class="o">*</span> <span class="n">s</span>
                    <span class="n">Ly_tot</span>          <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">L</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">W</span> <span class="o">*</span> <span class="n">c</span>
                    <span class="n">F2x_gi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>   <span class="o">+=</span> <span class="n">Cvals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">share</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Lx_tot</span> <span class="o">/</span> <span class="n">dxk</span><span class="p">)</span>
                    <span class="n">F2y_gi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>   <span class="o">+=</span> <span class="n">Cvals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">share</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ly_tot</span> <span class="o">/</span> <span class="n">dyk</span><span class="p">)</span>
                    <span class="n">gi_count</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be &#39;simple-geometry&#39; or &#39;cluster-axis&#39;&quot;</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;F2x_gi&quot;</span>   <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">F2x_gi</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;long_name&quot;</span>   <span class="p">:</span> <span class="s2">&quot;Grounded-iceberg additional form factor, x-projection (T-cell)&quot;</span><span class="p">,</span>
                                                                                       <span class="s2">&quot;units&quot;</span>       <span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span> <span class="s2">&quot;C_gi_default&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">C_gi</span><span class="p">),</span>
                                                                                       <span class="s2">&quot;length_scale&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">length_scale</span><span class="p">),</span> <span class="s2">&quot;weight_by&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">weight_by</span><span class="p">)}),</span>
                                     <span class="s2">&quot;F2y_gi&quot;</span>   <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">F2y_gi</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;long_name&quot;</span>   <span class="p">:</span> <span class="s2">&quot;Grounded-iceberg additional form factor, y-projection (T-cell)&quot;</span><span class="p">,</span>
                                                                                       <span class="s2">&quot;units&quot;</span>       <span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span> <span class="s2">&quot;C_gi_default&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">C_gi</span><span class="p">),</span>
                                                                                       <span class="s2">&quot;length_scale&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">length_scale</span><span class="p">),</span> <span class="s2">&quot;weight_by&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">weight_by</span><span class="p">)}),</span>
                                     <span class="s2">&quot;gi_count&quot;</span> <span class="p">:</span> <span class="p">(</span><span class="n">nat_dim</span><span class="p">,</span> <span class="n">gi_count</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;long_name&quot;</span>   <span class="p">:</span> <span class="s2">&quot;Number of GI polygons mapped into each T-cell&quot;</span><span class="p">,</span>
                                                                                       <span class="s2">&quot;units&quot;</span>       <span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">})},</span>
                        <span class="n">coords</span>    <span class="o">=</span> <span class="p">{</span><span class="n">nat_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nj</span><span class="p">),</span>
                                     <span class="n">nat_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ni</span><span class="p">)},</span>
                        <span class="n">attrs</span>     <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;proj_crs&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">proj_crs</span><span class="p">)})</span>
        <span class="c1"># diagnostics</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;gi_lon&quot;</span><span class="p">]</span>        <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ngi&quot;</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;lon&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">))</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;gi_lat&quot;</span><span class="p">]</span>        <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ngi&quot;</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;lat&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">))</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;gi_i&quot;</span><span class="p">]</span>          <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ngi&quot;</span><span class="p">,</span> <span class="n">ii</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">))</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;gi_j&quot;</span><span class="p">]</span>          <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ngi&quot;</span><span class="p">,</span> <span class="n">jj</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">))</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;gi_cluster_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ngi&quot;</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">))</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;gi_map_dist_m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ngi&quot;</span><span class="p">,</span> <span class="n">dist_m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">))</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;gi_area_m2&quot;</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ngi&quot;</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;area_m2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;area_m2&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">))</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;gi_perim_m&quot;</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ngi&quot;</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;perim_m&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;perim_m&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Built GI form factors (</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">): n_gi=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s2">, nonzero_cells=</span><span class="si">{</span><span class="p">(</span><span class="n">gi_count</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span></div>

    
    <span class="c1"># wrapper function for build_F2_GI_from_df</span>
<div class="viewcode-block" id="SeaIceGridWork.build_F2_GI_from_gpkg">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.build_F2_GI_from_gpkg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_F2_GI_from_gpkg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="n">P_gpkg</span>          <span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                <span class="n">layer</span>           <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;grounded_icebergs&quot;</span><span class="p">,</span>
                                <span class="n">method</span>          <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;simple-geometry&quot;</span><span class="p">,</span>
                                <span class="n">length_scale</span>    <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;perimeter&quot;</span><span class="p">,</span>
                                <span class="n">C_gi</span>            <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">proj_crs</span>        <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;EPSG:3031&quot;</span><span class="p">,</span>
                                <span class="n">max_map_dist_km</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">,</span>
                                <span class="n">dedup_uid</span>       <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience wrapper to build GI form factors directly from a GeoPackage.</span>

<span class="sd">        This reads grounded iceberg polygons from a GeoPackage layer using</span>
<span class="sd">        `read_grounded_iceberg_gpkg`, then delegates to `build_F2_GI_from_df` for</span>
<span class="sd">        mapping and accumulation on the CICE T-grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        P_gpkg : str or pathlib.Path</span>
<span class="sd">            GeoPackage path.</span>
<span class="sd">        layer : str, default=&quot;grounded_icebergs&quot;</span>
<span class="sd">            Layer name containing GI features.</span>
<span class="sd">        method : {&quot;simple-geometry&quot;,&quot;cluster-axis&quot;}, default=&quot;simple-geometry&quot;</span>
<span class="sd">            GI form-factor parameterisation.</span>
<span class="sd">        length_scale : {&quot;perimeter&quot;,&quot;area&quot;}, default=&quot;perimeter&quot;</span>
<span class="sd">            Length-scale option forwarded to `build_F2_GI_from_df`.</span>
<span class="sd">        C_gi : float, default=1.0</span>
<span class="sd">            Default scaling coefficient forwarded to `build_F2_GI_from_df`.</span>
<span class="sd">        proj_crs : str, default=&quot;EPSG:3031&quot;</span>
<span class="sd">            CRS used for mapping/clustering.</span>
<span class="sd">        max_map_dist_km : float, default=50.0</span>
<span class="sd">            Maximum mapping distance threshold (km).</span>
<span class="sd">        dedup_uid : bool, default=True</span>
<span class="sd">            Whether to deduplicate GI features by UID prior to mapping.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments forwarded to `build_F2_GI_from_df` (e.g.,</span>
<span class="sd">            clustering controls).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds : xarray.Dataset</span>
<span class="sd">            Output dataset from `build_F2_GI_from_df`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_grounded_iceberg_gpkg</span><span class="p">(</span><span class="n">P_gpkg</span><span class="p">,</span>
                                             <span class="n">layer</span>            <span class="o">=</span> <span class="n">layer</span><span class="p">,</span>
                                             <span class="n">dedup_uid</span>        <span class="o">=</span> <span class="n">dedup_uid</span><span class="p">,</span>
                                             <span class="n">normalise_lon_to</span> <span class="o">=</span> <span class="s2">&quot;0-360&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_F2_GI_from_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span>
                                        <span class="n">method</span>          <span class="o">=</span> <span class="n">method</span><span class="p">,</span>
                                        <span class="n">length_scale</span>    <span class="o">=</span> <span class="n">length_scale</span><span class="p">,</span>
                                        <span class="n">C_gi</span>            <span class="o">=</span> <span class="n">C_gi</span><span class="p">,</span>
                                        <span class="n">proj_crs</span>        <span class="o">=</span> <span class="n">proj_crs</span><span class="p">,</span>
                                        <span class="n">max_map_dist_km</span> <span class="o">=</span> <span class="n">max_map_dist_km</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

        
    <span class="k">def</span><span class="w"> </span><span class="nf">_nc_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># netCDF4 can&#39;t store bool attrs</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># numpy scalars -&gt; python scalars</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="c1"># paths -&gt; str</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># None -&gt; omit (or empty string if you prefer)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># dict/list/tuple -&gt; JSON string (netCDF attrs must be scalar-ish)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>
    
    <span class="c1"># wrapper and writer </span>
<div class="viewcode-block" id="SeaIceGridWork.write_F2_with_GI">
<a class="viewcode-back" href="../api.html#sea_ice_gridwork.SeaIceGridWork.write_F2_with_GI">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_F2_with_GI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">P_F2_coast</span>            <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">P_GI</span>                  <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>   <span class="c1"># NEW: can be .csv or .gpkg</span>
                        <span class="n">P_GI_CSV</span>              <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>   <span class="c1"># OPTIONAL: backward compatibility</span>
                        <span class="n">P_out</span>                 <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">method</span>                <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="s2">&quot;simple-geometry&quot;</span><span class="p">,</span>
                        <span class="n">base_area_m2</span>          <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">C_gi</span>                  <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                        <span class="c1"># pass-through clustering controls</span>
                        <span class="n">eps_cluster_km</span>        <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">15.0</span><span class="p">,</span>
                        <span class="n">min_cluster_size</span>      <span class="p">:</span> <span class="nb">int</span>   <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                        <span class="n">cluster_buffer_m</span>      <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">cluster_amplification</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                        <span class="n">weight_by</span>             <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="s1">&#39;perim&#39;</span><span class="p">,</span>
                        <span class="c1"># new optional knobs for GPKG workflow</span>
                        <span class="n">length_scale</span>          <span class="p">:</span> <span class="nb">str</span>   <span class="o">=</span> <span class="s2">&quot;perimeter&quot;</span><span class="p">,</span>   <span class="c1"># {&quot;perimeter&quot;,&quot;area&quot;} used by build_F2_GI_from_df/gpkg</span>
                        <span class="n">dedup_uid</span>             <span class="p">:</span> <span class="nb">bool</span>  <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">overwrite</span>             <span class="p">:</span> <span class="nb">bool</span>  <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine coast-only F2 form factors with grounded-iceberg (GI) contributions</span>
<span class="sd">        and write a new NetCDF.</span>

<span class="sd">        This method loads an existing coastline-derived F2 file (containing `F2x` and</span>
<span class="sd">        `F2y`), computes GI contributions from either:</span>
<span class="sd">        - a CSV of GI points (.csv), or</span>
<span class="sd">        - a GeoPackage of GI polygons (.gpkg),</span>
<span class="sd">        then writes a combined dataset containing:</span>
<span class="sd">        - total:     F2x, F2y</span>
<span class="sd">        - components F2x_coast, F2y_coast, F2x_gi, F2y_gi</span>
<span class="sd">        plus any available coastline vertex vectors and GI diagnostic vectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        P_F2_coast : str, optional</span>
<span class="sd">            Input coast-only F2 NetCDF path. If None, uses `self.CICE_dict[&quot;P_F2_coast&quot;]`.</span>
<span class="sd">        P_GI : str, optional</span>
<span class="sd">            Grounded iceberg input path. Supported extensions are &quot;.csv&quot; and &quot;.gpkg&quot;.</span>
<span class="sd">            If None, falls back to `P_GI_CSV` (legacy) or `self.GI_dict.get(&quot;P_KJ&quot;)`.</span>
<span class="sd">        P_GI_CSV : str, optional</span>
<span class="sd">            Legacy CSV input path (kept for backward compatibility). Ignored if `P_GI`</span>
<span class="sd">            is provided.</span>
<span class="sd">        P_out : str, optional</span>
<span class="sd">            Output NetCDF path. If None, uses `self.CICE_dict[&quot;P_F2_GI&quot;]`.</span>
<span class="sd">        method : {&quot;simple-geometry&quot;,&quot;cluster-axis&quot;}, default=&quot;simple-geometry&quot;</span>
<span class="sd">            GI parameterisation used when constructing GI form factors.</span>
<span class="sd">        base_area_m2 : float, optional</span>
<span class="sd">            Default area used when GI input lacks feature area. Passed through to GI</span>
<span class="sd">            builders where supported.</span>
<span class="sd">        C_gi : float, default=1.0</span>
<span class="sd">            Default GI scaling coefficient.</span>
<span class="sd">        eps_cluster_km : float, default=15.0</span>
<span class="sd">            Clustering radius (km) used for &quot;cluster-axis&quot; GI method.</span>
<span class="sd">        min_cluster_size : int, default=3</span>
<span class="sd">            Minimum cluster size used for &quot;cluster-axis&quot;.</span>
<span class="sd">        cluster_buffer_m : float, optional</span>
<span class="sd">            Buffer added to derived cluster axis lengths (meters).</span>
<span class="sd">        cluster_amplification : float, default=0.0</span>
<span class="sd">            Optional amplification of cluster axis lengths as a function of cluster size.</span>
<span class="sd">        length_scale : {&quot;perimeter&quot;,&quot;area&quot;}, default=&quot;perimeter&quot;</span>
<span class="sd">            Length-scale selection for the GI &quot;simple-geometry&quot; method.</span>
<span class="sd">        dedup_uid : bool, default=True</span>
<span class="sd">            For GeoPackage inputs, whether to deduplicate features by UID prior to mapping.</span>
<span class="sd">        overwrite : bool, default=False</span>
<span class="sd">            If False and `P_out` exists, raise FileExistsError. If True, overwrite.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds_out : xarray.Dataset</span>
<span class="sd">            Combined dataset written to disk.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If required inputs are missing or GI file type is unsupported.</span>
<span class="sd">        FileExistsError</span>
<span class="sd">            If `overwrite=False` and output path already exists.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Dim ordering is aligned to the coast file. GI arrays are transposed if needed</span>
<span class="sd">        to match the coast file (typically (nj, ni)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_F2_coast</span> <span class="o">=</span> <span class="n">P_F2_coast</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;P_F2_coast&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">P_out</span>      <span class="o">=</span> <span class="n">P_out</span>      <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">CICE_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;P_F2_GI&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Backward compatible resolution of GI path</span>
        <span class="k">if</span> <span class="n">P_GI</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">P_GI</span> <span class="o">=</span> <span class="n">P_GI_CSV</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">GI_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;P_KJ&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">P_GI</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No grounded iceberg input provided. Set P_GI (or legacy P_GI_CSV) or self.GI_dict[&#39;P_raw&#39;].&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;logger&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GI input: </span><span class="si">{</span><span class="n">P_GI</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">overwrite</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">P_out</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output already exists: </span><span class="si">{</span><span class="n">P_out</span><span class="si">}</span><span class="s2"> (set overwrite=True to replace)&quot;</span><span class="p">)</span>
        <span class="n">ds_coast</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">P_F2_coast</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;F2x&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds_coast</span><span class="o">.</span><span class="n">variables</span> <span class="ow">or</span> <span class="s2">&quot;F2y&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds_coast</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">P_F2_coast</span><span class="si">}</span><span class="s2"> must contain variables &#39;F2x&#39; and &#39;F2y&#39;.&quot;</span><span class="p">)</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># Dispatch: CSV vs GPKG</span>
        <span class="c1"># -----------------------------</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">P_GI</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.csv&quot;</span><span class="p">:</span>
            <span class="n">ds_gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_F2_GI_from_csv</span><span class="p">(</span><span class="n">P_GI</span><span class="p">,</span>
                                                <span class="n">method</span>                <span class="o">=</span> <span class="n">method</span><span class="p">,</span>
                                                <span class="n">base_area_m2</span>          <span class="o">=</span> <span class="n">base_area_m2</span><span class="p">,</span>
                                                <span class="n">C_gi</span>                  <span class="o">=</span> <span class="n">C_gi</span><span class="p">,</span>
                                                <span class="n">eps_cluster_km</span>        <span class="o">=</span> <span class="n">eps_cluster_km</span><span class="p">,</span>
                                                <span class="n">min_cluster_size</span>      <span class="o">=</span> <span class="n">min_cluster_size</span><span class="p">,</span>
                                                <span class="n">cluster_buffer_m</span>      <span class="o">=</span> <span class="n">cluster_buffer_m</span><span class="p">,</span>
                                                <span class="n">cluster_amplification</span> <span class="o">=</span> <span class="n">cluster_amplification</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.gpkg&quot;</span><span class="p">:</span>
            <span class="c1"># Prefer the new GPKG path; base_area_m2 can still be passed through via kwargs if you use it inside.</span>
            <span class="n">ds_gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_F2_GI_from_gpkg</span><span class="p">(</span><span class="n">P_GI</span><span class="p">,</span>
                                                <span class="n">method</span>                <span class="o">=</span> <span class="n">method</span><span class="p">,</span>
                                                <span class="n">length_scale</span>          <span class="o">=</span> <span class="n">length_scale</span><span class="p">,</span>
                                                <span class="n">C_gi</span>                  <span class="o">=</span> <span class="n">C_gi</span><span class="p">,</span>
                                                <span class="n">proj_crs</span>              <span class="o">=</span> <span class="s2">&quot;EPSG:3031&quot;</span><span class="p">,</span>
                                                <span class="n">max_map_dist_km</span>       <span class="o">=</span> <span class="mf">50.0</span><span class="p">,</span>
                                                <span class="n">dedup_uid</span>             <span class="o">=</span> <span class="n">dedup_uid</span><span class="p">,</span>
                                                <span class="c1"># clustering controls forwarded</span>
                                                <span class="n">eps_cluster_km</span>        <span class="o">=</span> <span class="n">eps_cluster_km</span><span class="p">,</span>
                                                <span class="n">min_cluster_size</span>      <span class="o">=</span> <span class="n">min_cluster_size</span><span class="p">,</span>
                                                <span class="n">cluster_buffer_m</span>      <span class="o">=</span> <span class="n">cluster_buffer_m</span><span class="p">,</span>
                                                <span class="n">cluster_amplification</span> <span class="o">=</span> <span class="n">cluster_amplification</span><span class="p">,</span>
                                                <span class="n">weight_by</span>             <span class="o">=</span> <span class="n">weight_by</span><span class="p">,</span>
                                                <span class="c1"># if build_F2_GI_from_df supports base_area_m2, include it:</span>
                                                <span class="n">base_area_m2</span>          <span class="o">=</span> <span class="n">base_area_m2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported GI input type &#39;</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&#39;. Expected .csv or .gpkg. Path: </span><span class="si">{</span><span class="n">P_GI</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Align dims (coast file uses (nj,ni) order)</span>
        <span class="n">F2x_coast</span> <span class="o">=</span> <span class="n">ds_coast</span><span class="p">[</span><span class="s2">&quot;F2x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">F2y_coast</span> <span class="o">=</span> <span class="n">ds_coast</span><span class="p">[</span><span class="s2">&quot;F2y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">gi_x</span>      <span class="o">=</span> <span class="n">ds_gi</span><span class="p">[</span><span class="s2">&quot;F2x_gi&quot;</span><span class="p">]</span>
        <span class="n">gi_y</span>      <span class="o">=</span> <span class="n">ds_gi</span><span class="p">[</span><span class="s2">&quot;F2y_gi&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">F2x_coast</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gi_x</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">gi_x</span> <span class="o">=</span> <span class="n">gi_x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">F2x_coast</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">gi_y</span> <span class="o">=</span> <span class="n">gi_y</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">F2y_coast</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">F2x_total</span> <span class="o">=</span> <span class="p">(</span><span class="n">F2x_coast</span> <span class="o">+</span> <span class="n">gi_x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">F2y_total</span> <span class="o">=</span> <span class="p">(</span><span class="n">F2y_coast</span> <span class="o">+</span> <span class="n">gi_y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="c1"># Build output dataset</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;F2x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F2x_total</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;F2y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F2y_total</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;F2x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Combined coastal + grounded-iceberg form factor, x-projection (cell-based)&quot;</span><span class="p">,</span>
                                    <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">})</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;F2y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Combined coastal + grounded-iceberg form factor, y-projection (cell-based)&quot;</span><span class="p">,</span>
                                    <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,})</span>
        <span class="c1"># Components</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;F2x_coast&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F2x_coast</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;F2y_coast&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F2y_coast</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;F2x_gi&quot;</span><span class="p">]</span>    <span class="o">=</span> <span class="n">gi_x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;F2y_gi&quot;</span><span class="p">]</span>    <span class="o">=</span> <span class="n">gi_y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="c1"># Carry through coastline lon/lat vectors if present</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;ncoast&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds_coast</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="n">ds_out</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_coast</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="c1"># Add GI metadata vectors (debug/traceability)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gi_lon&quot;</span><span class="p">,</span> <span class="s2">&quot;gi_lat&quot;</span><span class="p">,</span> <span class="s2">&quot;gi_i&quot;</span><span class="p">,</span> <span class="s2">&quot;gi_j&quot;</span><span class="p">,</span> <span class="s2">&quot;gi_cluster_id&quot;</span><span class="p">,</span> <span class="s2">&quot;gi_map_dist_m&quot;</span><span class="p">,</span> <span class="s2">&quot;gi_area_m2&quot;</span><span class="p">,</span> <span class="s2">&quot;gi_perim_m&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds_gi</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="n">ds_out</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_gi</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">ds_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;P_F2_coast_in&quot;</span>        <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">P_F2_coast</span><span class="p">),</span>
                            <span class="s2">&quot;P_GI_in&quot;</span>               <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">P_GI</span><span class="p">),</span>
                            <span class="s2">&quot;method_gi&quot;</span>             <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">method</span><span class="p">),</span>
                            <span class="s2">&quot;C_gi_default&quot;</span>          <span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">C_gi</span><span class="p">),</span>
                            <span class="s2">&quot;base_area_m2&quot;</span>          <span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">base_area_m2</span><span class="p">)</span> <span class="k">if</span> <span class="n">base_area_m2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                            <span class="s2">&quot;length_scale&quot;</span>          <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">length_scale</span><span class="p">),</span>
                            <span class="s2">&quot;dedup_uid&quot;</span>             <span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dedup_uid</span><span class="p">),</span>
                            <span class="s2">&quot;eps_cluster_km&quot;</span>        <span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">eps_cluster_km</span><span class="p">),</span>
                            <span class="s2">&quot;min_cluster_size&quot;</span>      <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_cluster_size</span><span class="p">),</span>
                            <span class="s2">&quot;cluster_buffer_m&quot;</span>      <span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">cluster_buffer_m</span><span class="p">)</span> <span class="k">if</span> <span class="n">cluster_buffer_m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                            <span class="s2">&quot;cluster_amplification&quot;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">cluster_amplification</span><span class="p">)})</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;logger&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Writing combined F2 (coast+GI): </span><span class="si">{</span><span class="n">P_out</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">clean</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">vv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nc_attr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clean</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vv</span>
        <span class="n">ds_out</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">clean</span>
        <span class="n">ds_out</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">P_out</span><span class="p">)</span>
        <span class="n">ds_coast</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ds_out</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Daniel Atwater.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>