<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>AFIM Lateral Drag Form Factor Methods</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">AFIM Lateral Drag Form Factor Methods</h1>
</header>
<h1
id="coastal-drag-form-factors-from-high-resolution-coastline-and-grounded-icebergs">Coastal-drag
form factors from high-resolution coastline and grounded icebergs</h1>
<p>This workflow constructs <strong>unitless coastal-drag form
factors</strong> ((F_{2x}, F_{2y})) on the <strong>CICE T-grid</strong>
using:</p>
<ol type="1">
<li>A <strong>high-resolution polygon coastline</strong> (Antarctic land
+ ice-shelf surfaces) to compute the <em>coast-only</em> form factors;
and</li>
<li>A <strong>grounded-iceberg polygon dataset</strong> to add sub-grid
obstacle form drag, producing a <em>combined</em> (coast + GI)
(F_2).</li>
</ol>
<p>The implementation follows the cell-based formulation of <strong>Liu
et al. (2022)</strong> for coastal geometry, then appends
grounded-iceberg contributions via a separate parameterisation.</p>
<hr />
<h2 id="definitions-and-target-quantities">1. Definitions and target
quantities</h2>
<p>For each T-cell ((i,j)), define two <strong>cell-based</strong> form
factors:</p>
<p>[ F_{2x}(i,j) ;=; _{n (i,j)} | <em>n <em>n |, F</em>{2y}(i,j) ;=;
</em>{n (i,j)} | _n _n |. ]</p>
<p>Where:</p>
<ul>
<li>(_n) is the <strong>geodesic length</strong> (m) of coastline
segment (n),</li>
<li>(x(i,j)), (y(i,j)) are <strong>local grid metric lengths</strong>
(m) on the T-grid,</li>
<li>(_n) is the <strong>segment orientation</strong> expressed in the
<strong>local model coordinate frame</strong>,</li>
<li>((i,j)) is the set of segments assigned to cell ((i,j)) by
nearest-neighbour mapping in a projected CRS.</li>
</ul>
<p>A convenient plotted diagnostic is the magnitude:</p>
<p>[ |F_2|(i,j) ;=; . ]</p>
<hr />
<h2 id="required-grid-geometry-cice-c-grid-file">2. Required grid
geometry (CICE C-grid file)</h2>
<p>The grid file supplies, per T-cell:</p>
<ul>
<li>T-cell centres: ((i,j)) (lon), ((i,j)) (lat),</li>
<li>local rotation angle: ((i,j)) (radians), and</li>
<li>metric lengths: (x(i,j)), (y(i,j)) (m).</li>
</ul>
<p><strong>Unit handling</strong> is robust: - lon/lat are inferred as
radians vs degrees by magnitude and converted to degrees if needed; -
(x,y) are converted to meters using metadata when available (cm → m is
supported).</p>
<p>Longitudes are normalised to ([-180^, 180^]) for stable Antarctic
projection transforms.</p>
<hr />
<h2
id="coastline-ingestion-and-conditioning-high-res-polygon-shapefile">3.
Coastline ingestion and conditioning (high-res polygon shapefile)</h2>
<h3 id="feature-filtering">3.1 Feature filtering</h3>
<p>The coastline layer is filtered by <code>surface</code> classes to
retain only polygonal coastal boundaries representing: -
<code>land</code>, <code>ice shelf</code>, <code>ice tongue</code>,
<code>rumple</code>.</p>
<h3 id="geometry-repair-and-dissolve">3.2 Geometry repair and
dissolve</h3>
<p>To avoid artefacts from internal polygon boundaries (e.g.,
grounding-line edges between land and ice shelf polygons), geometries
are optionally: - repaired (e.g., <code>make_valid</code> or
<code>buffer(0)</code> fallback), then - <strong>dissolved /
unioned</strong> in the native projected CRS prior to reprojection.</p>
<h3 id="exterior-rings-as-lonlat">3.3 Exterior rings as lon/lat</h3>
<p>The dissolved geometry is reprojected to EPSG:4326 and each polygon’s
<strong>exterior ring</strong> is emitted as a vertex sequence: [ (_k,
<em>k)</em>{k=1}^K, ] with consecutive vertices forming line
segments.</p>
<hr />
<h2 id="segment-geometry-on-the-sphere-wgs84-geodesic">4. Segment
geometry on the sphere (WGS84 geodesic)</h2>
<p>For each coastline segment connecting ((_0,_0)) → ((_1,_1)):</p>
<ul>
<li>compute geodesic distance () (m), and</li>
<li>compute forward azimuth (az) (degrees, clockwise from north).</li>
</ul>
<p>The implementation converts azimuth to a segment angle in
<strong>east-north</strong> convention: [ ;=; (90^- az), ] so ()
corresponds to +east.</p>
<hr />
<h2 id="assigning-segments-to-model-cells-projected-kdtree">5. Assigning
segments to model cells (projected KDTree)</h2>
<h3 id="project-to-antarctic-crs">5.1 Project to Antarctic CRS</h3>
<p>Segment endpoints are projected to an Antarctic planar CRS (default
EPSG:3031). Segment midpoints: [ (x_m, y_m) ;=; (x_0+x_1,, y_0+y_1) ]
are used for mapping.</p>
<h3 id="kdtree-over-selected-t-cells">5.2 KDTree over selected
T-cells</h3>
<p>A KDTree is built from projected T-cell centres ((x_{ij}, y_{ij})),
with optional restrictions:</p>
<ul>
<li>latitude subset: ((i,j) _{}) (default (-30^)) for Antarctic
relevance/performance;</li>
<li>optionally restrict the KDTree to <strong>coastal-ocean
cells</strong> only (ocean band within a small dilation of land), to
reduce erroneous assignment to interior grounding-line/ice-shelf
regions.</li>
</ul>
<p>Each segment midpoint is assigned to the nearest KDTree T-cell;
assignments beyond a maximum distance are rejected: [ d_{} d_{} d_{}=50.
]</p>
<hr />
<h2 id="local-angle-transform-and-accumulation">6. Local-angle transform
and accumulation</h2>
<p>For a segment assigned to cell ((i,j)), the <strong>local</strong>
segment angle is: [ ;=; ;-; (i,j), ] where ((i,j)) is the grid rotation
angle.</p>
<p>The segment contributes projected lengths: [ s_x ;=; ||, s_y ;=; ||.
]</p>
<p>Accumulators sum these within each cell: [ S_x(i,j)=s_x,
S_y(i,j)=s_y, ] and final coast-only form factors are: [
F_{2x}^{}(i,j)=, F_{2y}^{}(i,j)=. ]</p>
<p>The coast-only output NetCDF stores (F_{2x}^{}, F_{2y}^{}), plus
(optionally thinned) coastline vertices for provenance.</p>
<hr />
<h2 id="grounded-iceberg-gi-contributions-from-a-polygon-geopackage">7.
Grounded-iceberg (GI) contributions from a polygon GeoPackage</h2>
<p>Kaihong’s grounded iceberg dataset is provided as polygons in
EPSG:3031. For each polygon (p):</p>
<ul>
<li>geometry area (A_p) (m(^2)) and perimeter (P_p) (m) are computed
directly from the geometry;</li>
<li>an attribute area (e.g., <code>Area_Mean_km2</code>) may be used
when present, falling back to geometry area if missing;</li>
<li>features can be <strong>deduplicated by unique ID</strong> (e.g.,
<code>Global_UID</code>) to avoid multiple detections of the same
iceberg.</li>
</ul>
<p>Each grounded iceberg is mapped to the nearest T-cell using the same
projected KDTree strategy, with a maximum mapping distance
constraint.</p>
<h3 id="default-simple-geometry-gi-parameterisation">7.1 Default
“simple-geometry” GI parameterisation</h3>
<p>Each mapped iceberg contributes an <strong>isotropic projected length
scale</strong> (L_p) to both directions, scaled by a tunable coefficient
(C_{}):</p>
<p>[ F_{2x}^{}(i,j) ;{+}{=}; C_{} , F_{2y}^{}(i,j) ;{+}{=}; C_{} . ]</p>
<p>The default (L_p) is based on perimeter where available:</p>
<p>[ L_p ;=; P_p, ]</p>
<p>which corresponds to an isotropic mean absolute projection assumption
(using ([||]=2/) for uniformly distributed ()).</p>
<p>If perimeter is missing/unusable, a circular-equivalent scale derived
from area is used:</p>
<p>[ L_p ;=; 4. ]</p>
<p>This method produces (F_{2x}^{}) and (F_{2y}^{}) plus diagnostics
(mapped cell indices, mapping distances, area/perimeter vectors, and
per-cell GI counts).</p>
<h3
id="optional-cluster-axis-gi-parameterisation-for-dense-gi-fields">7.2
Optional “cluster-axis” GI parameterisation (for dense GI fields)</h3>
<p>A second option clusters nearby grounded icebergs (DBSCAN-like) in
projected space, estimates principal axes via PCA, and distributes an
oriented cluster-scale contribution back to members. This is intended
for treating densely packed iceberg “fields” as anisotropic obstacles.
In the current workflow, <strong>simple-geometry</strong> is used.</p>
<hr />
<h2 id="combined-coast-gi-form-factors-and-netcdf-outputs">8. Combined
coast + GI form factors and NetCDF outputs</h2>
<p>The final combined form factors are:</p>
<p>[ F_{2x} ;=; F_{2x}^{} + F_{2x}^{}, F_{2y} ;=; F_{2y}^{} + F_{2y}^{}.
]</p>
<p>The combined NetCDF includes: - totals: (F_{2x}, F_{2y}), -
components: (F_{2x}^{}, F_{2y}^{}, F_{2x}^{}, F_{2y}^{}), - coastline
vertex vectors (if stored), and - GI diagnostic vectors (if
enabled).</p>
<p>Key tunables include: - coastline-to-cell mapping CRS and max
distance, - coastal-ocean band restriction (buffer cells), - GI scaling
(C_{}), - GI length-scale definition (perimeter vs area), - optional
clustering controls (if cluster-axis is enabled).</p>
<hr />
<h2 id="practical-interpretation">9. Practical interpretation</h2>
<ul>
<li>Large (F_2) values typically occur where the coastline (or dense GI)
is geometrically complex within/near a cell, implying stronger
parameterised form drag.</li>
<li>The result is <strong>cell-based</strong> (T-grid) by construction;
conversion to velocity points (u/v) can be deferred to the dynamical
core as needed.</li>
</ul>
<hr />
</body>
</html>
